# 안전지대

```Java
class Solution {
    public int solution(int[][] board) {
        int n = board.length;
        // 위험 지역을 표시할 새로운 배열 (0: 안전, 1: 위험)
        int[][] dangerZone = new int[n][n];

        // 8방향 설정을 위한 좌표 배열 (상, 하, 좌, 우, 대각선 4방향)
        int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};
        int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                // 지뢰를 발견하면
                if (board[i][j] == 1) {
                    dangerZone[i][j] = 1; // 자기 자신 마킹
                    
                    // 주변 8방향 마킹
                    for (int k = 0; k < 8; k++) {
                        int nx = i + dx[k];
                        int ny = j + dy[k];

                        // 배열 범위 안인지 확인
                        if (nx >= 0 && nx < n && ny >= 0 && ny < n) {
                            dangerZone[nx][ny] = 1;
                        }
                    }
                }
            }
        }

        // 안전한 지역(0) 개수 세기
        int answer = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dangerZone[i][j] == 0) {
                    answer++;
                }
            }
        }

        return answer;
    }
}
```

## 지뢰 탐색 로직
1. dx, dy 배열을 사용하여 지뢰 주변 8방향의 상대 좌표를 정의한다.
2. 이중 반복문으로 지뢰(1)의 위치를 찾는다.
3. 지뢰 위치 (i, j)에 상대 좌표를 더해 주변 칸 (nx, ny)를 구한다.
4. nx, ny가 배열 크기 n 내부에 있을 때만 위험 지역으로 기록한다.
5. 최종적으로 기록되지 않은 칸의 총합을 구한다.

## 8방향
| 방향 | dx (행 변화) | dy (열 변화) | 최종 좌표 (상대 위치) |
| :--- | :---: | :---: | :--- |
| **왼쪽 위 대각선** | -1 | -1 | `(i-1, j-1)` |
| **위(북)** | -1 | 0 | `(i-1, j)` |
| **오른쪽 위 대각선** | -1 | 1 | `(i-1, j+1)` |
| **왼쪽(서)** | 0 | -1 | `(i, j-1)` |
| **오른쪽(동)** | 0 | 1 | `(i, j+1)` |
| **왼쪽 아래 대각선** | 1 | -1 | `(i+1, j-1)` |
| **아래(남)** | 1 | 0 | `(i+1, j)` |
| **오른쪽 아래 대각선** | 1 | 1 | `(i+1, j+1)` |