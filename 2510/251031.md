# 251031 TIL

## static 키워드의 의미와 사용 시 주의사항은 무엇인가요?

### `static`

- 해당 클래스의 인스턴스가 아니라 클래스 자체에 속함
- 인스턴스(객체)를 생성하지 않아도 접근 가능하고, 해당 클래스의 모든 인스턴스가 동일한 static 변수 하나를 공유

| 구분 | 주의사항 (제한 사항) | 모범 사례 (Best Practice) |
|------|------------------------|-----------------------------|
| **static 메서드** | static 메서드 내에서는 `this`나 `super` 키워드를 사용할 수 없으며, 비-static 멤버 변수나 메서드에 직접 접근할 수 없습니다. *(객체 없이 존재하므로)* | 유틸리티 메서드(예: 수학 연산, 헬퍼 기능)나 팩토리 메서드를 만들 때 사용합니다. |
| **static 변수** | 변경 가능한(mutable) static 변수는 사용에 주의해야 합니다. 모든 스레드가 공유하여 **스레드 안전성(Thread Safety)** 문제가 발생할 수 있습니다. | **상수(`public static final`)**나 모든 객체가 공유해야 하는 공통 설정 값(예: 카운터, 로그 레벨)에 사용합니다. |
| **일반 원칙** | **다형성(Polymorphism)**이 필요한 메서드(오버라이딩을 통해 동작이 바뀌어야 하는 메서드)에는 static을 사용하지 않습니다. | 코드 재사용성을 높이고 메모리 효율성을 개선하는 데 중점을 두고 사용합니다. |


## final, finally, finalize의 차이점을 설명해주세요.

| 키워드／메서드            | 의미                                                                         | 사용 대상                                     | 특징 / 주의사항                                                                                        |
| ------------------ | -------------------------------------------------------------------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------ |
| `final` (키워드)      | 변수, 메서드, 클래스에 적용되어 변경이나 상속 또는 재정의를 막음                                      | 변수, 메서드, 클래스                              | 변수: 값 변경 불가 → 상수화 가능 <br> 메서드: 오버라이드 불가 <br> 클래스: 상속 불가 ([GeeksforGeeks][1])                     |
| `finally` (블록)     | 예외 처리시 `try` 또는 `try-catch` 뒤에 오는 블록으로, 예외가 발생하든 안 하든 항상 실행됨               | `try { … } catch (…) { … } finally { … }` | 리소스 해제, 정리 코드 등에 적합. 예외 발생 여부와 관계없이 실행됨. ([GeeksforGeeks][1])                                    |
| `finalize()` (메서드) | `java.lang.Object` 클래스의 메서드로, 객체가 가비지 컬렉션(GC) 대상이 되기 직전에 호출되어 정리 작업을 수행 가능 | 객체 (클래스가 오버라이드)                           | **현재는 사용 권장 안 됨**: Java 9부터 deprecated, Java 18에서는 제거됨. GC 호출 시점도 보장되지 않음. ([javaguides.net][2]) |

[1]: https://www.geeksforgeeks.org/java-final-finally-and-finalize/?utm_source=chatgpt.com "Java final, finally and finalize - GeeksforGeeks"
[2]: https://www.javaguides.net/2023/11/difference-between-final-finally-and-finalize-in-java.html?utm_source=chatgpt.com "Difference between final, finally, and finalize in Java"

## 추상 클래스와 인터페이스의 차이점과 사용 시나리오를 설명해주세요.

| 항목           | 추상 클래스(Abstract Class)                                      | 인터페이스(Interface)                                                                              |
| ------------ | ----------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| 선언 키워드       | `abstract class ClassName { … }`                            | `interface InterfaceName { … }`                                                               |
| 객체 생성        | 직접 인스턴스화 불가 (`new AbstractClass()` 불가)                      | 직접 인스턴스화 불가 (`new InterfaceName()` 불가)                                                        |
| 메서드 구현       | 추상 메서드(선언만) + 일반 메서드(구현 포함) 모두 가질 수 있음 ([GeeksforGeeks][1]) | Java 8 이전엔 추상 메서드만 가능했으나, Java 8 이후부터는 `default` 메서드와 `static` 메서드도 가능함 ([Java Tech Blog][2]) |
| 멤버 변수        | 인스턴스 변수, 정적 변수 모두 가능 (final 아니어도 됨) ([javaguides.net][3])   | 변수는 자동으로 `public static final`(상수)이며, 인스턴스 필드 가질 수 없음 ([GeeksforGeeks][1])                    |
| 상속 및 구현      | 클래스는 한 개의 클래스(추상 포함)를 상속할 수 있음 `(extends)`                  | 클래스는 여러 개의 인터페이스를 구현 가능 `implements` (다중 구현) ([Guru99][4])                                    |
| 생성자          | 생성자 가질 수 있음 (자식 클래스 호출됨) ([Baeldung on Kotlin][5])          | 생성자 가질 수 없음                                                                                   |
| 상태(state) 유지 | 멤버 변수로 상태 유지 가능                                             | 인스턴스 상태를 가질 수 없고, 상수만 가짐                                                                      |
| 설계 목적        | “~이다(…이다)” 관계, 기본 동작 제공하고 일부만 자식에게 위임할 때                    | “~할 수 있다(…할 수 있다)” 또는 행위(behavior) 정의할 때, 더 느슨한 계약 계약(Capability) 설계                          |

[1]: https://www.geeksforgeeks.org/difference-between-abstract-class-and-interface-in-java/?utm_source=chatgpt.com "Difference Between Abstract Class and Interface in Java - GeeksforGeeks"
[2]: https://javanexus.com/blog/abstract-class-vs-interface-java?utm_source=chatgpt.com "Abstract Class vs Interface: Choosing the Right One in Java | Java Tech Blog"
[3]: https://www.javaguides.net/2023/11/abstract-class-vs-interface-in-java.html?utm_source=chatgpt.com "Difference Between Abstract Class and Interface in Java"
[4]: https://www.guru99.com/interface-vs-abstract-class-java.html?utm_source=chatgpt.com "Difference Between Abstract Class and Interface in Java"
[5]: https://www.baeldung.com/java-interface-vs-abstract-class?utm_source=chatgpt.com "Using an Interface vs. Abstract Class in Java | Baeldung"

- 추상 클래스를 사용할 때
    - 여러 클래스들이 공통으로 갖는 필드나 구현(메서드)을 공유해야 할 경우. 예컨대 Animal이라는 추상 클래스가 있고, move(), eat() 같은 기본 메서드는 구현되어 있고, makeSound() 같은 메서드는 자식 클래스마다 다르게 구현해야 할 때.
    - 상태(멤버 변수)나 공통 구현이 필요한 경우에 적합.
    - 클래스 상속 관계가 명확하고, 자식 클래스가 하나의 유사한 계층 구조에 있을 때.

- 인터페이스를 사용할 때
    - 클래스가 여러 ‘능력(capability)’을 가질 수 있을 때. 예컨대 Drivable, Flyable, Swimmable 같은 인터페이스를 하나의 클래스가 여러 개 구현 가능.
    - 구현하고자 하는 클래스가 서로 상관 관계(공통의 슈퍼클래스)가 약하거나, 단지 특정 메서드 계약만 보장하면 될 때.
    - 라이브러리 설계 시, 구현 클래스가 여러 가지가 있고, 사용자 코드가 인터페이스에만 의존하도록 설계하고 싶을 때.

## Java 8 이후 인터페이스의 default 메서드와 static 메서드에 대해 설명해주세요.
- 기존에는 인터페이스에 메서드 구현(바디)이 존재할 수 없었기 때문에, 인터페이스를 변경하면 이를 구현한 모든 클래스에 영향을 주어 호환성이 깨질 위험이 있었음
- Java 8 이후 인터페이스 내부에 구현된 메서드(`default`, `static`)를 허용

### `default` 
- 인터페이스에서 default 키워드를 사용해 기본 구현이 있는 메서드를 정의
- 구현 클래스가 이 메서드를 오버라이드할 수도 있고, 하지 않아도 인터페이스에 정의된 기본 구현이 실행 
- 주된 용도는 “기존 인터페이스에 새로운 메서드를 추가하더라도 기존 구현 클래스가 영향을 덜 받게 하기(Backward compatibility)

- 주의사항: 다중 인터페이스 구현 시에 동일한 메서드 시그니처의 default 메서드가 상충(conflict)할 수 있으며, 구현 클래스에서 이를 명시적으로 해결(오버라이드)

### `static`
- 인터페이스 내부에 static 메서드를 선언할 수 있으며, 이는 인터페이스명으로 직접 호출할 수 있고 구현 클래스에서 오버라이드할 수 없음
- 일반적으로 인터페이스 관련 유틸리티 메서드를 제공할 때 유용
- 호출 방법 예: InterfaceName.staticMethod()
- 주의사항: 인터페이스 static 메서드는 인스턴스의 컨텍스트(this)를 갖지 않으며, 구현 클래스의 인스턴스를 통해 호출되지 않아야함.