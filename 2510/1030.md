# 251030 TIL

## JVM의 구조와 동작 원리에 대해 설명해주세요. 

### 구조
| 컴포넌트         | 주요 역할                                                                                                     |
| ------------ | --------------------------------------------------------------------------------------------------------- |
| 클래스 로더 서브시스템 | .class 파일을 읽어들이고, 적절한 타입 정보를 JVM 내에 로드하는 기능                                                               |
| 런타임 데이터 영역   | 메소드 영역, 힙(Heap), 스택(Stack), PC Register, 네이티브 메서드 스택 등의 메모리 영역을 제공 ([Ajay Negi Portfolio][1])             |
| 실행 엔진        | 바이트코드를 해석(interpreter)하거나 JIT(Just-In-Time) 컴파일하고, 네이티브 메서드 인터페이스(JNI) 등을 통한 실행을 책임짐 ([Mouaad Aallam][2]) |

[1]: https://ajaynegi.web.app/blog/jvm-architecture/?utm_source=chatgpt.com "How Does Java Really Work? Inside the JVM Architecture"
[2]: https://mouaad.aallam.com/java-virtual-machine-architecture/?utm_source=chatgpt.com "JVM Architecture | Mouaad Aallam"

### 동작순서

1. 자바 소스코드 → 컴파일러(javac) → 바이트코드(.class)
2. JVM이 클래스 로더를 통해 해당 바이트코드를 로드
3. 런타임 데이터 영역에 타입 정보, 객체, 스레드 등의 메모리 할당
4. 실행 엔진이 바이트코드를 기계어로 변환하거나 직접 해석하여 실행
5. 힙 영역에서 객체 생성 및 GC로 메모리 관리

### 메모리 구조
- 힙(Heap): 객체 인스턴스가 생성되는 공간. 모든 스레드가 공유. 
- 스택(Stack): 각 스레드마다 존재하며 메소드 호출 시 프레임이 생성됨. 지역변수, 연산스택, 프레임데이터 저장. 
- 메소드 영역(Method Area, 또는 Metaspace in Java8+): 클래스 수준 정보(런타임 상수풀, 필드/메소드 정보, 정적 변수 등) 저장. 

### 실행 엔진 내부

- 인터프리터(Interpreter): 바이트코드를 한 줄씩 해석해서 실행
- JIT 컴파일러: 반복 호출되는 메소드 등을 네이티브 머신코드로 변환하여 성능 향상
- 가비지 컬렉터(GC): 사용하지 않는 객체를 자동으로 회수하며 메모리 누수를 방지

```plain
“JVM은 자바 바이트코드를 플랫폼에 독립적으로 실행하기 위한 가상머신으로, 클래스 로딩부터 실행, 메모리 관리를 모두 책임집니다. 메모리는 힙·스택·메소드 영역으로 나뉘며, 실행 엔진은 인터프리터와 JIT를 통해 최적화 실행을 합니다.”
```

## Garbage Collection의 동작 원리와 종류에 대해 설명해주세요. 

### 동작원리
1. 마크(Mark): 루트(Roots: 스레드 스택, 정적 변수, JNI 레퍼런스 등)로부터 참조되는 객체들을 추적하여 ‘살아있는 객체(live objects)’로 표시

2. 스윕/재활용(Sweep/Compact): 표시되지 않은 객체(즉, 더 이상 참조되지 않는 객체)를 메모리에서 제거하고, 필요 시 공간을 압축(compaction)하여 단편화 줄임

- JVM 구현에 따라 세대(young/old generations), 영역(region) 등을 이용해 최적화

### 종류
| GC 이름                                 | 특징 및 사용 용도                                                                                                                      |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| Serial GC                             | 단일 스레드로 동작하며 “stop-the-world”(모든 애플리케이션 스레드 정지) 방식. 작은 힙이나 단일 스레드 환경에 적합. ([GeeksforGeeks][1])                                  |
| Parallel GC (또는 Throughput Collector) | 여러 GC 스레드를 사용해 병렬로 마크/스윕. 처리량(throughput)을 중시하는 환경에 적합. ([GeeksforGeeks][1])                                                    |
| CMS (Concurrent Mark-Sweep)           | Old 세대 수집을 병행(concurrent)으로 처리하여 일시 중단(pause)를 줄이려는 목적. 다만 단편화(compaction)가 약하고 최근엔 deprecated 되었습니다. ([www.tpointtech.com][2]) |
| G1 (Garbage-First) GC                 | 힙을 여러 region(구역)으로 나누어 가장 먼저(First) 가비지가 많은 영역을 수집하는 전략. 자바9 이후 기본 GC가 되었습니다. ([위키백과][3])                                       |
| ZGC / Shenandoah                      | 매우 낮은 지연(latency)을 요구하는 애플리케이션용. 대부분의 작업을 애플리케이션 스레드와 병행 수행. ([kaksha.dev][4])                                                  |

[1]: https://www.geeksforgeeks.org/java/types-of-jvm-garbage-collectors-in-java-with-implementation-details/?utm_source=chatgpt.com "JVM Garbage Collectors - GeeksforGeeks"
[2]: https://www.tpointtech.com/types-of-garbage-collector-in-java?utm_source=chatgpt.com "Types of Garbage Collector in Java - Tpoint Tech"
[3]: https://en.wikipedia.org/wiki/Garbage-first_collector?utm_source=chatgpt.com "Garbage-first collector"
[4]: https://kaksha-dev.github.io/java/gc?utm_source=chatgpt.com "Introduction to Java Garbage Collection | kaksha.dev"


## G1 GC와 다른 GC 알고리즘의 차이점은 무엇인가요? 
### G1 GC의 특징
- 힙을 동일 크기의 Region(구역) 으로 나눕니다. 
- 가비지가 많이 쌓인 Region을 우선적으로 수집하는 방식(“Garbage-First”)을 채택합니다. 
- Young Generation/Old Generation 구분을 하면서도 Region 재할당이 가능하여 유연합니다.
- Old Generation 수집 시 CMS 대비 단편화가 적고, 전체 Full-GC를 줄이는 경향이 있습니다.

### 차이점
| 비교 대상              | G1 GC와의 차이                                                                                                                                                                    |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Parallel/Serial GC | Parallel GC 등은 Young/Old를 구분하긴 하지만, Old 세대에서는 전체 힙을 한꺼번에 수집하거나 압축하는 경우가 많아 정지시간이 클 수 있습니다. 반면 G1은 여러 Region으로 나누어 수집하여 더 짧은 정지시간을 목표로 합니다. ([Oracle Docs][1])                 |
| CMS                | CMS는 Old 세대 수집을 병행(concurrent)으로 처리해 정지시간을 줄이려 했으나 단편화가 발생하면 결국 긴 Full-GC가 발생할 수 있습니다. 반면 G1은 “빈 region을 우선 수거”하고 압축(compaction) 기능을 자연스럽게 포함해 그 위험을 줄입니다. ([Oracle Docs][1]) |
| ZGC/Shenandoah     | 이들은 매우 낮은 정지시간(싱글 밀리초 이하)을 목표로 설계되어 있고 대부분의 작업을 애플리케이션 실행과 병행으로 처리합니다. G1도 낮은 정지시간을 목표로 하지만 ZGC 수준의 초저지연은 아닙니다. ([Arm Learning Paths][2])                                     |

[1]: https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-g1-garbage-collector1.html?utm_source=chatgpt.com "Garbage-First Garbage Collector"
[2]: https://learn.arm.com/learning-paths/servers-and-cloud-computing/java-gc-tuning/different_gcs/?utm_source=chatgpt.com "Types of Garbage Collector | Arm Learning Paths"

### 언제 G1을 선택하는가?

- 힙이 수 기가바이트 이상이면서 응답성(pause time)도 고려가 필요한 서버 애플리케이션
- CMS가 단편화 문제나 Full-GC 문제로 부담이 될 때
- 기본 GC 설정만으로 안정성을 확보하고 싶을 때 (자바9 이상에서 기본값)

## Java의 클래스 로딩 과정을 설명해주세요.

### 과정
- `로딩(Loading)` → `링크(Linking)` → `초기화(Initialization)`

1. `로딩(Loading)`
- 클래스 파일(.class)을 읽고 바이트코드를 메모리로 가져와서 JVM의 메소드 영역(또는 Metaspace) 내에 타입 정보로 생성
- 이때 클래스 로더 체계(부트스트랩, 플랫폼/확장, 애플리케이션)가 사용

2. `링크(Linking)`
2-1. 검증(Verification): 클래스 파일이 자바 언어 명세와 JVM명세에 맞게 만들어졌는지 검사. 
2-2. 준비(Preparation): 클래스 변수(static 변수 등) 메모리 할당 및 기본값 초기화
2-3. 해결(Resolution): 상수풀(Constant Pool) 내의 심볼릭 참조(예: 클래스명, 필드명, 메소드명)를 실제 메모리 주소 등으로 변환하는 작업. (해당 단계는 지연(lazy) 방식으로 구현되기도 함) 


3. `초기화(Initialization)`
- 클래스의 정적 초기화 블록(static {})이나 static 변수의 명시적 초기화 구문이 실행되는 단계
- 초기화는 해당 클래스가 최초로 ‘사용’될 때 수행(예: `new`, `static` 필드 접근, `static`메소드 호출 등) 
- 부모 클래스가 먼저 초기화된 후 자식 클래스가 초기화