# 251020 TIL

## 동시성(Concurrency)과 병렬성(Parallelism)의 차이점은 무엇인가요?
| 항목      | 동시성(Concurrency)                                                 | 병렬성(Parallelism)                                            |
| ------- | ---------------------------------------------------------------- | ----------------------------------------------------------- |
| 개념      | 여러 작업이 **겹쳐서 진행 가능한 상태**                                         | 여러 작업이 **실제로 동시에 실행되는 상태**                                  |
| 실행 방식   | 단일 혹은 복수 코어에서 컨텍스트 스위칭 혹은 스레드 관리로 작업이 겹쳐 보임  | 여러 프로세서/코어에서 각 작업이 동시에 실행됨             |
| 주된 목적   | 응답성 향상, 작업 구조화 (I/O 바운드 환경 등)              | 처리량(througput) 증가, 계산 속도 개선 (CPU 바운드 환경)    |
| 하드웨어 요건 | 여러 작업 가능하지만 반드시 여러 코어가 필요하진 않음     | 여러 코어/프로세서가 있어야 진정한 병렬성 가능         |
| 구현 예시   | 단일 코어에서 여러 스레드가 번갈아 실행됨                                          | 쿼드코어 CPU에서 4개의 스레드가 각기 다른 코어에서 동시에 실행됨  |

- 설계 시에는 “동시성 있는 구조(concurrent design)”를 만들고, 그것이 실제로 “병렬 처리(parallel execution)”로 이어질 수 있도록 코어 수, 스레드 수, 작업 분할(task decomposition) 등을 고려
- I/O 대기 시간(데이터베이스, 네트워크 등)이 많은 웹서버 애플리케이션에서는 동시성이 중요하고, 대용량 데이터 처리·연산이 많은 배치 프로세스에서는 병렬성이 중요

## Race Condition과 Deadlock에 대해 설명해주세요.

### Race Condition (경쟁 상태)
- 정의 : 둘 이상의 프로세스나 스레드가 **공유 자원(Shared Resource)**에 동시 접근하여 자원을 읽거나 쓰는 경우, **실행 순서(Timing)**에 따라 프로그램의 결과가 달라지는 상황
- 예시 : 두 스레드가 동일한 카운터 변수를 동시에 1씩 증가시키려고 할 때, 최종 값이 예상보다 작게 나옴
- 원인  
    - 공유 변수 또는 자원이 스레드 간에 동기화 없이 사용될 때
    - 연산이 원자적(atomic)이지 않을 때 (예: count++는 내부적으로 읽기→증가→쓰기라는 세 단계 연산) 
    - 스레드 실행 순서나 콘텍스트 스위칭이 예측 불가능할 때
- 예방방법 
    - `synchronized` 메서드/블록을 사용하여 임계구역(critical section)을 보호
    - `Java.util.concurrent.locks.Lock` 또는 `ReentrantLock`, `AtomicInteger` 등의 원자형(atomic) 클래스를 사용
    - 공유 자원에 대한 접근을 **임계 영역(Critical Section)**으로 설정하고, 한 번에 하나의 스레드만 접근하도록 동기화

### Deadlock (교착 상태)
- 정의 : 둘 이상의 프로세스 또는 스레드가 서로 상대방이 점유하고 있는 자원을 기다리고 있어서, 모두가 무한히 대기 상태에 빠져 더 이상 진행하지 못하는 상황
- 예시 
    ```
    스레드 A는 자원 $R_1$을 소유하고 자원 $R_2$를 대기
    스레드 B는 자원 $R_2$를 소유하고 자원 $R_1$을 대기 
    이 경우, A도 B도 진행할 수 없으며 무기한 대기 상태에 빠집니다. 
    ```
- 발생조건
    1. 상호 배제 (Mutual Exclusion) : 자원은 한 번에 하나의 프로세스만 사용할 수 있음
    2. 점유 및 대기 (Hold and Wait) : 자원을 소유한 상태에서 다른 자원을 기다림
    3. 비선점 (No Preemption) : 자원은 강제로 빼앗을 수 없으며, 소유자가 작업을 마친 후 자발적으로 해제해야 함
    4. 순환 대기 (Circular Wait) : 대기 중인 프로세스들이 순환적으로 자원을 기다림
- 예방방법
    - **자원 획득 순서(lock‑ordering)**를 일관성 있게 정해 데드락 가능성 제거
    - `Lock.tryLock(timeout)` 같은 타임아웃 방식 사용