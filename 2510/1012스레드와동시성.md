# 스레드와 동시성

## 동시성 (Concurrency)
여러 작업이 동시에 진행되는 것처럼 보이도록 작업을 번갈아 수행

## 병렬성 (Parallelism)
여러 작업을 실제로 동시에 실행(멀티코어 사용)

- 단일 코어에서는 동시성은 구현 가능하지만 병렬성은 불가능하다.
- 동시성은 구조와 설계 관점, 병렬성은 실행 관점이다.

## 스레드 관련 문제
- 경쟁 조건(race condition) :여러 스레드가 동일한 자원에 접근할 때 동기화 안 하면 오류 발생

- 데드락 (Deadlock) : 서로 락을 쥐고 대기하면서 영원히 멈추는 상태

- 기아 (Starvation) : 어떤 스레드가 계속 자원을 못 얻어 실행되지 못하는 상태

- 우선순위 역전 (Priority Inversion): 낮은 우선순위 스레드가 락을 잡고 있어서 높은 우선순위 스레드가 대기해야 하는 상황

- 컨텍스트 스위칭 비용 및 캐시 미스 : 스레드가 너무 많으면 오히려 성능 저하

- 메모리 가시성 / 메모리 모델 : 최신 CPU / 캐시 구조에서 변수 읽고 쓰는 순서가 보장 안 될 수 있어서 volatile, synchronized, 메모리 배리어 등을 적절히 써야 함

- 리소스 누수 / 스레드 누수 : 스레드 종료 안 하거나 풀 관리가 잘못돼서 자원 낭비

- 스레드 풀 크기 조정 : 요청량, I/O 대기 비율, CPU 개수 등을 고려해서 적절히 설정해야 해

- 스레드 당 자원 사용량 : 스택 크기, 로컬 변수, TLS (Thread-local storage) 등도 고려

## 스레드 생성
1. Thread 클래스 상속
```Java
class MyThread extends Thread {
    public void run() {
        System.out.println("Hello from thread: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();  // run()이 아닌 start() 호출해야 새로운 스레드에서 실행됨
    }
}
```

2.Runnable 인터페이스
```Java
public class Main {
    public static void main(String[] args) {
        Runnable task = () -> System.out.println("Runnable running in " + Thread.currentThread().getName());
        Thread t = new Thread(task);
        t.start();
    }
}

```