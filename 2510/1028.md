# 251028 TIL

## Call by Value와 Call by Reference의 차이점을 설명해주세요.
- Call by Value(값에 의한 호출)”란 메서드에 인자로 변수의 **값(복사본)**을 넘기는 방식입니다.
- Call by Reference(참조에 의한 호출)란 인자로 변수의 주소 또는 참조를 넘겨서 메서드 내부에서 인자로 받은 식별자가 원본 변수를 직접 가리키는 방식입니다.
- 그러나 Java 에서는 모든 인자 전달이 값에 의한 전달(call by value) 방식입니다. 객체를 넘길 때도 참조(주소) 값의 복사본을 넘기므로 “진정한 참조에 의한 호출(call by reference)”은 아닙니다. 
- 객체의 상태는 변경 가능”하지만 “참조 자체를 바꿀 수 없다”는 점이 중요합니다. 

| 구분 | Call by Value | Call by Reference |
|------|--------------|-------------------|
| 전달 방식 | 인자의 값 복사 전달 | 인자의 주소(참조) 전달 |
| 원본 변경 가능성 | 메서드 내부 변경이 원본에 영향 없음 | 메서드 내부 변경이 원본에 영향 있음 |
| 메모리 위치 | 실제 인자와 형식 인자가 다른 메모리 위치 | 실제 인자와 형식 인자가 같은 메모리 위치 |
| Java 지원 여부 | 지원됨 | Java에서 진정한 방식은 지원되지 않음 (참조값의 복사만 있음) |


## 메모리 누수(Memory Leak)가 발생하는 원인과 방지 방법은 무엇인가요?

### 메모리 누수(Memory Leak)
- Java 같은 가비지 컬렉션(GC) 환경에서도 더 이상 사용되지 않는 객체가 여전히 참조되어 있어 GC의 대상이 되지 못하고 메모리가 회수되지 않는 상태

### 원인
1. 불필요한 참조 유지 : 더 이상 쓰지 않는 객체에 참조가 남아 있어서 GC 대상이 되지 않음. 


2. Static 필드나 컬렉션에 객체 누적 : 애플리케이션 생명주기 동안 살아 있는 static 참조가 객체를 계속 유지함. 

3. 리스너(listener), 콜백(callback) 등록 후 해제 누락 : 이벤트 리스너 등이 해제되지 않고 참조가 남아 있음. 


4. ThreadLocal 사용 후 remove() 누락 : 스레드 풀처럼 재사용되는 스레드 내 스레드로컬 값이 남아 메모리 누수 유발. 

5. 리소스(스트림, DB 커넥션 등) 미반납 : 네이티브 리소스나 외부 리소스가 열려 있고 닫히지 않아 메모리 또는 핸들이 남음.

### 방지방법
- 객체 사용이 끝나면 참조를 null로 설정하거나 범위를 벗어나게 함. 

- 컬렉션 또는 캐시 사용 시 크기 제어나 만료(eviction) 정책 도입. 

- 리스너 등록 시 해제하고, 내부 클래스를 사용할 땐 외부 참조를 피하거나 static 클래스를 고려. 

- ThreadLocal 사용 완료 후 remove() 호출.

- 자바 7 이상에서는 try-with-resources 문을 사용하여 스트림/DB 커넥션 등의 리소스를 자동으로 닫도록 함. 

- 메모리 프로파일링 도구(예: VisualVM, Eclipse Memory Analyzer)로 힙 덤프 분석

| 구분 | 원인 | 방지 방법 |
|------|------|-----------|
| 불필요한 참조 유지 | 사용이 끝난 객체가 참조되어 있음 | 참조 삭제, 변수 범위 좁히기 |
| Static 필드/컬렉션 누적 | static 컬렉션에 객체 누적 | 캐시 만료정책, WeakReference 사용 |
| 리스너/콜백 누락 해제 | 이벤트 리스너가 해제되지 않음 | 리스너 등록 후 반드시 해제 |
| ThreadLocal 값 누락 | 스레드풀 사용 시 ThreadLocal 제거 누락 | 작업 완료 후 remove() 호출 |
| 리소스 미반납 | 스트림/DB/소켓 등이 닫히지 않음 | try-with-resources 또는 finally 블록 사용 |
