# 260127 TIL

## 정렬

### sort()
* `배열` : Arrays.sort()
* `리스트` : Collections.sort()
* Comparator
    * Arrays.sort(arr, Comparator.reverseOrder())
    * Collections.sort(list, Comparator.reverseOrder())

### 완전 탐색
* N < 10,000 일 때 고려
* 전체 탐색
* `for`, `while`

### 이진 탐색
* 복잡도 : O(log N)
* 범위를 절반씩 좁혀가서 탐색


```Java
public int binarySearch(int[] arr, int target) {
    int low = 0;
    int high = arr.length - 1;

    while (low <= high) {
        int mid = low + (high - low) / 2; // (low + high) / 2 와 같지만 오버플로우 방지

        if (arr[mid] == target) {
            return mid; // 찾았을 때 인덱스 반환
        } else if (arr[mid] < target) {
            low = mid + 1; // 타겟이 오른쪽 영역에 있음
        } else {
            high = mid - 1; // 타겟이 왼쪽 영역에 있음
        }
    }
    return -1; // 찾지 못했을 때
}
```

### 그리디(탐욕)
* 지금 가장 이득인 것을 선택
```Java
public int countCoins(int money) {
    int[] coins = {500, 100, 50, 10}; 
    int count = 0;

    for (int coin : coins) {
        if (money == 0) break;
        count += (money / coin); // 해당 동전으로 줄 수 있는 최대 개수
        money %= coin;           // 남은 잔돈
    }
    return count;
}
```