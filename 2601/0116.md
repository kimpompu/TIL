# 260116 TIL

## 쿠키와 세션의 차이에 대해 설명해 주세요.

### 정의 및 저장 위치
* **쿠키 :** 클라이언트의 웹 브라우저에 저장되는 작은 텍스트 파일임.
* **세션 :** 서버 측에서 클라이언트의 상태 정보를 관리하는 메커니즘임.

### 주요 차이점
* **보안성 :** 쿠키는 클라이언트에 노출되어 변조 위험이 있으나, 세션은 서버에서 관리되므로 상대적으로 안전함.
* **유지 기간 :** 쿠키는 파일로 저장되어 브라우저 종료 후에도 유지될 수 있으나, 세션은 브라우저 종료 시 삭제되거나 서버 설정에 따라 만료됨.
* **속도 :** 쿠키는 요청 시 서버에 데이터를 바로 전달하므로 빠르나, 세션은 서버에서 데이터를 찾는 과정이 필요하여 비교적 느림.



---

## 세션 방식의 로그인 과정에 대해 설명해 주세요.

### 수행 단계
1. **로그인 요청 :** 사용자가 아이디와 비밀번호를 입력하여 서버에 전송함.
2. **정보 확인 :** 서버가 데이터베이스를 조회하여 사용자 정보를 검증함.
3. **세션 생성 :** 검증 성공 시 서버는 고유한 세션 아이디를 생성하고 서버 메모리나 데이터베이스에 저장함.
4. **쿠키 전달 :** 서버는 응답 헤더에 세션 아이디를 담아 클라이언트에 보냄.
5. **쿠키 저장 :** 브라우저는 전달받은 세션 아이디를 쿠키에 저장함.
6. **인증 유지 :** 이후 요청부터 클라이언트는 쿠키에 담긴 세션 아이디를 서버에 함께 보냄.
7. **상태 확인 :** 서버는 수신한 아이디로 서버 저장소를 확인하여 사용자를 식별함.



---

## HTTP의 특성인 Stateless에 대해 설명해 주세요.

### 상태 비저장성의 의미
서버가 클라이언트의 이전 요청 상태를 보존하지 않는 특성임. 각 요청은 독립적인 트랜잭션으로 취급됨.

### 특징
* **서버 확장성 :** 서버가 클라이언트 상태를 유지할 필요가 없어 서버를 자유롭게 늘릴 수 있는 수평적 확장에 유리함.
* **독립성 :** 이전 요청의 성공 여부와 관계없이 현재 요청에 필요한 모든 정보를 포함하여 전송해야 함.

---

## Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?

### 기술적 분석
논리적으로 세션은 서버에 상태를 저장하므로 상태 비저장성 원칙에 어긋나는 것은 사실임. 그러나 통신 프로토콜 자체는 여전히 상태 비저장성을 유지하면서, 응용 단계에서 비즈니스 로직(로그인 유지 등)을 구현하기 위해 세션을 보완적으로 사용하는 것임. 최근에는 완전한 상태 비저장성을 유지하기 위해 토큰 방식의 인증을 더 선호하기도 함.

---

## 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?

### 관리 전략
1. **스티키 세션 :** 특정 사용자의 요청을 처음 세션이 생성된 서버로만 고정하여 전달하는 방식임. 특정 서버에 부하가 몰릴 위험이 있음.
2. **세션 클러스터링 :** 여러 서버가 세션 데이터를 서로 복제하여 공유하는 방식임. 메모리 낭비와 네트워크 복제 비용이 발생함.
3. **세션 스토리지 :** 별도의 외부 저장소(레디스, 멤캐시드 등)에 세션 정보를 저장하고 모든 서버가 이를 참조하게 함. 현재 가장 널리 사용되는 방식임.

---

## HTTP 응답코드에 대해 설명해 주세요.

### 분류 및 의미
* **100번대 :** 정보 제공. 요청을 받았으며 작업을 계속 진행 중임을 나타냄.
* **200번대 :** 성공. 요청이 성공적으로 처리되었음을 의미함.
* **300번대 :** 리다이렉션. 요청 완료를 위해 추가적인 동작이 필요함.
* **400번대 :** 클라이언트 오류. 요청 구문이 잘못되었거나 권한이 없는 등 클라이언트 측 문제임.
* **500번대 :** 서버 오류. 서버가 유효한 요청을 처리하는 데 실패했음을 의미함.



---

## 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?

### 상세 비교
* **401 비인가 :** 클라이언트가 누구인지 인증되지 않았음을 의미함. 즉, 로그인이 필요한 상태임.
* **403 권한 없음 :** 클라이언트가 누구인지 서버가 알고 있으나, 해당 자원에 접근할 권한이 허용되지 않은 상태임.

---

## 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.

### 용도 구분
* **200 성공 :** 요청이 정상적으로 수행되었음을 알리는 일반적인 성공 코드임.
* **201 생성됨 :** 요청이 성공하여 새로운 자원이 생성되었음을 의미함. 주로 생성된 자원의 위치 정보가 응답에 포함됨.

---

## 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.

### 가능 여부 및 권고
기술적으로는 가능하나 지양해야 함. 표준화된 응답 코드를 사용해야 브라우저, 프록시 서버, 라이브러리 등이 개발자의 의도대로 동작하기 때문임. 임의의 코드를 사용하면 상호운용성 문제가 발생하고 유지보수가 어려워짐.

---

## HTTP Method 에 대해 설명해 주세요.

### 주요 메서드 역할
* **조회 :** 서버의 자원을 요청함.
* **등록 :** 새로운 자원을 생성하거나 데이터를 처리함.
* **수정 :** 자원을 전체적으로 교체함.
* **부분 수정 :** 자원의 일부분만 수정함.
* **삭제 :** 특정 자원을 제거함.

---

## HTTP Method의 멱등성에 대해 설명해 주세요.

### 정의
동일한 요청을 한 번 보내는 것과 여러 번 보내는 것이 서버의 상태에 동일한 결과를 가져오는 성질임.

### 메서드별 특징
* **멱등함 :** 조회, 수정(전체), 삭제, 헤드, 옵션 메서드는 여러 번 실행해도 결과가 같음.
* **멱등하지 않음 :** 등록 메서드는 호출할 때마다 새로운 자원이 생성될 수 있어 결과가 달라짐. 부분 수정은 구현 방식에 따라 결과가 달라질 수 있음.



---

## GET과 POST의 차이는 무엇인가요?

### 비교 분석
* **조회 vs 처리 :** 조회는 데이터 획득이 목적이며, 등록은 데이터 전송 및 처리가 목적임.
* **파라미터 위치 :** 조회는 주소창에 데이터를 포함하나, 등록은 본문에 담아 전송함.
* **멱등성 :** 조회는 멱등하며 결과가 변하지 않으나, 등록은 멱등하지 않음.
* **캐싱 :** 조회는 브라우저 캐싱이 가능하나, 등록은 불가능함.

---

## POST와 PUT, PATCH의 차이는 무엇인가요?

### 상세 구분
* **등록 (POST) :** 자원을 새로 생성하며, 자원의 위치를 서버가 결정함. 멱등하지 않음.
* **수정 (PUT) :** 자원을 통째로 대체함. 만약 자원이 없으면 생성함. 멱등함.
* **부분 수정 (PATCH) :** 자원의 특정 속성만 변경함. 멱등성을 보장하지 않을 수 있음.

---

## HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?

### 사유
1. **호환성 문제 :** 오래된 서버나 프록시 장비가 조회 요청의 본문을 무시하거나 오류를 일으킬 수 있음.
2. **캐싱 효율 :** 조회 요청은 주소를 기반으로 캐싱되는데, 본문의 내용은 캐싱 키로 활용되기 어려움.
3. **표준의 일관성 :** 조회 메서드의 설계 목적 자체가 식별자를 통한 자원 획득이므로 본문을 사용하는 것은 의미론적으로 맞지 않음.

---

## HTTP에 대해 설명해 주세요.

### 정의
하이퍼텍스트 전송 프로토콜의 약자로, 웹 상에서 자원을 주고받기 위해 사용하는 응용 계층의 프로토콜임.

### 특징
* **클라이언트-서버 구조 :** 요청과 응답 모델을 기반으로 동작함.
* **유연성 :** 텍스트뿐만 아니라 이미지, 동영상, 제이슨 등 다양한 형태의 데이터를 전송할 수 있음.
* **비연결성 :** 요청과 응답이 끝나면 연결을 끊어 자원 낭비를 줄임.