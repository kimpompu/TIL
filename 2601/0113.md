# 260113 TIL

## 인터럽트가 무엇인지 설명해 주세요.

### 정의
CPU가 프로그램을 실행하고 있을 때 입출력 하드웨어 등의 장치나 예외 상황이 발생하여 처리가 필요한 경우 CPU에 알리는 신호

### 목적
프로그램의 정상적인 실행 흐름을 일시 중단하고 시급한 이벤트를 우선 처리해 시스템의 효율성을 높이고 실시간 대응 가능하게 함

---

## 인터럽트는 어떻게 처리하나요?

### 처리 과정
1. **인터럽트 요청 발생 :** 하드웨어 또는 소프트웨어가 CPU에 신호를 보냄
2. **현재 상태 저장 :** CPU는 현재 실행 중인 명령어까지만 수행한 후, 현재의 상태(프로그램 카운터, 레지스터 등)를 스택이나 프로세스 제어 블록에 저장함
3. **인터럽트 서비스 루틴 실행 :** 인터럽트 벡터를 통해 해당 번호에 맞는 서비스 루틴 주소로 점프하여 실제 처리 로직 실행함
4. **상태 복구 및 복귀 :** 처리가 완료되면 저장했던 이전 상태를 복구하고 중단되었던 지점부터 실행 재개함



---

## Polling 방식에 대해 설명해 주세요.

### 정의 및 작동 방식
CPU가 특정 장치의 상태를 주기적으로 확인하며 작업이 필요한지 검사하는 방식. 장치가 준비될 때까지 CPU가 루프를 돌며 대기하는 상태를 포함

### 특징
* **장점:** 별도의 인터럽트 회로가 필요 없어 구현이 단순함
* **단점:** 장치가 작업을 수행하는 동안 CPU가 무의미하게 상태만 확인하므로 자원 낭비가 심함

---

## HW / SW 인터럽트에 대해 설명해 주세요.

### 하드웨어 인터럽트
키보드, 마우스, 디스크 컨트롤러 등 외부 장치로부터 발생하는 신호임. 전원 이상이나 기계적 오류 등도 포함됨.

### 소프트웨어 인터럽트
프로그램 내부에서 명령어 실행 중 발생하는 신호임. 시스템 콜 호출이나 0으로 나누기, 메모리 접근 오류 등의 예외 상황을 처리하기 위해 발생함. 흔히 트랩이라고도 부름.

---

## 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

### 처리 전략
1. **인터럽트 우선순위 활용:** 각 인터럽트에 우선순위를 부여하여 높은 쪽을 먼저 처리함. 처리 중 더 높은 순위의 인터럽트가 오면 현재 루틴을 중단하고 중첩해서 처리함.
2. **인터럽트 마스크 설정:** 특정 인터럽트가 처리되는 동안 다른 인터럽트가 발생하지 못하도록 차단함. 현재 처리가 끝난 후 차례대로 수행함.

---

## 프로세스가 무엇인가요?

### 정의
디스크에 저장되어 있던 실행 파일(프로그램)이 메모리에 적재되어 CPU에 의해 실행되고 있는 상태를 의미함. 운영체제로부터 자원을 할당받는 작업의 단위임.

---

## 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

### 비교 및 차이점
* **프로그램:** 실행 가능한 명령어의 집합을 가진 정적인 데이터 파일임.
* **프로세스:** 실행 중인 프로그램의 인스턴스로, 독립된 메모리 공간(코드, 데이터, 힙, 스택)을 가짐.
* **스레드:** 프로세스 내에서 실행되는 흐름의 단위임. 프로세스의 자원을 공유하면서 각자 독립적인 스택과 레지스터 상태만 가짐.



---

## PCB가 무엇인가요?

### 정의 및 역할
프로세스 제어 블록은 운영체제가 프로세스를 관리하기 위해 할당하는 데이터 구조임. 프로세스의 현재 상태, 프로그램 카운터, 레지스터 값, 메모리 범위, 할당된 자원 정보 등이 저장됨. 문맥 교환 시 프로세스의 상태를 저장하고 복원하는 근거가 됨.

---

## 그렇다면, 스레드는 PCB를 갖고 있을까요?

### 사실 정정 및 설명
스레드는 별도의 프로세스 제어 블록을 갖지 않음. 대신 스레드 제어 블록을 가짐. 스레드 제어 블록은 해당 스레드만의 스택 포인터, 프로그램 카운터, 레지스터 상태 등을 관리하며, 소속된 프로세스의 프로세스 제어 블록을 가리키는 포인터를 포함함.

---

## 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

### 생성 방식
* **프로세스:** `fork` 시스템 콜을 통해 현재 프로세스를 복제하여 생성함. 부모와 자식은 별도의 주소 공간을 가짐.
* **스레드:** `clone` 시스템 콜을 사용하여 생성함. 이때 플래그 설정을 통해 부모 프로세스의 메모리 공간과 파일 기술자 등을 공유하도록 지정함.

---

## 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

### 상황별 처리
* **좀비 프로세스:** 자식이 종료되었으나 부모가 종료 상태를 수거하지 않은 상태임. 부모가 `wait` 계열 함수를 호출하여 상태를 확인해야 시스템에서 완전히 삭제됨.
* **고아 프로세스:** 부모가 자식보다 먼저 종료된 경우임. 리눅스 시스템은 이러한 고아 프로세스의 부모를 루트 프로세스(init 또는 systemd)로 재설정하여 루트 프로세스가 추후 종료 상태를 수거하게 함.

---

## 리눅스에서, 데몬프로세스에 대해 설명해 주세요.

### 정의 및 특징
사용자의 개입 없이 백그라운드에서 특정 서비스를 제공하기 위해 실행되는 프로세스임. 터미널과의 연결이 끊어져 있으며, 시스템 부팅 시 실행되어 종료 시까지 상주하는 경우가 많음. 보통 이름 뒤에 'd'가 붙는 관례가 있음.

---

## 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

### 루트 프로세스
모든 프로세스의 조상인 `init` 또는 현대 리눅스의 `systemd` 프로세스임. 프로세스 아이디는 항상 1번이며, 커널 부팅 후 가장 먼저 실행되어 시스템 운영에 필요한 다른 프로세스들을 생성하고 고아 프로세스를 수거하는 역할을 수행함.

---

## 프로세스 주소공간에 대해 설명해 주세요.

### 구성 영역
1. **코드 영역:** 실행할 프로그램의 기계어 명령어가 저장되는 읽기 전용 공간임.
2. **데이터 영역:** 초기화된 전역 변수와 정적 변수가 저장됨.
3. **비에스에스(BSS) 영역:** 초기화되지 않은 전역 변수와 정적 변수가 저장됨.
4. **힙 영역:** 사용자가 런타임에 동적으로 할당하는 메모리 공간임. 낮은 주소에서 높은 주소로 할당됨.
5. **스택 영역:** 함수의 매개변수, 지역 변수, 복귀 주소 등이 저장되는 임시 공간임. 높은 주소에서 낮은 주소로 할당됨.



---

## 초기화 하지 않은 변수들은 어디에 저장될까요?

### 위치
비에스에스(BSS) 영역에 저장됨. 프로그램 실행 시 운영체제에 의해 자동으로 0으로 초기화되므로 데이터 영역과 구분하여 실행 파일의 크기를 줄이는 효과가 있음.

---

## 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?

### 결정 시점 및 크기
스택과 힙이 전체 주소 공간을 모두 차지하는 것은 아님.
* **스택:** 컴파일 타임에 크기가 결정되거나 운영체제 설정에 의해 최대 크기가 고정됨. 보통 수 메가바이트 단위로 제한됨.
* **힙:** 런타임에 프로그램이 실행되면서 필요에 따라 크기가 유연하게 결정됨. 사용 가능한 가상 메모리 범위 내에서 확장 가능함.

---

## Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?

### 비교 결과
스택이 훨씬 빠름. 스택은 CPU의 스택 포인터 레지스터를 통해 관리되며 단순히 포인터를 이동시키는 방식으로 할당과 해제가 이루어짐. 힙은 메모리 풀 내에서 빈 공간을 찾는 탐색 과정과 파편화 관리 비용이 발생하므로 상대적으로 느림.

---

## 다음과 같이 공간을 분할하는 이유가 있을까요?

### 목적
1. **보안:** 코드 영역을 읽기 전용으로 설정하여 실행 중인 코드가 수정되지 않도록 보호함.
2. **공유:** 동일한 프로그램을 여러 프로세스가 실행할 때 코드 영역은 공유하여 메모리 효율을 높임.
3. **효율적 관리:** 데이터 특성(동적/정적)에 따라 관리 방식을 최적화함.

---

## 스레드의 주소공간은 어떻게 구성되어 있을까요?

### 공유 및 독립 영역
스레드는 프로세스 내의 코드, 데이터, 힙 영역을 소속된 다른 스레드들과 공유함. 단, 각 스레드는 함수 호출 흐름을 독립적으로 유지해야 하므로 자신만의 스택 영역과 레지스터 상태를 따로 가짐.

---

## "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.

### 연관성 분석
* **스택 영역:** 자료구조의 스택과 밀접하게 연관됨. 함수 호출 시 정보를 쌓고(Push), 종료 시 제거하는(Pop) 후입선출 방식으로 동작함.
* **힙 영역:** 자료구조의 힙(완전 이진 트리)과는 직접적인 연관이 없음. 여기서 힙은 '쌓여있는 더미'라는 의미로, 자유로운 메모리 풀을 의미함. 다만 메모리 관리자가 할당 알고리즘을 구현할 때 내부적으로 힙 자료구조를 사용하는 경우는 있을 수 있음.

---

## IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?

### 위치 및 이유
스택과 힙 사이의 메모리 매핑 영역에 위치함. 이 영역은 동적 라이브러리나 공유 메모리를 연결하기 위해 비워둔 공간임. 물리 메모리의 특정 블록을 여러 프로세스의 가상 주소 공간에 동일하게 매핑하여 복사 과정 없이 데이터를 빠르게 공유하기 위함임.

---

## 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?

### 결정 시점 및 수정 방법
* **스택:** 빌드 시 링크 옵션으로 지정하거나 운영체제 커널 설정으로 결정됨.
* **힙:** 프로그램 실행 중 사용자의 요청에 의해 동적으로 결정됨.
* **사용자 수정 가능성:** 운영체제 명령(예: 리눅스의 `ulimit`)을 통해 프로세스당 할당 가능한 최대 스택 크기나 전체 메모리 사용량을 제한하거나 수정할 수 있음.