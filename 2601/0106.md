# 260106 TIL
# 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식

## 블로킹(Blocking)
* **블로킹(Blocking)** : 호출된 함수가 자신의 작업이 모두 끝날 때까지 제어권을 가지고 호출한 함수(Caller)에게 돌려주지 않는 상태

* **동작** : I/O 작업(파일 읽기, 네트워크 수신 등)이 완료될 때까지 해당 스레드는 대기하며, 다른 작업을 수행할 수 없으므로 리소스 낭비가 발생할 수 있음

## 요청당 스레드
* **요청당 스레드** : 요청이 들어올 때마다 해당 요청을 전담하여 처리할 스레드(Thread)를 하나씩 할당하는 방식
* **장점** : 로직이 단순하고 디버깅이 쉬우며, 코드를 순차적으로 작성할 수 있음
* **단점** : 동시 접속자가 많아지면 스레드 수가 급격히 늘어나 메모리 부족이 발생하거나, 스레드 간 컨텍스트 스위칭 비용이 증가하여 성능이 급격히 저하됨

## 컨텍스트 스위칭
* **컨텍스트 스위칭** : CPU가 실행 중이던 프로세스나 스레드를 멈추고, 다른 프로세스나 스레드를 실행하기 위해 상태(Context)를 교체하는 작업
* **과정** : 현재 실행 중인 스레드의 상태를 TCB(Thread Control Block)에 저장하고, 다음에 실행할 스레드의 상태를 읽어옴
* **영향** : 이 작업 자체도 CPU 시간을 소모하므로 스레드가 너무 많아지면 실제 작업보다 스위칭하는 데 더 많은 시간을 쓰게 될 수 있음

## 트래픽이 증가하면 자원 효율이 떨어지는 이유
1. IO 대기와 컨텍스트 스위칭에 따른 CPU 낭비
2. 요청마다 스레드를 할당함으로써 메모리 사용량이 높음

### IO 대기로 인한 CPU 낭비 줄이는 방법
1. 가상 스레드, 고루틴 같은 경량 스레드 사용
2. 논블로킹 또는 비동기 IO 사용

## 경량 스레드(Lightweight Thread)
* **경량 스레드** : OS 스레드와 1:1로 매핑되지 않고, 언어의 런타임이나 라이브러리 레벨에서 관리되는 스레드 
ex) Go 루틴, 코틀린 코루틴, 자바의 가상 스레드
* **특징** 
    * **적은 메모리** : 일반 스레드가 수 MB의 스택을 차지하는 반면, 경량 스레드는 수 KB 수준
    * **빠른 생성/전환** : OS 레벨의 컨텍스트 스위칭 없이 사용자 영역에서 스케줄링되므로 속도가 매우 빠름
    * **대규모 동시성** : 수백만 개의 스레드를 생성해도 시스템에 무리가 가지 않음

## 캐리어 스레드(Carrier Thread)
* **캐리어 스레드** : 자바의 가상 스레드 모델에서 사용되는 개념으로, 가상 스레드를 실제로 실행하는 **OS 스레드**

* **동작 원리** : 가상 스레드가 I/O 작업 등으로 블로킹되면, 캐리어 스레드는 해당 가상 스레드를 힙 메모리에 잠시 내려놓고(Unmount), 대기 중인 다른 가상 스레드를 가져와 실행(Mount)
* **관계** : 소수의 캐리어 스레드가 수많은 가상 스레드를 번갈아가며 처리(M:N 모델)

## 논블로킹 IO
* **논블로킹 IO** : I/O 작업을 요청했을 때, 작업 완료 여부와 상관없이 **즉시 제어권을 반환**하는 방식

* **동작** : 스레드가 멈추지 않고 다른 작업을 계속 수행할 수 있음. I/O 작업의 결과는 나중에 폴링(Polling)하거나 콜백(Callback), 이벤트를 통해 확인
* **장점** : 적은 수의 스레드로도 많은 수의 연결을 동시에 처리할 수 있음

### Selector
* **Selector** : 자바 NIO(New IO)의 핵심 컴포넌트로, **하나의 스레드가 여러 개의 채널(Channel, 연결)** 을 모니터링할 수 있게 해주는 객체. **I/O 멀티플렉싱(Multiplexing)** 
* **역할** : 등록된 채널들 중에서 읽기 가능, 쓰기 가능, 연결 요청 등의 **이벤트가 발생한 채널만 골라냄**
* **효과** : 수만 개의 클라이언트 연결이 있어도 실제 데이터 전송이 있는 연결만 처리하면 되므로 효율적

### 리액터 패턴
* **리액터 패턴** : 동시에 들어오는 여러 요청을 처리하기 위한 동시성 디자인 패턴, **이벤트 루프(Event Loop)** 기반
ex) Node.js, Netty, Vert.x

* **구조** 
    1.  **Reactor(Event Loop)** : 무한 루프를 돌며 이벤트(요청)가 들어오기를 기다림
    2.  **Selector/Demultiplexer** : 어느 핸들러가 이벤트를 처리해야 할지 결정합
    3.  **Handler** : 실제 비즈니스 로직을 비동기적으로 수행
* **특징** : 블로킹 I/O를 사용하지 않고, 단일(또는 소수) 스레드로 높은 처리량을 낼 수 있음