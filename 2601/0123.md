# 260123 TIL

## Spring Framework의 기본 개념과 주요 특징에 대해 설명해주세요.
### Spring Framework 개요 및 특징
* **정의 :** 자바 엔터프라이즈 애플리케이션 개발을 위한 포괄적인 인프라를 제공하는 오픈 소스 경량급 프레임워크
* **주요 특징 :** 
    * **POJO(Plain Old Java Object) 지향 :** 특정한 인터페이스나 클래스를 상속받지 않는 일반적인 자바 객체를 활용하여 비즈니스 로직을 구현함
    * **IoC/DI :** 객체의 생성 및 관리를 프레임워크가 담당하여 객체 간 결합도를 낮춤
    * **AOP(Aspect Oriented Programming) :** 로깅, 트랜잭션 등 공통 관심사를 분리하여 모듈화
    * **PSA(Portable Service Abstraction) :** 환경 변화에 독립적으로 일관된 서비스 추상화를 제공

## Spring Boot와 전통적 Spring Framework의 차이점은 무엇인가요?
### Spring Framework vs Spring Boot 비교
| 구분 | Spring Framework | Spring Boot |
| :--- | :--- | :--- |
| **설정** | XML 또는 Java Config를 통한 복잡한 수동 설정 필요 | **Auto-Configuration**을 통한 설정 자동화 |
| **의존성 관리** | 호환되는 라이브러리 버전을 직접 명시해야 함 | **Starter** 의존성을 통해 버전 조합 관리 자동화 |
| **내장 서버** | 별도의 WAS(Tomcat 등) 설치 및 배포 필요 | **Embedded Server**(Tomcat, Jetty 등) 내장 |
| **운영 지원** | 운영 모니터링 기능 부족 | **Actuator**를 통한 지표 모니터링 제공 |

## IoC(Inversion of Control)와 DI(Dependency Injection)의 개념 및 이점에 대해 설명해주세요.
### IoC와 DI의 메커니즘
* **IoC (제어의 역전) :** 객체의 생성, 생명주기 관리, 호출에 대한 제어권이 개발자가 아닌 프레임워크(Container)에 있는 것을 의미
* **DI (의존성 주입) :** 객체가 직접 의존하는 객체를 생성하지 않고, 외부(IoC 컨테이너)로부터 주입받는 패턴
* **이점 :** 객체 간의 결합도를 낮추어 코드의 재사용성과 테스트 용이성을 높이며, 단일 책임 원칙(SRP)을 준수하기 쉬워짐

## Spring Bean의 라이프사이클과 관련 콜백 메서드에 대해 설명해주세요.
### Bean Lifecycle 단계
1. **Instantiate :** 빈 객체 생성
2. **Populate Properties :** 의존성 주입
3. **Initialization :** 
    * `postProcessBeforeInitialization` (BeanPostProcessor)
    * **@PostConstruct** 또는 `afterPropertiesSet()` 호출
    * `postProcessAfterInitialization` (BeanPostProcessor)
4. **Destruction :** **@PreDestroy** 또는 `destroy()` 호출



## @Component, @Service, @Repository의 차이점 및 사용 사례는 무엇인가요?
### Stereotype Annotation 구분
* **@Component :** Spring 관리 빈으로 등록하는 가장 기본이 되는 어노테이션
* **@Service :** 비즈니스 로직을 수행하는 서비스 레이어에 사용함. 특별한 기능적 특징보다는 의미론적인 구분 역할
* **@Repository :** 데이터 액세스 레이어(Persistence 레이어)에 사용함. 해당 어노테이션이 붙은 클래스는 플랫폼별 **DataAccessException**을 스프링의 일관된 예외 체계로 변환하는 기능을 제공

## AOP(Aspect Oriented Programming)를 활용한 공통 관심사 분리 방법에 대해 설명해주세요.
### AOP 구성 요소 및 동작
* **Aspect :** 공통 관심사를 모듈화한 단위
* **Join Point :** 어드바이스가 적용될 수 있는 위치(메서드 실행, 필드 값 변경 등)
* **Pointcut :** 어드바이스를 적용할 조인 포인트를 선별하는 표현식
* **Advice :** 특정 조인 포인트에서 실행되는 실질적인 코드(Before, After, Around 등)
* **구현 방식 :** 스프링은 **Proxy** 패턴을 사용하여 런타임에 부가 기능을 삽입

## Spring에서 트랜잭션 관리와 @Transactional 어노테이션의 역할에 대해 설명해주세요.
### @Transactional 동작 원리
* **역할 :** 해당 메서드나 클래스를 트랜잭션 범위로 지정하여 ACID 속성을 보장
* **동작 방식 :** 스프링 AOP를 통해 프록시 객체를 생성하고, 메서드 호출 전 트랜잭션 시작, 종료 후 커밋 또는 롤백을 수행
* **주요 속성 :** `propagation`(전파), `isolation`(격리 수준), `readOnly`(읽기 전용 여부), `timeout` 등이 있음

## Spring MVC 아키텍처의 구성 요소와 요청 처리 과정을 설명해주세요.
### Request Processing Flow
1. **DispatcherServlet :** 클라이언트의 모든 요청을 수신
2. **HandlerMapping :** 요청 URL에 맞는 핸들러(Controller)를 찾음
3. **HandlerAdapter :** 찾은 핸들러를 실행할 수 있는 어댑터를 통해 메서드 호출
4. **Controller :** 비즈니스 로직을 처리하고 ModelAndView를 반환
5. **ViewResolver :** 반환된 뷰 이름을 바탕으로 실제 View 객체를 찾음
6. **View :** 모델 데이터를 렌더링하여 클라이언트에게 응답



## Spring Boot의 자동 구성(Auto-Configuration) 원리에 대해 설명해주세요.
### @EnableAutoConfiguration 메커니즘
* **원리 :** 클래스패스에 존재하는 라이브러리와 정의된 빈을 분석하여 필요한 설정을 자동으로 적용
* **동작 과정 :** `@SpringBootApplication` 내부의 `@EnableAutoConfiguration`이 실행되며, `spring-boot-autoconfigure` 모듈 내의 `META-INF/spring.factories` (또는 최신 버전의 `org.springframework.boot.autoconfigure.AutoConfiguration.imports`) 파일을 읽어 조건(@Conditional)에 부합하는 설정 클래스들을 빈으로 등록

## 예외 처리를 위한 @ControllerAdvice의 역할과 활용 방법은 무엇인가요?
### Global Exception Handling
* **역할 :** 애플리케이션 내의 여러 컨트롤러에서 발생하는 예외를 한 곳에서 전역적으로 처리하도록 돕는 어노테이션
* **활용 :** `@ExceptionHandler`와 조합하여 특정 예외 발생 시 반환할 HTTP 상태 코드와 메시지를 정의함. 컨트롤러의 비즈니스 로직과 예외 처리 로직을 분리하여 코드 가독성을 높임

## Spring Security의 기본 개념과 인증/인가 처리 흐름에 대해 설명해주세요.
### Authentication vs Authorization
* **Authentication(인증) :** 주체(Principal)가 누구인지 확인하는 과정
* **Authorization(인가) :** 인증된 주체가 특정 리소스에 접근할 권한이 있는지 확인하는 과정
* **흐름 :** `FilterChianProxy`를 통해 보안 필터 체인이 가동됨. `AuthenticationFilter`가 정보를 수집하여 `AuthenticationManager`에 전달하고, 인증 성공 시 `SecurityContextHolder`에 저장함. 이후 `FilterSecurityInterceptor`가 인가 여부를 결정



## RESTful API를 Spring에서 구현하는 방법과 모범 사례는 무엇인가요?
### REST 구현 가이드라인
* **구현 :** `@RestController`와 `@RequestMapping`(또는 `@GetMapping`, `@PostMapping` 등)을 사용하여 자원을 명시함.
* **모범 사례 :**
    * **Resource 명명 :** 명사형 URI를 사용하고 복수형을 권장
    * **HTTP Method 활용 :** GET(조회), POST(생성), PUT(수정), DELETE(삭제)를 목적에 맞게 사용
    * **Status Code 반환 :** 성공 시 200/201, 클라이언트 오류 4xx, 서버 오류 5xx를 정확히 반환
    * **DTO 사용 :** 엔티티를 직접 노출하지 않고 DTO를 통해 데이터를 전달

## Spring Boot Actuator를 통한 애플리케이션 모니터링 방법은 무엇인가요?
### Actuator 기능 및 엔드포인트
* **개요 :** 실행 중인 애플리케이션의 상태를 HTTP나 JMX를 통해 노출하는 기능
* **주요 엔드포인트 :** * `/health` : 애플리케이션 상태 확인
    * `/metrics` : JVM 메모리, CPU 사용량 등의 지표 확인
    * `/beans` : 등록된 스프링 빈 목록 확인

## Spring Cloud를 활용한 마이크로서비스 아키텍처 구현 전략에 대해 설명해주세요.
### MSA 구성 요소
* **Service Discovery (Eureka) :** 서비스의 위치를 동적으로 등록하고 탐색
* **API Gateway (Spring Cloud Gateway) :** 요청 라우팅 및 통합 인증/인가를 수행
* **Config Server :** 환경 설정을 외부화하여 중앙에서 관리
* **Circuit Breaker (Resilience4j) :** 서비스 장애 전파를 방지

## Spring에서 메시징 시스템(Kafka, RabbitMQ 등)과의 연동 방법은 무엇인가요?
### Message Driven Communication
* **Spring Kafka / Spring AMQP :** 각 메시징 시스템에 특화된 템플릿(`KafkaTemplate`, `RabbitTemplate`)과 리스너(`@KafkaListener`, `@RabbitListener`)를 제공
* **Spring Cloud Stream :** 메시징 시스템 종류와 관계없이 공통된 바인더(Binder) 추상화를 통해 메시지 기반 통신을 구현

## Spring의 캐싱 추상화(Cache Abstraction)와 캐시 적용 방법에 대해 설명해주세요.
### Cache Abstraction
* **개요 :** 특정 캐시 기술(Redis, Ehcache, Caffeine 등)에 종속되지 않는 일관된 캐시 인터페이스 제공
* **어노테이션 :** * `@Cacheable` : 결과 캐시 저장 및 반환
    * `@CacheEvict` : 캐시 데이터 삭제
    * `@CachePut` : 결과 캐시 강제 업데이트

## Spring Boot에서 프로파일 관리와 환경별 설정 적용 방법은 무엇인가요?
### Profiles 환경 관리
* **설정 방식 :** `application-{profile}.properties` 또는 `yml` 파일로 구분
* **활성화 :** `spring.profiles.active` 속성을 사용하여 실행 시 프로파일을 선택
* **빈 선택 :** `@Profile` 어노테이션을 통해 특정 환경에서만 특정 빈이 등록되도록 설정

## Spring Bean의 Scope(싱글톤, 프로토타입 등) 차이점과 활용 사례는 무엇인가요?
### Bean Scope 비교
* **Singleton :** 컨테이너당 하나의 인스턴스만 생성하여 공유함(기본값)
* **Prototype :** 요청될 때마다 새로운 인스턴스를 생성함. 상태를 유지해야 하는 빈에 사용
* **Request/Session :** 웹 애플리케이션에서 HTTP 요청/세션 주기 동안만 유지

## Spring의 이벤트 발행 및 리스너(Event Listener) 메커니즘에 대해 설명해주세요.
### Event Driven Architecture in Spring
* **ApplicationEventPublisher :** 이벤트를 발행하는 객체
* **ApplicationEvent :** 발행할 이벤트 객체(Java 8 이후부터는 POJO도 가능함)
* **@EventListener :** 발행된 이벤트를 수신하여 처리하는 메서드에 사용
* **장점 :** 클래스 간의 직접적인 의존성을 제거하여 결합도를 낮춤

## 커스텀 어노테이션을 생성하고 이를 Spring에서 활용하는 방법은 무엇인가요?
### Custom Annotation 구현 절차
1. **정의 :** `@interface`를 사용하여 선언
2. **메타 어노테이션 :** `@Target`, `@Retention`을 설정
3. **로직 적용 :** 주로 **AOP**를 사용하여 해당 어노테이션이 붙은 지점에 실행될 횡단 관심사 로직을 `Aspect` 클래스에서 구현

## Spring WebFlux와 Spring MVC의 차이점 및 사용 시나리오는 무엇인가요?
### Blocking vs Reactive
* **Spring MVC :** Thread-per-request 모델 기반의 블로킹 I/O 방식임. 서블릿 API 기반
* **Spring WebFlux :** 비차단(Non-blocking) 리액티브 스트림 기반임. 적은 수의 스레드로 대규모 동시 접속 처리에 유리
* **사용 시나리오 :** MVC는 일반적인 웹 애플리케이션에, WebFlux는 고성능/대용량 스트리밍 데이터 또는 마이크로서비스 간 논블로킹 통신이 필요할 때 사용



## Spring에서 비동기 처리(Asynchronous Processing)를 구현하는 방법에 대해 설명해주세요.
### @Async 동작
* **설정 :** `@EnableAsync`를 설정 클래스에 추가
* **사용 :** 비동기로 실행할 메서드에 `@Async` 어노테이션
* **반환 타입 :** `void`, `Future`, `CompletableFuture` 등을 사용하여 비동기 결과를 처리. 내부적으로 `TaskExecutor`를 사용하여 별도의 스레드에서 작업을 수행

## Logback을 이용한 Spring Boot의 로깅 설정과 관리 방법은 무엇인가요?
### Logging Framework
* **기본 설정 :** 스프링 부트는 SLF4J의 구현체로 Logback을 기본 채택
* **파일 설정 :** `logback-spring.xml` 파일을 통해 로그 레벨, 패턴, 파일 저장 정책(Rolling) 등을 세밀하게 제어함. 프로파일별로 로그 설정을 다르게 적용할 수 있음.

## HttpMessageConverter의 역할과 Spring에서의 메시지 변환 과정을 설명해주세요.
### 메시지 변환 원리
* **역할 :** HTTP 요청 본문(Body)을 객체로 변환하거나, 객체를 HTTP 응답 본문으로 변환
* **동작 :** `@RequestBody` 또는 `@ResponseBody` 사용 시 작동함. `Content-Type`과 대상 클래스 타입을 확인하여 적합한 컨버터(예 : `MappingJackson2HttpMessageConverter`)를 선택

## RestTemplate과 WebClient의 차이점 및 사용 사례에 대해 설명해주세요.
### HTTP Clients 비교
* **RestTemplate :** 동기/블로킹 방식의 클라이언트임. 현재는 유지 관리 상태(Maintenance Mode)
* **WebClient :** 비동기/논블로킹 방식의 리액티브 클라이언트임. 동기 방식도 지원하며, 현대적인 스프링 개발에서 권장

## @Scheduled 애노테이션을 사용한 스케줄링 작업 구현 방법은 무엇인가요?
### Task Scheduling
* **설정 :** `@EnableScheduling`을 추가
* **속성 :** 
    * `fixedDelay` : 이전 작업 종료 후 설정 시간만큼 대기
    * `fixedRate` : 설정된 주기마다 실행
    * `cron` : 크론 표현식을 사용하여 정밀한 스케줄링 수행

## Spring Boot Starter의 개념과 주요 Starter들의 역할에 대해 설명해주세요.
### Starter Dependency
* **개념 :** 연관된 라이브러리 의존성들을 한데 묶어 제공하는 모듈
* **주요 예시 :** 
    * `spring-boot-starter-web` : RESTful, Spring MVC 사용을 위한 의존성 모음
    * `spring-boot-starter-data-jpa` : Hibernate, Spring Data JPA 사용을 위한 모음
    * `spring-boot-starter-security` : Spring Security 적용을 위한 모음

## Java Config와 XML Config를 통한 Bean 등록 및 설정 방식의 차이점은 무엇인가요?
### Configuration Methods
* **XML Config :** `<bean>` 태그를 사용함. 자바 코드와 설정이 완전히 분리되나 가독성이 떨어지고 컴파일 시점에 오류를 잡기 어려움
* **Java Config :** `@Configuration`과 `@Bean` 어노테이션을 사용함. 타입 안전성이 보장되며 자바 코드로 복잡한 조건부 설정을 구현하기 용이함. 현대 스프링 개발의 표준임

## 최신 Spring 버전에서 추가된 기능 및 개선 사항에 대해 설명해주세요.
### Spring Framework 6 & Spring Boot 3 핵심 변경사항
* **Java 버전 :** Java 17 이상을 필수로 요구
* **Jakarta EE 9+ :** `javax` 패키지 네임스페이스가 `jakarta`로 변경
* **Native Image :** GraalVM Native Image에 대한 공식 지원을 강화하여 실행 속도와 메모리 효율을 극대화
* **Observability :** Micrometer Observation API를 통합하여 모니터링 및 추적 기능을 내재화