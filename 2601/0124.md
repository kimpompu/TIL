# 260124 TIL

## Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

### Key의 종류와 계층 구조

* **Super Key** : 유일성(Uniqueness)을 만족하는 속성 또는 속성들의 집합임. 튜플을 고유하게 식별할 수 있으나 최소성은 만족하지 못할 수 있음.
* **Candidate Key(후보키)** : 유일성과 최소성(Minimality)을 모두 만족하는 속성 집합임. 모든 기본키는 후보키의 부분 집합임.
* **Primary Key(기본키, PK)** : 후보키 중 설계자에 의해 선택된 주요 식별자임. Null을 허용하지 않으며 유일해야 함.
* **Alternate Key(대체키)** : 후보키 중 기본키로 선택되지 않은 나머지 키임.
* **Foreign Key(외래키, FK)** : 타 테이블의 기본키를 참조하여 테이블 간의 관계를 형성하는 속성임.

---

## 기본키는 수정이 가능한가요?

### 기본키 수정 가능 여부 및 권장 사항
* **기술적 가능성** : SQL 명령을 통해 수정이 가능함
* **문제점** : 기본키는 Clustered Index의 정렬 기준이므로 수정 시 물리적 데이터 재배치가 발생하여 성능 저하를 유발함. 또한 외래키로 참조되고 있을 경우 참조 무결성 위배 위험이 크므로 현실적으로는 수정을 금기시함.

---

## 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?

### InnoDB의 Hidden Primary Key 메커니즘
* **동작 원리** : InnoDB 스토리지 엔진은 PK가 없을 경우 다음과 같이 대체 인덱스를 탐색함. Not Null 제약이 있는 Unique Index 중 첫 번째를 PK로 선택함.
* 적절한 인덱스가 없다면 내부적으로 6바이트 크기의 ROW ID를 생성하여 Clustered Index를 구축함(사용자는 직접 조회 불가)

---

## 외래키 값은 NULL이 들어올 수 있나요?

### 외래키의 Null 허용 여부
* 가능함. 외래키는 참조 무결성을 지키기 위함이지만, "참조 대상이 없음"을 의미하는 NULL 값을 가질 수 있음. 단, 속성 정의에 NOT NULL 제약을 걸었다면 불가능함.

---

## 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

### UNIQUE 인덱스의 성능 특징
* **조회 성능** : 인덱스가 자동 생성되므로 성능이 대폭 향상됨. 일반 인덱스와 달리 검색 대상이 유일함을 보장하므로 검색 중단 시점이 명확하여 미세한 이점이 있음.
* **쓰기 성능** : 데이터 삽입/수정 시 중복 여부를 매번 확인해야 하므로 인덱스가 없는 칼럼보다 쓰기 속도는 느려짐.

---

## RDB와 NoSQL의 차이에 대해 설명해 주세요.

### RDB vs NoSQL 비교

* **RDB (Relational Database)** : 엄격한 스키마(Schema)와 테이블 간 관계 중심. SQL을 사용하며 데이터 무결성을 최우선으로 함.
* **NoSQL (Non-Relational)** : 유연한 데이터 모델(Document, Key-Value 등)을 제공함. 수평적 확장성(Horizontal Scaling)이 뛰어나며 비정형 데이터 처리에 적합함.

---

## NoSQL의 강점과, 약점이 무엇인가요?

### NoSQL의 특성
* **강점** : 스키마 변경이 자유로움. 읽기/쓰기 성능이 매우 빠름. 데이터 분산 처리가 용이함.
* **약점** : JOIN 연산이 복잡하거나 불가능함. 데이터 중복 발생으로 인한 일관성 관리의 어려움. 트랜잭션 지원 범위가 RDB보다 좁음.

---

## RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요?

### RDB의 부하 요인
* **JOIN 연산** : 테이블 간 관계를 해석하기 위한 연산 비용이 큼.
* **엄격한 스키마** : 데이터 삽입 시 제약 조건 및 타입 검증 과정이 필수적임.
* **ACID 준수** : 트랜잭션의 격리 수준을 유지하기 위한 잠금(Locking)과 로깅 과정이 오버헤드를 유발함.

---

## NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

### 기술 선택의 근거 (예시)
* **Redis 사용 사례** : 잦은 세션 관리나 실시간 랭킹 시스템 구축 시, 디스크 기반 RDB의 I/O 병목을 피하고 In-memory 기반의 극단적인 속도를 확보하기 위해 선택함.
* **MongoDB 사용 사례** : 로그 데이터와 같이 필드가 수시로 변하거나 데이터 양이 방대하여 샤딩(Sharding)을 통한 확장이 필수적인 경우 선택함.

---

## 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.

### 트랜잭션 및 ACID 정의

* **트랜잭션** : DB의 상태를 변화시키는 작업의 최소 논리적 단위임.
* **Atomicity (원자성)** : 작업이 모두 성공하거나 모두 실패해야 함.
* **Consistency (일관성)** : 트랜잭션 종료 후 DB는 정의된 제약 조건을 만족해야 함.
* **Isolation (격리성)** : 동시 실행 중인 트랜잭션들이 서로 간섭하지 않아야 함.
* **Durability (지속성)** : 성공한 트랜잭션 결과는 시스템 장애가 발생해도 영구 저장되어야 함.

---

## ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

### 지속성 보장 메커니즘
* **Redo Log (Redo 로깅)** : 변경 내용을 실제 데이터 파일에 기록하기 전, 로그 파일(Write-Ahead Log, WAL)에 먼저 기록함. 시스템 장애 시 이 로그를 재실행(Replay)하여 데이터를 복구함.

---

## 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

### 트랜잭션 적용 사례
* **금융 결제** : 송금인 계좌 차감과 수취인 계좌 입금이 반드시 세트로 수행되어야 하는 경우.
* **주문 시스템** : 주문 생성, 결제 정보 기록, 재고 감소 처리가 원자적으로 실행되어야 하는 경우.

---

## 읽기에는 트랜잭션을 걸지 않아도 될까요?

### 읽기 트랜잭션의 필요성
* 필요함. 단순 1회 조회는 무방할 수 있으나, 여러 쿼리를 조합하여 정합성을 맞춰야 하는 경우(예: 통계 산출) 조회 중에 데이터가 변하면 부정확한 결과를 얻게 됨. 이를 방지하기 위해 일관된 읽기(Consistent Read)를 위한 트랜잭션이 필요함.

---

## 트랜잭션 격리 레벨에 대해 설명해 주세요.

### Isolation Levels

* **Read Uncommitted** : 커밋되지 않은 데이터도 읽음 (Dirty Read 발생).
* **Read Committed** : 커밋된 데이터만 읽음 (Non-repeatable Read 발생).
* **Repeatable Read** : 트랜잭션 중 읽은 데이터의 일관성 보장 (Phantom Read 발생 가능).
* **Serializable** : 완벽한 격리. 성능 저하가 극심함.

---

## 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 공식적으로 밝혀져 있나요?

### 구현 현황 및 이유
* **현황** : 대다수가 지원하나, 성능 최적화를 위해 특정 레벨을 기본값으로 강제하거나 일부 변형하여 구현함(예: Oracle은 Read Committed가 기본이며 Repeatable Read 대신 Serializable 수준의 Snapshot Isolation을 제공함)
* **이유** : 완벽한 격리(Serializable)는 동시성 처리 성능을 심각하게 저하시키기 때문에 각 DBMS 엔진의 아키텍처(MVCC 등)에 최적화된 방식을 채택함.

---

## 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.

### Undo vs Redo Log
* **Undo Log** : 데이터 변경 이전의 값을 저장함. 트랜잭션 롤백 시 복구 및 MVCC(다중 버전 동시성 제어)를 위한 이전 데이터 제공에 사용됨.
* **Redo Log** : 데이터 변경 이후의 물리적 변경 사항을 기록함. 시스템 장애 발생 시 마지막 체크포인트 이후의 데이터를 복구하는 데 사용됨.

---

## 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?

### Storage Engine의 역할
* **정의** : DB 서버가 데이터를 디스크나 메모리에 물리적으로 저장, 갱신, 조회하는 것을 담당하는 소프트웨어 모듈임.
* **기능** : 트랜잭션 관리, 인덱싱 구현, 잠금(Locking) 전략 결정, 버퍼 풀 관리 등 실질적인 데이터 핸들링을 수행함.

---

## 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.

### Index 개요
* **정의** : 특정 칼럼의 값을 정렬하여 데이터 탐색 속도를 높이기 위해 별도로 구축하는 자료구조임.
* **사용 시점** : WHERE 절의 조건, JOIN의 연결 고리, ORDER BY 및 GROUP BY 연산이 빈번한 칼럼에 사용함.

---

## 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?

### 인덱스 관리 오버헤드
* INSERT, UPDATE, DELETE 발생 시 데이터뿐만 아니라 인덱스 자료구조(B-Tree)도 재정렬 및 갱신해야 함. 이 과정에서 페이지 분할(Page Split) 등이 발생하여 전체적인 쓰기 성능이 저하됨.

---

## 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?

### 선택되지 않은 칼럼의 특징
* 인덱스에 포함되지 않은 칼럼은 수정 시 인덱스 갱신 비용이 발생하지 않음. 즉, 테이블 전체가 아닌 '인덱스로 구성된 칼럼'의 수정 빈도가 성능의 핵심 지표임.

---

## ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.

### 인덱스와 정렬/그룹화
* **인덱스 존재 시** : 이미 데이터가 정렬된 상태이므로 추가적인 연산 없이 인덱스를 순차적으로 읽기만 하면 됨 (매우 빠름).
* **인덱스 미존재 시** : 대상 데이터를 임시 공간(Filesort)에 담아 수동 정렬 과정을 거쳐야 함. 데이터 양이 많을 경우 디스크 I/O가 발생하여 성능이 급감함.

---

## 기본키는 인덱스라고 할 수 있을까요? 그렇지 않나요?

### PK와 Index의 관계
* 기본키는 인덱스임. 정확히는 테이블의 데이터와 인덱스가 물리적으로 함께 저장되는 Clustered Index를 생성함.
* **차이점** : 일반 인덱스(Secondary Index)는 데이터의 주소값(또는 PK)을 들고 있는 별도 리스트인 반면, 기본키는 데이터 그 자체의 정렬 기준임.

---

## 그렇다면 외래키는요?

### FK와 Index
* 외래키는 인덱스가 아님. 단지 제약 조건(Constraint)일 뿐임. 하지만 성능과 데드락 방지를 위해 외래키 칼럼에는 인덱스를 생성하는 것이 권장되며, 많은 DBMS(MySQL 등)는 외래키 생성 시 자동으로 인덱스를 생성함.

---

## 인덱스가 데이터의 물리적 저장에도 영향을 미치나요?

### 물리적 저장 구조
* 영향을 미침. Clustered Index(보통 PK)는 데이터 파일 자체의 저장 순서를 결정함. 인덱스가 없는 테이블(Heap Table)은 삽입 순서대로 저장되거나 비어있는 공간에 임의로 저장됨.

---

## 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요?

### NoSQL 인덱스 특징
* 인덱스를 가짐. MongoDB는 B-Tree 계열 인덱스를 지원하며, Redis는 Sorted Set 등을 통해 유사 기능을 수행함.
* **차이점** : RDB는 강력한 스키마 기반의 인덱싱를 지원하지만, NoSQL은 분산 환경에 최적화된 인덱싱이나 Document 내부 필드(Embedded)에 대한 인덱싱 기능을 강조함.

---

## (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?

### Composite Index의 특징
* 일반적으로 타지 않음(Full Table Scan 수행). 인덱스는 가장 왼쪽 칼럼(A)부터 정렬되어 구축되기 때문임.
* **예외** : 인덱스 내의 모든 정보를 읽어 처리할 수 있는 Index Skip Scan 기능이 활성화된 최신 옵티마이저 환경에서는 제한적으로 인덱스를 활용하기도 함.

---

## RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.

### 확장 및 가용성 전략
* **Replication(복제)** : 마스터 노드의 데이터를 슬레이브 노드로 복사함. 읽기 부하 분산 및 고가용성 목적.
* **Clustering** : 여러 노드를 하나의 시스템처럼 운영하여 고가용성 및 성능 향상.
* **Sharding(샤딩)** : 데이터를 특정 기준(Hash 등)으로 쪼개어 여러 서버에 분산 저장함. 쓰기 부하 분산 목적.

---

## 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?

### 분산 트랜잭션 관리
* **2PC(2-Phase Commit)** : 준비(Prepare)와 커밋(Commit) 두 단계로 모든 노드의 성공을 보장함. 동기식이라 성능이 낮음.
* **Saga Pattern** : 각 서비스의 로컬 트랜잭션을 순차적으로 실행하며, 실패 시 보상 트랜잭션(Compensating Transaction)으로 복구함. 마이크로서비스에서 선호됨.

---

## 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?

### 정합성 유지 전략
* **Semi-Synchronous Replication** : 최소 한 대의 슬레이브가 기록을 완료했음을 확인 후 커밋함.
* **Consistent Hashing** : 항상 동일한 노드에서 읽도록 유도함.
* **Proxy/Middleware** : 쓰기 후 즉시 읽기 요청은 마스터로 강제 전달하는 로직 적용.

---

## 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.

### Deadlock 정의 및 해결
* **정의** : 두 트랜잭션이 서로가 가진 자원의 잠금을 기다리며 무한 대기에 빠지는 현상임.
* **해결 방법**
    1. **데드락 탐지** : DBMS가 Wait-for Graph를 통해 주기적으로 탐지하여 하나를 강제 롤백함.
    2. **타임아웃** : 일정 시간 대기 후 잠금을 획득 못 하면 에러 반환.
    3. **순서 고정** : 모든 트랜잭션이 자원 접근 순서를 동일하게 유지하도록 설계함.

---

## 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?

### 선택 기준
* **Replication 우선** : 읽기 비중이 압도적으로 높고 데이터 총량이 서버 한 대의 용량을 초과하지 않을 때 선택함. 관리가 상대적으로 쉬움.
* **Sharding 선택** : 단일 서버의 저장 용량 한계를 초과하거나, 쓰기 트래픽이 너무 높아 복제만으로 해결 불가능할 때 선택함.

---

## 정규화가 무엇인가요?

### Normalization 정의
* **정의** : 관계형 데이터베이스 설계에서 중복을 최소화하고 데이터 정합성을 높이기 위해 테이블을 구조화하는 과정임.

---

## 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.

### Anomaly(이상 현상)
* **삽입 이상** : 불필요한 데이터를 함께 입력해야만 데이터 삽입이 가능한 경우.
* **삭제 이상** : 한 정보를 삭제할 때 연관된 다른 중요 정보까지 함께 삭제되는 경우.
* **갱신 이상** : 중복된 데이터 중 일부만 수정되어 데이터 불일치가 발생하는 경우.

---

## 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.

### 정규화 단계별 변화
* **1NF(제1정규형)** : 모든 속성 값이 원자값(Atomic)을 갖도록 분리함.
* **2NF(제2정규형)** : 부분 함수 종속성 제거. 기본키의 일부분에만 종속된 속성을 별도 테이블로 분리함.
* **3NF(제3정규형)** : 이행 함수 종속성 제거. 기본키가 아닌 속성 간의 종속 관계를 분리함.

---

## 정규화가 무조건 좋은가요? 역정규화를 하는게 좋은 상황은?

### 정규화의 한계와 Denormalization
* **정규화의 한계** : 테이블 분리로 인해 JOIN 연산이 많아져 조회 성능이 저하될 수 있음.
* **역정규화 권장 상황** : 읽기 성능이 극도로 중요하고, 데이터의 변경 빈도가 낮으며, JOIN 비용이 성능 임계치를 넘을 때 수행

---

## View가 무엇이고, 언제 사용할 수 있나요?

### View 정의 및 활용
* **정의** : 하나 이상의 테이블로부터 유도된 가상의 테이블임. 실제 데이터를 저장하지 않고 쿼리문만 저장
* **활용** : 보안상 특정 칼럼만 노출해야 할 때, 복잡한 JOIN 쿼리를 단순화하여 재사용하고 싶을 때 사용

---

## 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?

### View 수정 가능 여부
* **반영** : 단순 뷰(단일 테이블 기반)는 수정 시 원본 테이블 데이터가 변경됨.
* **제약** : JOIN, 집계 함수, GROUP BY 등이 포함된 복잡한 뷰는 수정이 불가능함.

---

## DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.

### JOIN 정의 및 종류
* **정의** : 둘 이상의 테이블을 연결하여 데이터를 조회하는 연산임.
* **Inner Join** : 양쪽 테이블에 모두 매칭되는 행만 반환함.
* **Left/Right Outer Join** : 한쪽 테이블을 기준으로 매칭되지 않는 행은 NULL로 표시하여 반환함.
* **Full Outer Join** : 양쪽의 모든 행을 반환함.

---

## JOIN의 내부적 구현 방식 예시에 대해 설명해 주세요.

### Join Algorithms
* **Nested Loop Join** : 중첩 반복문을 돌리듯 외부 테이블의 한 행마다 내부 테이블을 스캔함. 인덱스가 있을 때 효율적임.
* **Hash Join** : 작은 테이블을 해시 맵으로 만들어 메모리에 올린 후 대조함. 대용량 처리에 유리함 (인덱스 불필요).
* **Sort Merge Join** : 양쪽 테이블을 정렬한 후 스캔하며 병합함.

---

## 입력한 쿼리에서 어떤 구현 방식을 사용하는지는 어떻게 알 수 있나요?

### 실행 계획 확인
* **방법** : 쿼리 앞에 EXPLAIN 키워드를 붙여 실행함. 옵티마이저가 선택한 JOIN 방식(예: hash join), 사용된 인덱스, 스캔 순서 등을 확인할 수 있음.

---

## JOIN의 성능도 인덱스의 유무의 영향을 받나요?

### 인덱스와 JOIN 성능
* **막대한 영향** : 특히 Nested Loop Join 시 내부 테이블의 조인 칼럼에 인덱스가 없다면 매번 Full Table Scan을 해야 하므로 성능이 기하급수적으로 느려짐.

---

## 3중 조인 부터는 동작 방식이 약간 바뀝니다. 어떻게 동작하나요?

### Multi-way Join 동작
* **동작 방식** : 세 테이블을 동시에 조인하는 것이 아니라, 두 테이블을 먼저 조인하여 중간 결과 집합을 만든 후, 그 결과와 세 번째 테이블을 조인함.
* **성능 영향** : 어떤 테이블을 먼저 조인하느냐(Join Order)에 따라 중간 결과의 크기가 달라지므로 옵티마이저의 순서 결정이 성능의 핵심임.

---

## B-Tree와 B+Tree에 대해 설명해 주세요.

### Index Data Structures
* **B-Tree** : 모든 노드에 키와 데이터를 함께 저장함. 탐색 시 Root에서 데이터를 만날 가능성이 있어 평균 탐색 시간이 빠를 수 있음.
* **B+Tree** : 리프 노드에만 데이터를 저장하고, 나머지 노드에는 키만 저장함. 리프 노드끼리 Linked List로 연결되어 있어 범위 스캔(Range Scan)에 매우 유리함. 대부분의 RDB 인덱스 구조임.

---

## B+Tree가 B-Tree에 비해 반드시 좋다고 할 수 있을까요? 단점은?

### B+Tree의 단점
* 특정 키를 찾기 위해 반드시 리프 노드까지 내려가야 하므로, 운 좋게 루트 근처에서 데이터를 찾는 B-Tree의 'Best Case'보다는 탐색 시간이 길 수 있음.

---

## DB에서 RBT(Red-Black Tree)를 사용하지 않고, B-Tree/B+Tree를 사용하는 이유?

### Disk I/O 최적화
* RBT는 이진 트리이므로 데이터가 많아질수록 깊이가 깊어짐. B-Tree 계열은 노드 하나가 디스크 블록(Page) 단위와 일치하며, 수십~수백 개의 자식을 가질 수 있어 트리 높이를 낮게 유지함(Disk I/O 최소화).

---

## 오름차순 인덱스에서 내림차순 정렬 시 성능은?

### 인덱스 스캔 방향
* **동작** : B+Tree의 리프 노드는 양방향 연결 리스트(Doubly Linked List) 구조임. 따라서 오름차순 인덱스를 뒤에서부터 읽는 '인덱스 역순 스캔(Index Backward Scan)'으로 처리 가능함.
* **성능** : 순방향 스캔보다는 약간 느리지만(CPU 아키텍처 및 페이지 방향성 때문), 정렬 연산을 새로 수행하는 것보다는 훨씬 빠름.

---

## DB Locking에 대해 설명해 주세요.

### Lock의 정의 및 수준
* **정의** : 동시에 여러 사용자가 데이터에 접근할 때 데이터의 일관성을 유지하기 위한 제어 메커니즘임.
* **수준** : Database, Table, Page, Row 단위 잠금이 존재함. 단위가 작을수록 동시성은 높으나 관리 오버헤드가 큼.

---

## Optimistic Lock/Pessimistic Lock에 대해 설명해 주세요.

### 낙관적/비관적 잠금
* **Pessimistic Lock (비관적)** : 충돌이 날 것으로 가정하고 데이터 조회 시점부터 실제 Lock을 거는 방식 (SELECT ... FOR UPDATE)
* **Optimistic Lock (낙관적)** : 충돌이 나지 않을 것으로 가정함. 버전 번호(Version) 등을 활용하여 커밋 시점에만 데이터 변경 여부를 확인함. 애플리케이션 레벨에서 처리함.

---

## 비정상 종료 시 Lock이 해제되지 않는 문제의 해결책은?

### Deadlock 및 Zombie Lock 관리
* **해결책**
    1. **Keep-alive/Heartbeat** : 세션 연결이 끊기면 DB가 자동으로 소유한 락을 해제함.
    2. **Transaction Timeout** : 특정 시간 이상 지속되는 트랜잭션을 강제 종료함.
    3. **InnoDB Monitor** : 내부적으로 좀비 프로세스를 탐지하여 자원 회수.

---

## 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?

### Scaling 전략
* **Scale-up** : CPU, RAM 등 서버 성능 업그레이드.
* **Scale-out** : 서버 대수를 늘림. (Replication, Sharding 활용)
* **CQRS** : 읽기와 쓰기 DB를 분리하여 처리 효율을 높임.

---

## DB 서버를 분산하지 않고, 트래픽을 감당할 수 있는 방법은 없을까요?

### 최적화 기법
* **Query Tuning** : 실행 계획 분석 및 인덱스 최적화.
* **Connection Pooling** : 연결 비용 절감.
* **Caching** : Redis 등을 사용하여 반복적인 조회 요청을 메모리에서 처리.

---

## Schema가 무엇인가요?

### 스키마 정의
* **정의** : 데이터베이스의 구조와 제약 조건에 관한 전반적인 정의임. 데이터 개체, 속성, 관계 등을 포함함.

---

## 3계층 스키마에 대해 설명해 주세요.

### Schema Architecture
* **외부 스키마 (External)** : 개별 사용자 관점의 뷰.
* **개념 스키마 (Conceptual)** : 전체 데이터베이스의 논리적 구조 (통합 관점).
* **내부 스키마 (Internal)** : 물리적 저장 구조 및 장치 관점.

---

## DB의 Connection Pool에 대해 설명해 주세요.

### Connection Pooling
* **정의** : 미리 일정 수의 DB 커넥션을 생성하여 풀(Pool)에 보관해 두었다가, 요청 시 빌려주고 반납받는 방식임. 커넥션 생성/해제에 드는 과도한 비용을 절감함.

---

## Client가 Connection을 어떻게 구성하는지 설명해 주세요.

### 커넥션 수립 과정
1. 드라이버 로드.
2. DB 서버 주소, 계정 정보 전달.
3. TCP/IP 핸드쉐이크 및 인증.
4. 세션 생성 및 커넥션 객체 반환.

---

## Table Full Scan, Index Range Scan에 대해 설명해 주세요.

### Scan 방식
* **Table Full Scan** : 테이블의 모든 블록을 처음부터 끝까지 읽음.
* **Index Range Scan** : 인덱스의 특정 범위를 탐색하여 필요한 데이터의 주소를 찾은 후 테이블에 접근함.

---

## 인덱스를 타는 쿼리임에도 Table Full Scan 방식으로 동작하는 경우가 있습니다. 왜 그럴까요?

### 옵티마이저의 판단 이유
* **데이터 양** : 테이블 전체 데이터가 너무 적어 인덱스 타는 것보다 한 번에 다 읽는 게 빠를 때.
* **선택도(Selectivity)** : 인덱스 조건에 해당하는 데이터 비중이 너무 높을 때(예: 전체의 30% 이상).
* **잘못된 쿼리** : 인덱스 칼럼을 가공하거나(예: WHERE UPPER(name) = '...'), 부정형 조건(!=)을 사용한 경우.

---

## COUNT (개수를 세는 쿼리) 의 동작 과정에는 차이가 있나요?

### COUNT 연산 차이
* **COUNT(*) / COUNT(1)** : 성능 차이 없음. 모든 행(NULL 포함)의 개수를 셉니다.
* **COUNT(column)** : 해당 칼럼이 NULL인 행을 제외하고 개수를 셉니다. 따라서 NULL 여부 검사 과정이 추가됨.

---

## SQL Injection에 대해 설명해 주세요.

### 보안 위협
* **정의** : 사용자 입력값에 SQL 구문을 주입하여 DB의 데이터를 조작하거나 탈취하는 공격 기법임.

---

## 우리가 서버 개발 과정에서 사용하는 수많은 DB 라이브러리들은 이 문제를 어떻게 해결할까요?

### 방어 메커니즘
* **Prepared Statement (Parameterized Query)** : 사용자 입력을 쿼리의 일부로 직접 이어 붙이지 않고, 별도의 파라미터로 처리함. 입력값은 단순 문자열로 취급되어 실행 코드로 작동하지 않음.