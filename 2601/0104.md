# 260104 TIL

## 백엔드 성능 최적화 방법을 설명해 주세요.

### 계층별 최적화 전략
- 백엔드 성능 최적화 : 애플리케이션의 병목 지점을 찾고 이를 해결하는 과정

1.  **애플리케이션 레벨**
    - 불필요한 객체 생성을 줄이고, 효율적인 알고리즘과 자료구조를 사용
    - 비동기 처리를 통해 블로킹을 최소화
2.  **데이터베이스 레벨**
    - 인덱스 튜닝, 쿼리 최적화, 정규화/반정규화 적절한 사용, Connection Pool 설정을 최적화
3.  **인프라 레벨**
    - 스케일 아웃(Scale-out)을 통해 부하를 분산하고, 캐시(Redis)와 CDN을 도입하여 DB와 서버의 부하를 줄임

## 데이터베이스 쿼리 최적화를 위한 방법을 설명해 주세요.

### 실행 계획 분석과 인덱스 활용
```
가장 먼저 실행 계획을 확인하여 쿼리가 인덱스를 제대로 타고 있는지(Index Scan) 아니면 풀 스캔(Full Scan)을 하고 있는지 확인해야 합니다.
```

1.  **인덱스 최적화**
    - `WHERE`, `JOIN`, `ORDER BY` 절에 사용되는 컬럼에 적절한 인덱스를 생성
    - 인덱스가 너무 많으면 쓰기 성능이 저하되므로 주의
2.  **SELECT * 지양**
    - 필요한 컬럼만 명시적으로 조회하여 네트워크 트래픽과 디스크 I/O를 줄임(커버링 인덱스 활용 가능성 증대)
3.  **N+1 문제 해결**
    - JPA 사용 시 연관된 엔티티를 조회할 때 `Fetch Join`이나 `EntityGraph`를 사용하여 쿼리 발생 횟수를 줄임

## Redis의 주요 사용 사례를 설명해 주세요.

### 고속 데이터 처리가 필요한 영역
- **Redis** : 인메모리(In-Memory) 기반의 Key-Value 저장소

1.  **캐싱(Caching)** : DB 조회 부하를 줄이기 위해 자주 조회되는 데이터를 저장(Look-aside 패턴)
2.  **세션 저장소(Session Store)** : 여러 서버 간의 세션 공유(Clustering)를 위해 사용
3.  **실시간 랭킹/리더보드** : `Sorted Set` 자료구조를 활용하여 실시간 순위 산정에 사용
4.  **메시지 큐(Message Queue)** : `Pub/Sub` 기능을 이용해 채팅이나 알림 시스템을 구축

## 캐시(Cache) 메커니즘을 설명하고, 캐시를 사용하는 이유를 이야기해주세요.

### 파레토의 법칙과 성능 향상
- **캐시** : 데이터나 값을 미리 복사해 놓는 임시 저장소

* **메커니즘** 
    1. 클라이언트가 데이터를 요청하면 먼저 캐시 저장소(L1, Redis 등)를 확인(`Cache Hit`)
    2. 데이터가 없으면(Cache Miss) 원본 DB에서 데이터를 가져와 응답하고, 동시에 캐시에 저장
* **사용 이유** :
    1.  **속도 향상** : 디스크(HDD/SSD)보다 메모리(RAM) 접근 속도가 훨씬 빠름
    2.  **부하 분산** : 반복적인 읽기 요청을 캐시가 처리함으로써 원본 데이터베이스의 CPU 및 I/O 부하를 획기적으로 줄임
    3.  **파레토 법칙** : 전체 요청의 80%는 20%의 데이터에 집중된다는 특성을 이용해 효율을 극대화

## CDN(Content Delivery Network)이 무엇이며, 성능 최적화에 어떤 기여를 하는지 설명해 주세요.

### 지리적 지연 시간 감소
- **CDN** : 콘텐츠(이미지, 영상, CSS, JS 등 정적 파일)를 사용자와 물리적으로 가까운 **에지 서버(Edge Server)** 에 미리 캐싱해 두고 전달하는 분산 네트워크 기술

* **성능 기여** : 한국에 있는 사용자가 미국 서버에 있는 이미지를 다운로드할 때, 미국까지 가지 않고 한국에 있는 CDN 서버에서 데이터를 받아오므로 **네트워크 지연 시간(Latency)** 이 줄어듬. 또한 원본 서버(Origin Server)의 트래픽 부하를 덜어줌

## 캐시 무효화(Cache Invalidation) 전략에 대해 설명해주세요.

### 데이터 일관성 유지
캐시된 데이터와 원본 DB 데이터가 달라지는 **데이터 정합성 문제** 해결을 위한 전략입니다.

1.  **TTL(Time To Live) 설정** : 데이터에 만료 시간을 두어 일정 시간이 지나면 자동으로 삭제처리
2.  **Write-Through** : 데이터를 쓸 때 캐시와 DB에 동시에 씀. 항상 최신 데이터를 유지하지만 쓰기 시간이 길어집니다.
3.  **Cache Aside (Look-aside)** : 주로 읽기 시에만 캐시를 갱신하고, 데이터 수정 시에는 캐시를 명시적으로 삭제(Evict)하는 전략

## Redis에서 데이터가 영구적으로 저장되지 않는 이유와 이를 방지하기 위한 방법을 설명해 주세요.

### 인메모리 특성과 지속성(Persistence) 옵션
Redis는 RAM에 데이터를 저장하므로 전원이 꺼지면 데이터가 유실됨. 이를 방지하기 위해 디스크에 `백업`함
**두 방식을 혼용**하여 데이터 안전성과 복구 속도를 모두 챙기는 것이 일반적
| 방식 | RDB (Snapshot) | AOF (Append Only File) |
| :--- | :--- | :--- |
| **개념** | 특점 시점의 메모리 전체를 스냅샷으로 저장 | 모든 쓰기 명령(Command)을 로그 파일에 기록 |
| **장점** | 로딩 속도가 빠르고 파일 크기가 작음 | 데이터 유실 가능성이 매우 적음 (초 단위 설정 가능) |
| **단점** | 스냅샷 이후의 데이터는 유실될 수 있음 | 파일 크기가 계속 커지며, 로딩 속도가 느림 |

## JVM 튜닝을 통한 성능 최적화 방법을 설명해주세요.

### GC 튜닝과 힙 메모리 관리
JVM 튜닝의 핵심은 **Stop-The-World(STW)** 시간을 줄이는 것. STW가 발생하면 GC를 수행하는 스레드를 제외한 모든 애플리케이션 스레드가 멈춤

1.  **Heap Size 조정** : `-Xms`(초기 크기)와 `-Xmx`(최대 크기)를 동일하게 설정하여, 런타임에 힙 크기를 동적으로 늘리거나 줄이는 오버헤드를 제거하는 것이 좋음
2.  **GC 알고리즘 선택** : 애플리케이션 특성에 맞는 GC를 선택(Java 8은 G1GC, Java 11/17 이상은 G1GC가 개선되었으며, 초저지연이 필요하면 **ZGC**를 고려)
3.  **메모리 누수 분석** : 힙 덤프(Heap Dump)를 분석하여 불필요하게 메모리를 점유하는 객체를 찾아 제거

## 스레드 풀(Thread Pool)과 비동기 작업을 사용한 성능 최적화 방법을 설명해주세요.

### 리소스 재사용과 Non-blocking
스레드 생성 비용은 비싸기 때문에(메모리 할당, OS 커널 호출), 매 요청마다 스레드를 생성하는 대신 **스레드 풀**을 사용하여 미리 만들어둔 스레드를 재사용

* **스레드 풀 설정** : 적절한 `CorePoolSize`와 `MaxPoolSize`를 설정해야함. CPU 바운드 작업은 `CPU 코어 수 + 1`, I/O 바운드 작업은 그보다 넉넉하게 설정하는 것이 일반적
* **비동기 작업(@Async)** : 이메일 발송이나 푸시 알림처럼 즉각적인 응답이 필요 없는 무거운 작업은 별도의 스레드(비동기)로 위임하여, 메인 스레드가 즉시 클라이언트에게 응답을 줄 수 있도록 하여 체감 성능을 높임

## 서버의 CPU, 메모리 사용률을 모니터링하고 최적화하는 방법을 설명해 주세요.

### APM 도구 활용 및 병목 분석
**Prometheus & Grafana**, **Pinpoint**, **Datadog** 같은 APM(Application Performance Monitoring) 도구를 활용

1.  **CPU 사용률이 높을 때** : 무한 루프나 복잡한 연산이 있는지 확인하고, 스레드 덤프(Thread Dump)를 떠서 어떤 스레드가 CPU를 점유하는지 분석
2.  **메모리 사용률이 높을 때** : 힙 메모리가 가득 찼다면(Full GC 빈발), 힙 덤프를 분석해 메모리 누수(Leak)를 찾거나 힙 사이즈(`-Xmx`)를 증설
3.  **최적화** : 로직 개선으로 해결되지 않으면 스케일 아웃(서버 증설)이나 스케일 업(사양 업그레이드)을 결정