# 260107 TIL

## 서버 보안의 기본 원칙에 대해 설명해 주세요.

### 3대 요소와 최소 권한 원칙
서버 보안은 **CIA Triad**라고 불리는 **기밀성(Confidentiality), 무결성(Integrity), 가용성(Availability)** 보장을 목표로 합니다.

1.  **최소 권한 원칙(Principle of Least Privilege)** : 사용자나 프로세스에게 작업을 수행하는 데 필요한 최소한의 권한만 부여 
ex) 웹 서버 프로세스는 시스템 설정 파일을 수정할 권한이 없어야 함
2.  **심층 방어(Defense in Depth)** : 단일 보안 계층에 의존하지 않고, 네트워크, OS, 애플리케이션, 데이터 등 여러 계층에 걸쳐 보안 장치 마련
3.  **공격 표면 축소(Reduce Attack Surface)** : 불필요한 포트, 서비스, 소프트웨어를 비활성화하거나 제거하여 공격자가 접근할 수 있는 경로 최소화

## 쿠키와 세션의 차이점이 무엇인지 설명해 주세요.

### 저장 위치와 보안성

| 구분 | 쿠키(Cookie) | 세션(Session) |
| :--- | :--- | :--- |
| **저장 위치** | **클라이언트**(웹 브라우저)에 텍스트 파일로 저장 | **서버**의 메모리나 DB에 객체로 저장 |
| **보안** | 탈취 및 변조가 쉬워 보안에 취약함 | 쿠키에는 세션 ID만 저장하고 실제 데이터는 서버에 있어 비교적 안전 |
| **생명 주기** | 만료 시간을 설정하면 브라우저 종료 후에도 유지됨 | 브라우저 종료 시 삭제되거나 서버 설정 시간에 따라 만료됨 |
| **속도** | 서버 요청 시 헤더에 실려 보내지므로 빠름 | 서버에서 처리가 필요하여 쿠키보다 느림 |

## CSRF(Cross-Site Request Forgery) 공격이 무엇이며, 이를 방지하는 방법을 설명해주세요.

### 사이트 간 요청 위조
- **CSRF** : 사용자가 이미 로그인되어 있는 상태(세션/쿠키 유지)를 이용해 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 만드는 공격


### 방지 방법
1.  **CSRF Token 사용** : 서버는 임의의 난수(Token)를 생성하여 세션에 저장하고, 클라이언트에게 폼 페이지를 줄 때 히든 필드로 같이 전송해 사용자가 요청을 보낼 때 이 토큰값이 세션의 값과 일치하는지 검증
2.  **SameSite Cookie 설정** : 쿠키 설정 시 `SameSite=Strict` 또는 `Lax` 옵션을 주어, 다른 도메인에서 요청을 보낼 때 쿠키가 전송되지 않도록 막음

## HTTPS와 SSL 인증서의 역할에 대해 설명해 주세요.

### 암호화 통신과 신원 보증
- **HTTPS** : HTTP 프로토콜에 **SSL/TLS(Secure Sockets Layer)** 프로토콜을 얹어 데이터를 암호화하여 전송하는 방식

1.  **기밀성(Encryption)** : 대칭키와 공개키 암호화 방식을 혼합하여 패킷을 암호화해서 중간에 해커가 패킷을 가로채도 내용을 알 수 없음
2.  **무결성(Integrity)** : 데이터가 전송 중에 변조되지 않았음을 보장
3.  **인증(Authentication)** : 신뢰할 수 있는 CA(Certificate Authority)가 발급한 **SSL 인증서**를 통해, 접속한 서버가 가짜 사이트가 아님을 보증

## JWT(Json Web Token)의 개념과 이를 사용한 인증 방식을 설명해 주세요.

### 무상태(Stateless) 토큰 인증
- **JWT** : 유저 정보를 JSON 객체에 담아 암호화(서명)하여 클라이언트와 서버 간에 정보를 주고받는 토큰 기반 인증 방식

### 구조와 동작 방식
* **구조** : `Header`(알고리즘 정보) + `Payload`(데이터/Claim) + `Signature`(서명)
* **인증 방식** :
    1.  로그인 성공 시 서버는 비밀키(Secret Key)로 서명된 JWT를 발급하여 클라이언트에게 전달
    2.  서버는 세션을 저장하지 않음(**Stateless**)
    3.  클라이언트는 요청 헤더(`Authorization: Bearer <token>`)에 토큰을 실어 전달
    4.  서버는 서명을 검증하여 유효하면 요청을 처리

## XSS(Cross-Site Scripting) 공격이 무엇이며, 이를 방지하는 방법을 설명해 주세요.

### 악성 스크립트 주입
- **XSS** : 공격자가 웹 페이지에 악성 스크립트(JavaScript)를 삽입하여, 이를 열람하는 다른 사용자의 브라우저에서 스크립트가 실행되게 만드는 공격

### 방지 방법
1.  **입출력 값 검증 및 이스케이프(Escaping)** : 사용자 입력값을 그대로 HTML로 렌더링하지 않고, `<`를 `&lt;`로, `>`를 `&gt;`로 변환하여 스크립트가 실행되지 않고 텍스트로 보이게 함
2.  **HttpOnly Cookie** : 세션 쿠키에 `HttpOnly` 속성을 설정하면, 자바스크립트(`document.cookie`)로 쿠키에 접근하는 것을 차단할 수 있음
3.  **CSP(Content Security Policy)** : 브라우저가 신뢰할 수 있는 소스에서만 스크립트를 실행하도록 정책 설정

## 서버에서 비밀번호를 안전하게 저장하기 위한 방법(예: 해시 함수, 솔팅 등)을 설명해 주세요.

### 단방향 암호화와 키 스트레칭
비밀번호는 절대 평문(Plain text)으로 저장하면 안 되며, 복호화가 불가능한 **단방향 해시 함수**를 사용해야 함

1.  **해시 함수(Hash Function)** : 비밀번호를 고정된 길이의 문자열로 변환 ex) SHA-256
2.  **솔팅(Salting)** : 같은 비밀번호라도 다른 해시값이 나오도록, 임의의 문자열(**Salt**)을 비밀번호에 붙여서 해싱해  미리 계산된 해시 테이블(**Rainbow Table**) 공격을 방어
3.  **키 스트레칭(Key Stretching)** : 해싱을 수천 번 반복하거나, **bcrypt**, **Argon2**, **scrypt**와 같은 알고리즘을 사용하여 해싱에 걸리는 시간을 의도적으로 늦춰 무차별 대입 공격(Brute Force)을 어렵게 만듦

## SQL 인젝션(SQL Injection)이 무엇이며, 이를 방지하기 위한 방법을 설명해 주세요.

- **SQL 인젝션** : 악의적인 SQL 구문을 입력값에 삽입하여 데이터베이스를 비정상적으로 조작하거나 정보를 탈취하는 공격 ex) 로그인 ID에 `' OR 1=1 --` 입력

### 방지 방법
1.  **Prepared Statement(파라미터 바인딩) 사용** : 가장 확실한 방법. DB 컴파일러가 SQL 구문과 데이터를 분리하여 처리하므로, 입력값이 SQL 코드가 아닌 단순 문자열 데이터로만 인식
2.  **ORM(Object Relational Mapping) 사용** : JPA나 Hibernate 같은 ORM 프레임워크는 내부적으로 파라미터 바인딩을 사용하여 쿼리를 생성하므로 안전함
3.  **입력값 검증** : 특수문자 등을 필터링

## OAuth 2.0과 OpenID Connect의 차이점을 설명해 주세요.

두 프로토콜은 목적이 다릅니다.

* **OAuth 2.0 (인가)** : "이 사용자를 대신해서 내 앱이 **무엇을 할 수 있는가?(권한)**"에 초점을 맞춰 결과물로 **Access Token**을 받음(열쇠를 빌려줌)
* **OpenID Connect (인증)** : "이 사용자가 **누구인가?(신원)**"에 초점을 맞춰 OAuth 2.0 프로토콜 위에 구축된 레이어로, 결과물로 **ID Token**(JWT 형식)을 추가로 받음(신분증을 확인)

## CORS(Cross-Origin Resource Sharing)가 무엇이며, 이를 해결하는 방법을 설명해 주세요.

브라우저는 보안상의 이유로 **SOP(Same Origin Policy)** 준수해 로드된 도메인(Origin)과 다른 도메인의 리소스(API)를 요청하는 것을 기본적으로 차단함. **CORS**는 서버가 허용하는 경우에 한해 다른 도메인의 리소스를 사용할 수 있게 해주는 메커니즘

### 해결 방법
1.  **서버 설정** : 서버의 응답 헤더에 `Access-Control-Allow-Origin`을 추가하여 허용할 도메인을 명시(Spring Boot의 경우 `@CrossOrigin` 애너테이션이나 `WebMvcConfigurer` 설정 사용)
2.  **Preflight Request 처리** : 브라우저가 실제 요청(GET/POST) 전에 `OPTIONS` 메서드로 예비 요청을 보내 권한을 확인하므로, 서버는 이에 대한 응답을 적절히 설정해야 함