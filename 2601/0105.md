# 260105 TIL

# 주니어 백엔드 개발자가 반드시 알아야 할 실무 지식

## synchronized
- **`synchronized`** : 자바에서 제공하는 가장 기본적인 동기화 메커니즘. 멀티 스레드 환경에서 하나의 객체나 메서드에 오직 **하나의 스레드만 접근할 수 있도록 보장**

* **특징** 
    * **암시적 락** : 개발자가 명시적으로 락을 걸거나 해제할 필요 없이, 메서드나 블록 진입 시 자동으로 획득하고 빠져나올 때 자동으로 해제
    * **재진입 가능(Reentrant)** : 락을 획득한 스레드는 같은 락이 필요한 다른 `synchronized` 블록에 진입할 수 있음
* **단점** : 대기 중인 스레드를 중단하거나, 락 획득 시 타임아웃을 설정할 수 없어 유연성이 떨어짐

## ReentrantLock
- **ReentrantLock** : `java.util.concurrent.locks` 패키지에서 제공하는 클래스로, `synchronized`보다 더 유연하고 세밀한 제어가 필요할 때 사용

* **기능적 차이** 
    1.  **공정성(Fairness)** : `new ReentrantLock(true)`로 생성하면 대기 시간이 가장 긴 스레드에게 우선권을 줄 수 있음(기본은 비공정)
    2.  **타임아웃** : `tryLock(time, unit)`을 통해 일정 시간만 기다리다가 락을 못 얻으면 포기할 수 있어 데드락 방지에 유리
    3.  **인터럽트** : 락을 기다리는 도중 인터럽트 신호를 받으면 대기를 멈출 수 있음
* **주의사항** : 반드시 `try-finally` 블록을 사용하여 `unlock()`을 명시적으로 호출해야 함. 그렇지 않으면 예외 발생 시 영구적으로 락이 해제되지 않을 수 있음

| 구분 | synchronized | ReentrantLock |
| :--- | :--- | :--- |
| **사용법** | 키워드 사용 | API 호출 |
| **락 해제** | 자동 | 수동 (`finally` 블록 필수) |
| **기능** | 단순 잠금 | 공정성, 타임아웃, 인터럽트 지원 |

## 세마포어(Semaphore)
- **세마포어(Semaphore)** : 뮤텍스(락)와 달리, 동시에 자원에 접근할 수 있는 **스레드의 개수를 제어**하는 동기화 도구

* **동작 원리** :
    * **Permit(허가증)** 개수를 정해두고 시작
    * `acquire()` : 허가증이 있으면 하나 가져가고 실행. 없으면 대기
    * `release()` : 작업을 마친 후 허가증을 반납
* **활용** : DB 커넥션 풀이나 스레드 풀처럼 한정된 자원을 여러 스레드가 나누어 써야 할 때 과부하를 막는 용도로 사용 (허가증이 1개면 뮤텍스와 동일하게 동작)

## 읽기 쓰기 잠금
- **읽기 쓰기 잠금(ReadWriteLock)** : 읽기 작업과 쓰기 작업을 구분하여 락을 관리하는 방식

* **정책** :
    * **읽기(Read) 락** : 데이터가 변경되지 않으므로 여러 스레드가 동시에 접근(공유)
    * **쓰기(Write) 락** : 데이터가 변경되므로 오직 하나의 스레드만 접근
* **장점** : 웹 서비스처럼 읽기 요청이 쓰기 요청보다 압도적으로 많은 환경에서 `synchronized`를 사용하는 것보다 처리량(Throughput)이 훨씬 높음. 자바에서는 `ReentrantReadWriteLock`으로 구현

## 증분쿼리
- **증분쿼리** : 매번 전체 데이터를 조회(Full Scan)하는 대신, 마지막 조회 이후에 **새로 추가되거나 변경된 데이터만** 조회하는 기법. 주로 배치 작업이나 검색 엔진 인덱싱, 데이터 동기화에서 사용

* **구현 방법** :
    1.  **Timestamp 기준** : `WHERE updated_at > 'last_execution_time'` 조건을 사용하여 마지막 실행 시간 이후 변경된 건만 가져옴
    2.  **Auto Increment ID 기준** : `WHERE id > last_max_id` 조건을 사용하여 새로 생성된 건만 가져옴
* **장점** : 데이터 처리량을 줄여 DB 부하를 최소화하고, 동기화 속도를 획기적으로 높일 수 있음
* **단점** : 물리적으로 삭제된 데이터(`DELETE`)는 감지하기 어렵기 때문에, 삭제 로그를 따로 관리하거나 Soft Delete를 사용해야 함