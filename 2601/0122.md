# 260122 TIL

## JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
### JVM(Java Virtual Machine) 정의 및 기능
* **정의 :** Java Bytecode를 OS에 특화된 기계어로 변환하여 실행하는 가상 머신
* **기능 :** 
    * **OS 독립성 제공:** 'Write Once, Run Anywhere' 구현
    * **메모리 관리:** Garbage Collection(GC)을 통한 자동 메모리 해제
    * **보안:** Bytecode Verifier를 통한 코드 유효성 검사

## 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
### JVM 기반 언어의 다양성
* **가능함 :** JVM은 특정 언어가 아닌 Java Bytecode(.class 파일)를 실행 
* **실행 가능한 언어 종류 :** Kotlin, Scala, Groovy, Clojure, JRuby, Jython 등이 존재

## 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
### Native Compilation 가능 여부
* **가능함 :** GraalVM의 `Native Image` 기능을 사용하면 JVM 없이 실행 가능한 OS 전용 Binary로 컴파일할 수 있음. 
* **특징 :** 실행 속도가 빠르고 메모리 점유율이 낮으나, 컴파일 시간이 길고 Reflection 등 일부 동적 기능 제약이 있음.

## VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
### VM 기반 실행의 특성
* **장점 :** 
    * OS와 하드웨어 아키텍처에 독립적인 배포 가능
    * GC를 통한 메모리 안전성 확보
    * 런타임 중 JIT Compiler를 통한 최적화 수행
* **단점 :** 
    * OS 직접 호출 대비 성능 오버헤드 발생
    * VM 구동 및 초기 클래스 로딩으로 인한 초기 실행 속도 저하

## JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
### 프로세스 관계에 대한 오류 정정
* JVM과 내부에서 실행되고 있는 프로그램은 부모-자식 프로세스 관계가 아님
* JVM 자체가 하나의 OS 프로세스이며, 자바 프로그램은 해당 프로세스 내에서 실행되는 코드. 자바의 각 작업 단위는 프로세스가 아닌 **Thread**로 관리

## final 키워드를 사용하면, 어떤 이점이 있나요?
### final 키워드의 효과
* **불변성 확보 :** 값이 변경되지 않음을 보장하여 Side Effect 방지
* **Thread-safe :** 멀티 스레드 환경에서 데이터 오염 방지
* **최적화 :** 컴파일러가 해당 변수를 상수로 취급하여 인라인 처리 등의 최적화 수행 가능

## 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
### 컴파일 타임 처리
* **상수 풀(Constant Pool) 등록 :** `static final`로 선언된 기본 타입이나 `String`은 컴파일 시점에 결정되어 직접 치환됨
* **제약 검사 :** 컴파일러가 할당 코드를 확인하여 재할당 시 에러를 발생시킴

## 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
### 구조 및 목적 차이
* **추상 클래스(Abstract Class) :** '상속'을 통해 부모의 기능을 확장(`extends`)하는 것이 목적. 필드(상태)를 가질 수 있으며 "Is-a" 관계에 사용
* **인터페이스(Interface) :** '구현'을 통해 기능 규약을 정의(`implements`)하는 것이 목적. 상태를 가질 수 없으며(Java 8 이후 static/default 메서드 제외), "Has-a" 또는 "Can-do" 관계에 사용

## 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
### 다중 상속의 문제와 해결
* **다중 상속 금지 이유 :** Diamond Problem(두 부모 클래스에 동일한 메서드가 있을 시 모호함 발생) 방지.
* **인터페이스 다중 구현 이유 :** 인터페이스는 메서드 선언부만 존재하므로 구현체에서 메서드를 오버라이딩하면 모호함이 발생하지 않음(Java 8 default 메서드 충돌 시에도 개발자가 직접 명시하도록 강제함)

## 리플렉션에 대해 설명해 주세요.
### Reflection 정의
* **정의 :** 런타임에 클래스, 인터페이스, 필드, 메서드의 정보를 분석하거나 객체를 생성하고 조작
* **원리 :** JVM의 Class Loader가 로딩한 클래스 메타데이터 정보를 활용

## 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
### 보안 위협 및 방어
* **보안 위협 존재 :** `private` 접근 제어자를 무시하고 필드/메서드에 접근 가능하여 캡슐화 파괴. 
* **방지 방법** 
    * **SecurityManager :** 런타임 권한 체크 수행(단, Java 17 이후 Deprecated). 
    * **Module System(Java 9+) :** `module-info.java`를 통해 특정 패키지의 Reflection 접근 권한(`opens`)을 명시적으로 제한.

## 리플렉션을 언제 활용할 수 있을까요?
### 주요 활용 사례
* **Framework 개발 :** Spring의 DI(의존성 주입), Hibernate의 엔티티 매핑
* **Library 개발 :** Jackson(JSON 직렬화), JUnit(테스트 메서드 실행)
* **IDE 기능 :** 코드 자동 완성, 클래스 계층 구조 분석

## static class와 static method를 비교해 주세요.
### static 구성 요소의 특징
* **Static Class :** 외부 클래스의 인스턴스 없이도 생성 가능. 외부 클래스에 대한 참조를 유지하지 않아 메모리 누수 방지.
* **Static Method :** 인스턴스 생성 없이 클래스명으로 호출. 클래스 로딩 시점에 메모리에 할당됨.

## static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
### 이점 및 제약 사항
* **이점 :** 객체 생성 비용 절감. 데이터 공유 용이. 
* **제약 :** 
    * **Non-static 접근 불가 :** `static` 영역에서 인스턴스 변수/메서드 직접 호출 불가.
    * **Overriding 불가 :** 클래스 레벨의 기능이므로 다형성 적용 안 됨.
    * **메모리 유지 :** GC의 대상이 아니므로 프로그램 종료 시까지 메모리 점유.

## 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
### Class Loading 단계 처리
* **로딩 시점 :** 클래스가 처음 참조될 때 Class Loader에 의해 Method Area(Metaspace)에 고정 할당됨.
* **초기화 :** `static` 블록과 `static` 필드가 소스 코드 순서에 따라 실행 및 초기화됨.

## Java의 Exception에 대해 설명해 주세요.
### 예외 구조
* **Throwable :** 모든 예외와 에러의 최상위 클래스
* **Error :** 시스템 레벨의 심각한 문제 (StackOverflowError 등, 복구 불가)
* **Exception :** 응용 프로그램 레벨의 예외(복구 가능성 있음)

## 예외처리를 하는 세 방법에 대해 설명해 주세요.
### 예외 처리 전략
1. **예외 복구 :** `try-catch` 블록을 사용하여 정상 흐름으로 유도
2. **예외 회피 :** `throws` 키워드를 사용하여 호출자에게 처리를 위임
3. **예외 전환 :** 발생한 예외를 적절한 의미를 가진 커스텀 예외로 감싸서 다시 던짐

## CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
### 체크 유무에 따른 구분
* **Checked Exception :** `RuntimeException`을 상속받지 않음. 컴파일 시점에 예외 처리를 강제함(예: `IOException`)
* **Unchecked Exception :** `RuntimeException`을 상속받음. 컴파일 시점에 체크하지 않음(예: `NullPointerException`)

## 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
### 성능 부하 및 최적화
* **성능 저하 사실 :** 예외 발생 시 Stack Trace를 생성하는 과정에서 오버헤드 발생
* **부하 감소 방안 :** 
    * 비즈니스 로직 제어용으로 예외를 사용하지 않음(if문 권장)
    * 스택 정보가 필요 없는 경우 `fillInStackTrace()` 메서드를 재정의하여 스택 생성을 생략함

## Synchronized 키워드에 대해 설명해 주세요.
### 동기화 메커니즘
* **정의 :** 여러 스레드가 공유 자원에 동시 접근할 때, 한 번에 하나의 스레드만 접근하도록 Lock을 거는 장치
* **동작 :** 자바 객체마다 존재하는 `Monitor Lock`을 활용

## Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
### 적용 위치에 따른 범위
* **Method :** 해당 인스턴스(`this`) 전체에 Lock을 걺
* **Static Method :** 해당 클래스의 Class 객체 전체에 Lock을 걺
* **Block :** 특정 객체를 지정하여 해당 블록 구간만 Lock을 걺 (범위를 최소화할 때 권장)

## 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
### 성능 관점의 평가
* **부정적 사실 :** Lock 획득을 위해 스레드가 `Blocking` 상태로 대기하며 컨텍스트 스위칭 오버헤드가 발생함. 
* **대안 :** 성능이 중요한 멀티 스레드 환경에서는 `Non-blocking` 방식의 동기화가 더 효율적임.

## Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
### 동기화 대안
* **Concurrent Collections :** `ConcurrentHashMap` 등 내부적으로 세분화된 Lock 사용
* **Atomic Classes :** `AtomicInteger` 등 CAS(Compare And Swap) 알고리즘 사용
* **Lock API :** `ReentrantLock` 등 더 세밀한 제어(Time-out 등) 제공

## Thread Local에 대해 설명해 주세요.
### Thread Local 정의
* **정의 :** 각 스레드마다 독립적인 저장 공간을 제공하는 클래스
* **특징 :** 전역 변수처럼 접근 가능하지만 다른 스레드와 공유되지 않음. Thread Pool 사용 시 `remove()`를 호출하지 않으면 메모리 누수 위험이 있음.

## Java Stream에 대해 설명해 주세요.
### Stream API 특징
* **정의 :** 데이터 소스를 추상화하여 선언형으로 처리하는 API
* **특징 :** 
    * 원본 데이터를 변경하지 않음
    * 일회성
    * 지연 연산을 수행

## Stream과 for ~ loop의 성능 차이를 비교해 주세요,
### 성능 비교 (Fact 기반)
* **단순 반복 :** `for-loop`가 더 빠름. `Stream`은 객체 생성 및 파이프라인 호출 오버헤드가 존재함.
* **복잡한 로직/대용량 데이터 :** 병렬 처리가 용이한 `Stream`이 유리할 수 있으나, 가독성과 유지보수성이 핵심 이점

## Stream은 병렬처리 할 수 있나요?
### 병렬 스트림
* **가능함 :** `parallelStream()` 메서드를 호출하여 사용. 
* **원리 :** 내부적으로 `Fork/Join Framework`와 `Common Pool`을 사용. 데이터 순서가 중요하거나 데이터 양이 적을 때는 오히려 성능이 저하될 수 있음.

## Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
### 주요 인터페이스
* **Predicate :** 인자를 받아 boolean 반환(`filter`)
* **Consumer :** 인자를 받아 처리하고 반환 없음(`forEach`)
* **Supplier :** 인자 없이 결과 반환(`generate`)
* **Function :** 인자를 받아 다른 타입으로 변환(`map`)

## 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
### Variable Capture 제약
* **이유 :** 람다나 익명 클래스는 외부의 지역 변수를 사용할 때 '복사본'을 사용. 원본 변수의 값이 변경되면 데이터 불일치가 발생하므로, 값이 변하지 않음을 보장해야 함.
* **제약 :** `Java 8`부터는 명시적 `final`이 없어도 값이 한 번도 변하지 않았다면 **Effectively Final**로 간주하여 사용 가능.

## Java의 GC에 대해 설명해 주세요.
### Garbage Collection 메커니즘
* **정의 :** Heap 메모리 영역에서 더 이상 참조되지 않는 객체를 자동으로 찾아 삭제하는 프로세스
* **Young Generation :** 새로 생성된 객체 배치(Minor GC). 
* **Old Generation :** 살아남은 객체 이동(Major/Full GC).



## finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
### finalize()의 위험성
* **실행 비보장 :** JVM이 언제 실행할지 알 수 없으며, 실행되지 않을 수도 있음. 
* **성능 저하 :** GC 작업의 효율을 떨어뜨리고 시스템 리소스를 낭비함. Java 9 이후 Deprecated 됨.

## 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
* 변수가 `null`이 되면 기존에 참조하던 객체는 Reachability를 잃음. 다른 곳에서 참조하고 있지 않다면 다음 GC 수행 시 수거 대상이 됨.

## equals()와 hashcode()에 대해 설명해 주세요.
### 동등성 비교 원칙
* **equals() :** 두 객체의 논리적 동등성(내용)을 비교 
* **hashCode() :** 객체를 식별하는 정수 값을 반환
* **규칙 :** `equals()`가 `true`인 두 객체는 반드시 같은 `hashCode()`를 가져야 함.

## 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
### hashCode() 구현 전략
* **일관성 :** 객체 변경이 없다면 항상 같은 값 반환
* **분포도 :** 서로 다른 객체는 가능한 다른 해시값을 반환하여 해시 충돌 최소화
* **성능 :** 연산이 너무 복잡하지 않도록 주요 필드만 활용

## 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
### equals() 구현 원칙
* **반사성, 대칭성, 추이성, 일관성** 보장. 
* **Null 체크 및 타입 체크** 필수. 
* **중요 필드 비교 :** 객체의 핵심 정체성을 나타내는 필드들을 모두 비교

## IoC와 DI에 대해 설명해 주세요.
### 제어의 역전과 의존성 주입
* **IoC(Inversion of Control) :** 객체의 생명주기와 의존성 관리 권한을 개발자가 아닌 컨테이너(Spring)에 넘기는 것. 
* **DI(Dependency Injection) :** 사용할 객체를 직접 생성하지 않고 외부에서 주입받음

## 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
### Bean 관리의 이점
* **Singleton 보장 :** 인스턴스 중복 생성 방지 및 메모리 효율
* **생명주기 제어 :** 초기화 및 소멸 시점의 콜백 관리
* **Proxy 활용:** AOP(트랜잭션, 로깅 등) 기능을 적용하기 위해서는 컨테이너가 관리하는 Bean이어야 함

## Spring의 Bean 생성 주기에 대해 설명해 주세요.
### Bean Lifecycle
1. **Instantiate :** 객체 생성
2. **Populate Properties :** 의존성 주입
3. **Initialization :** `postConstruct` 등 초기화 콜백 실행
4. **Destruction :** 컨테이너 종료 시 `preDestroy` 등 소멸 콜백 실행



## 프로토타입 빈은 무엇인가요?
### Prototype Bean 특징
* **특징 :** 컨테이너에 요청할 때마다 새로운 인스턴스를 생성함
* **주의 :** 초기화는 수행하지만, 소멸 단계는 스프링 컨테이너가 관리하지 않으므로 개발자가 직접 관리해야 함

## AOP에 대해 설명해 주세요.
### Aspect Oriented Programming
* **정의 :** `공통 관심사(Cross-cutting Concerns)`를 비즈니스 로직에서 분리하여 모듈화하는 프로그래밍 패러다임
* **예시 :** 로깅, 트랜잭션 관리, 보안

## @Aspect는 어떻게 동작하나요?
### Aspect 동작 원리
* **Proxy 기반 :** 스프링 런타임에 타겟 객체를 감싸는 Proxy 객체를 생성함. 
* **기법 :** 인터페이스가 있으면 JDK Dynamic Proxy, 없으면 CGLIB 라이브러리를 사용

## Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
### 실행 위치 및 제어 범위
* **Filter :** Servlet Context에서 동작. Spring Context 외부
* **Interceptor :** DispatcherServlet과 Controller 사이(Spring Context)에서 동작. Spring Bean 접근 가능



## 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?
### Filter 사용 사례
* **저수준 웹 처리 :** 스프링과 무관한 전역적인 인코딩 변환, XSS 방어, 로깅, 서블릿 레벨의 보안 인증 수행 시 사용

## DispatcherServlet 의 역할에 대해 설명해 주세요.
### Front Controller
* **역할 :** 클라이언트의 모든 요청을 한 곳에서 받아 핸들러 매핑을 통해 적절한 컨트롤러로 분배하고 결과를 응답하는 중앙 처리 장치

## 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?
### 동시 요청 처리
* DispatcherServlet은 싱글톤으로 동작하지만, 이를 호출하는 Servlet Container(Tomcat)가 요청마다 스레드를 생성하여 처리하므로 멀티 스레드 방식으로 동시 처리가 가능

## @Controller 를 DispatcherServlet은 어떻게 구분 할까요?
### Handler Mapping
* **원리 :** 애플리케이션 구동 시 `@Controller` 및 `@RequestMapping` 정보를 스캔하여 `HandlerMapping` 객체 내부에 Map 형태로 저장. 요청 시 URL 정보를 키로 하여 핸들러를 검색함.

## JPA와 같은 ORM을 사용하는 이유가 무엇인가요?
### ORM의 목적
* **생산성 향상 :** SQL을 직접 작성하지 않고 객체 중심 개발 가능
* **유지보수 용이 :** 스키마 변경 시 쿼리 수정 최소화
* **패러다임 불일치 해결 :** 객체지향의 상속, 연관 관계 등을 관계형 DB에 맞게 변환

## 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
### Persistence Context 기능
* **기능 :** 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지(Dirty Checking)
* **성능 향상 :** 같은 트랜잭션 내 반복 조회 시 DB 접근 생략 및 쿼리 최적화(Batch Insert 등)를 통해 도움

## N + 1 문제에 대해 설명해 주세요.
### 연관 관계 조회 문제
* **정의 :** 1번의 쿼리로 N개의 데이터를 가져왔으나, 연관된 데이터를 가져오기 위해 추가로 N번의 쿼리가 실행되는 현상 
* **해결 :** `Fetch Join`, `@EntityGraph`, 혹은 `batch_size` 설정을 통해 해결

## @Transactional 은 어떤 기능을 하나요?
### 트랜잭션 관리
* **정의 :** 메서드 실행 단위를 하나의 트랜잭션으로 묶어 원자성(Atomicity)을 보장
* **원리 :** AOP를 통해 메서드 시작 전 `begin`, 종료 후 `commit`/`rollback` 로직을 프록시가 삽입

## @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
### 읽기 전용 트랜잭션
* **기능:** 
    * **Dirty Checking 생략 :** 변경 감지를 위한 Snapshot을 생성하지 않아 메모리 및 성능 절약. 
    * **DB 최적화 :** DB 서버가 Master-Slave 구조일 때 Slave(읽기 전용) 서버로 요청 유도.

## 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?
### 명시적 선언의 필요성
* **지연 로딩(Lazy Loading) :** JPA의 지연 로딩은 트랜잭션(영속성 컨텍스트) 범위 내에서만 작동함. 안 붙일 경우 `LazyInitializationException` 발생 가능 
* **데이터 일관성 :** 여러 번의 조회가 하나의 스냅샷 기준으로 이루어져야 하는 경우 트랜잭션이 필요함

## Java 에서 Annotation 은 어떤 기능을 하나요?
### Metadata 제공
* **정의 :** 코드에 붙이는 주석 이상의 메타데이터 
* **기능 :** 컴파일러 체크, 빌드 도구의 자동 코드 생성, 런타임 중 Reflection을 통한 특수 로직 수행 지시

## 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 것일까요?
* Annotation 자체는 기능이 없으나, Spring Framework가 런타임에 클래스를 스캔하여 특정 Annotation이 붙은 객체를 찾아 가로채기(AOP), 주입(DI) 등의 복잡한 처리를 대신 수행해주기 때문

## Lombok @Data를 잘 사용하지 않는 이유는 무엇일까요?
### @Data의 위험성
* **캡슐화 위반 :** 모든 필드에 대한 `@Setter` 생성으로 불변성 유지 어려움
* **순환 참조 :** `@ToString`, `@EqualsAndHashCode`가 양방향 연관 관계에서 무한 루프 유발 가능
* **과도한 생성 :** 필요 없는 메서드까지 모두 생성하여 가독성 저해

## Tomcat이 정확히 어떤 역할을 하는 도구인가요?
### Servlet Container(WASM)
* **역할 :** HTTP 요청을 수신하여 자바 Servlet 객체를 호출하고 결과를 반환하는 웹 애플리케이션 서버. 서블릿의 생명주기를 관리

## 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?
### Non-blocking 네트워크 프레임워크
* **정의 :** 비동기 이벤트 기반의 고성능 네트워크 프레임워크
* **사용 이유 :** 적은 수의 스레드로 대량의 동시 접속(C10K 문제)을 효율적으로 처리하기 위함. Spring WebFlux, gRPC, API Gateway 구현 시 핵심적으로 사용

---
