# 260121 TIL

## Optional 클래스의 필요성과 올바른 사용 방법은 무엇인가요?



### 필요성

Optional : `NullPointerException` 발생 가능성을 낮추고, 값이 없을 수 있는 상황을 명시적으로 표현하기 위해 도입된 Wrapper Class



### 올바른 사용 방법

* **반환 타입으로만 사용 :** 메서드의 반환 타입으로 사용하여 호출자에게 값이 없을 수 있음을 알림. 멤버 변수나 매개변수로 사용하는 것은 지양함.

* **orElse 대신 orElseGet 사용 :** 기본값이 필요할 때 연산 비용이 크다면 Supplier를 사용하는 orElseGet을 권장함.

* **isPresent().get() 지양 :** 대신 ifPresent(), orElseThrow(), map() 등을 활용하여 체이닝 방식으로 처리함.



---



## Functional Interface와 Lambda Expression에 대해 설명해 주세요.



### Functional Interface

단 하나의 추상 메서드만을 가진 인터페이스임. `@FunctionalInterface` 어노테이션을 사용하여 명시함. (예 : Runnable, Consumer, Function)



### Lambda Expression

함수형 인터페이스를 구현하는 익명 함수를 단순화한 표현식임. 코드가 간결해지고 메서드 인수로 전달 가능하여 함수형 프로그래밍을 지원함.







---



## Method Reference의 종류와 사용 방법을 설명해 주세요.



### 정의 및 종류

람다식이 단 하나의 메서드만 호출하는 경우 이를 더욱 간결하게 표현하는 방식임.

1. **Static Method Reference :** `ClassName::methodName`

2. **Instance Method Reference (특정 객체) :** `instance::methodName`

3. **Instance Method Reference (임의 객체) :** `ClassName::methodName`

4. **Constructor Reference :** `ClassName::new`



---



## CompletableFuture의 동작 원리와 사용 방법을 설명해 주세요.



### 동작 원리

Future의 한계를 보완하여 비동기 작업의 결과물을 결합하고 예외 처리를 수행함. 내부적으로 ForkJoinPool을 사용하여 작업을 수행하며, 콜백을 통해 결과 처리를 논블로킹 방식으로 지원함.



### 주요 메서드

* **supplyAsync :** 결과를 반환하는 비동기 작업 실행.

* **thenApply :** 결과물을 가공하여 다음 작업으로 전달.

* **thenCompose :** 두 비동기 작업을 순차적으로 연결.

* **allOf :** 모든 작업이 완료될 때까지 대기.







---



## Java의 리플렉션(Reflection)이란 무엇이고 언제 사용하나요?



### 정의

런타임에 클래스, 인터페이스, 필드, 메서드 등의 정보를 분석하고 객체를 생성하거나 메서드를 호출하는 기술임.



### 사용 시나리오

* **Framework 제작 :** Spring의 의존성 주입이나 Hibernate의 엔티티 매핑 등에서 사용함.

* **Library 개발 :** 컴파일 시점에 타입을 알 수 없는 동적인 객체 처리가 필요할 때 활용함.

* **주의사항 :** 캡슐화를 저해하고 성능 오버헤드가 발생하며 컴파일 시점의 타입 체크가 불가능함.



---



## 동적 프록시(Dynamic Proxy)의 동작 원리를 설명해 주세요.



### 작동 방식

런타임에 특정 인터페이스를 구현하는 가공의 클래스(Proxy)를 생성하여 타겟 객체의 로직을 가로채고 부가 기능을 수행하는 기법임.

* **JDK Dynamic Proxy :** 인터페이스가 반드시 존재해야 함. `InvocationHandler`를 구현하여 로직을 정의함.

* **CGLIB :** 바이트코드를 조작하여 클래스를 상속받아 생성함. 인터페이스가 없는 경우에도 사용 가능하며 성능이 더 우수함.







---



## Annotation의 동작 원리와 커스텀 Annotation 작성 방법은 무엇인가요?



### 동작 원리

코드에 붙이는 메타데이터임. 컴파일러에게 정보를 주거나 런타임에 리플렉션을 통해 특정 로직을 수행하도록 지시함.



### 작성 방법

1. **정의 :** `@interface`를 사용하여 선언함.

2. **Meta-Annotation 설정 :**

    * `@Retention` : 유지 범위 결정 (Source, Class, Runtime).

    * `@Target` : 적용 대상 결정 (Type, Field, Method 등).

3. **속성 정의 :** 메서드 형태로 속성을 선언하며 기본값 설정이 가능함.



---



## Java의 직렬화(Serialization)와 역직렬화에 대해 설명해 주세요.



### 개념

* **Serialization :** 자바 객체를 이진 데이터(Byte Stream)로 변환하는 과정임. 파일 저장이나 네트워크 전송 시 사용함. `Serializable` 인터페이스 구현이 필요함.

* **Deserialization :** 이진 데이터를 다시 자바 객체로 복원하는 과정임.



---



## serialVersionUID의 역할은 무엇인가요?



### 역할

직렬화된 객체의 버전 번호임. 역직렬화 시 직렬화했을 때의 클래스 버전과 현재 클래스의 버전이 일치하는지 확인하는 용도임. 명시하지 않으면 클래스 구조 변경 시 역직렬화 과정에서 `InvalidClassException`이 발생할 수 있음.



---



## Java의 모듈 시스템(Java 9+)에 대해 설명해 주세요.



### JPMS (Java Platform Module System)

패키지보다 큰 단위인 Module을 정의함. `module-info.java` 파일을 통해 어떤 패키지를 외부로 노출할지(exports), 어떤 모듈을 사용할지(requires) 명시함.

* **목점 :** 캡슐화 강화, 의존성 관리의 명확화, 런타임 메모리 사용량 최적화.



---



## var 키워드(Java 10+)의 사용과 제한사항은 무엇인가요?



### 특징 및 제한

Local Variable Type Inference : 로컬 변수의 타입을 컴파일러가 초기화 값을 바탕으로 추론함.

* **제한사항 :** 로컬 변수에서만 사용 가능함. 멤버 변수, 메서드 매개변수, 반환 타입으로는 사용할 수 없음. 선언과 동시에 반드시 초기화가 필요함.



---



## Record 클래스(Java 14+)의 특징과 사용 시나리오를 설명해 주세요.



### 특징

데이터를 전달하기 위한 용도의 불변(Immutable) 객체를 정의함. 생성자, Accessor, equals, hashCode, toString 메서드를 컴파일러가 자동으로 생성해 줌.



### 시나리오

DTO (Data Transfer Order) 작성이나 API 응답 데이터를 담는 객체와 같이 오직 데이터 저장과 전달이 목적인 경우에 사용함.



---



## Sealed Class(Java 17+)란 무엇이고 왜 필요한가요?



### 정의 및 필요성

상속받을 수 있는 하위 클래스를 명시적으로 제한하는 클래스임. `permits` 키워드를 사용함.

* **필요성 :** 무분별한 상속을 방지하여 도메인 모델의 무결성을 지키고, 계층 구조를 명확히 설계하기 위해 도입됨. Pattern Matching과 결합 시 모든 케이스를 체크하기 용이함.



---



## Pattern Matching(Java 14+)의 개선사항을 설명해 주세요.



### 개선 사항

1. **instanceof :** `if (obj instanceof String s)`와 같이 타입 확인과 형변환을 동시에 수행함.

2. **Switch Expressions :** `case String s ->`와 같이 switch 문 내에서 패턴 매칭과 변수 할당이 가능해짐. 코드의 가독성을 높이고 불필요한 캐스팅 코드를 제거함.