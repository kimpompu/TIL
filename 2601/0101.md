# 260101 TIL

## Java(Kotlin)으로 구성된 프로젝트의 Kotlin(Java) 컨버팅 작업이 가능한지, 무엇을 염두에 두어야 하는지 이야기해주세요.

### 상호운용성과 주의점
Java와 Kotlin은 모두 JVM 위에서 동작하며 100% 상호운용성을 가지므로 컨버팅 작업은 충분히 **가능**합니다. 하지만 단순 문법 변환을 넘어 언어적 특성을 고려해야 합니다.

1.  **Null Safety** : Kotlin은 Null이 될 수 있는 타입(`?`)과 없는 타입을 엄격히 구분합니다. Java 코드를 변환할 때 `Optional` 처리나 Null 체크 로직을 Kotlin의 Nullable 타입으로 적절히 변환해야 `NullPointerException`을 방지할 수 있습니다.
2.  **Lombok 제거** : Java에서 사용하던 `@Getter`, `@Setter`, `@Data` 등의 Lombok 애너테이션은 Kotlin의 **Data Class**로 대체해야 합니다.
3.  **Static 키워드** : Kotlin에는 `static` 키워드가 없습니다. 대신 **Companion Object**나 패키지 레벨 함수로 대체해야 하므로 구조적인 변경이 필요할 수 있습니다.
4.  **Checked Exception** : Kotlin은 Checked Exception을 강제하지 않습니다. Java에서 예외 처리를 강제하던 로직이 Kotlin으로 넘어오면서 누락되지 않도록 주의해야 합니다.



## Legacy Spring과 최근 Spring 또는 Spring Boot의 차이점을 설명해주세요.

### 생산성과 설정의 간소화
가장 큰 차이는 **설정의 복잡도**와 **내장 서버 유무**입니다.

| 비교 항목 | Legacy Spring (Spring Framework) | Spring Boot |
| :--- | :--- | :--- |
| **설정 방식** | 복잡한 `XML` 설정이 주를 이룸. 초기 세팅이 매우 어려움. | **Auto Configuration** 기반. `application.yml` 등으로 간소화됨. |
| **의존성 관리** | 필요한 라이브러리 버전을 일일이 맞춰야 함. | **Starter** 의존성을 통해 검증된 라이브러리 조합을 한 번에 가져옴. |
| **실행 환경** | 별도의 WAS(Tomcat 등)를 설치하고 WAR 파일을 배포해야 함. | **내장 Tomcat**을 포함하고 있어 JAR 파일 하나로 즉시 실행 가능(`java -jar`). |
| **모니터링** | 별도 구현 필요. | **Actuator**를 통해 헬스 체크 및 매트릭 모니터링 기본 제공. |

## Spring의 의존성 주입(Dependency Injection)이란 무엇이며, 이를 사용하는 이유를 설명해 주세요.

### 제어의 역전(IoC) 구현체
**의존성 주입(DI)** 은 객체가 자신이 사용할 의존성(객체)을 직접 생성(`new`)하는 것이 아니라, 외부(Spring 컨테이너)로부터 주입받아 사용하는 디자인 패턴입니다.



1.  **결합도 감소(Decoupling)** : 객체 간의 의존 관계가 느슨해져서, 구현 클래스가 변경되더라도 코드를 수정할 필요가 줄어듭니다.
2.  **테스트 용이성** : 실제 객체 대신 **Mock 객체**를 주입하기 쉬워 단위 테스트 작성이 수월해집니다.
3.  **코드 가독성 및 유지보수** : 객체의 생성과 사용의 관심사를 분리하여 비즈니스 로직에만 집중할 수 있습니다.

## AOP(Aspect Oriented Programming)가 무엇이며, Spring에서 AOP를 어떻게 구현할 수 있는지 설명해 주세요.

### 관점 지향 프로그래밍
**AOP**는 로깅, 보안, 트랜잭션 관리처럼 애플리케이션 전반에 걸쳐 공통적으로 사용되는 기능(**횡단 관심사, Cross-cutting Concerns**)을 비즈니스 로직에서 분리하여 모듈화하는 프로그래밍 기법입니다.



* **구현 방법** : Spring에서는 주로 **프록시 패턴(Proxy Pattern)** 을 사용하여 구현합니다.
    * `@Aspect` 애너테이션을 사용하여 Aspect 클래스를 정의합니다.
    * `@Pointcut`으로 적용할 위치(메서드 등)를 지정합니다.
    * `@Before`, `@After`, `@Around` 등의 어드바이스(Advice)를 사용하여 실행 시점을 결정합니다.

## Spring Boot에서 JPA와 Hibernate의 차이점을 설명해 주세요.

### 인터페이스와 구현체
이 둘은 **역할** 이 다릅니다.

* **JPA(Java Persistence API)** : 자바 애플리케이션에서 관계형 데이터베이스를 어떻게 사용할지 정의한 **명세(인터페이스 표준)** 입니다. 구체적인 코드가 아닌 규칙의 집합입니다.
* **Hibernate** : JPA 인터페이스를 실제로 구현한 **라이브러리(구현체)** 입니다. JPA의 핵심인 `EntityManager` 등을 내부적으로 구현하여 동작하게 만듭니다.
* **Spring Data JPA** : JPA를 한 단계 더 추상화하여, `Repository` 인터페이스만으로 쿼리를 실행할 수 있게 해주는 Spring의 모듈입니다. (내부적으로 Hibernate를 사용합니다.)

## Spring에서 @Transactional 애너테이션의 역할을 설명해 주세요.

### 트랜잭션 경계 설정
`@Transactional`은 해당 메서드나 클래스의 로직을 하나의 **트랜잭션** 으로 묶어주는 역할을 합니다.

1.  **원자성 보장** : 메서드 실행 도중 예외(기본적으로 `RuntimeException`)가 발생하면 수행했던 모든 DB 작업을 **자동으로 롤백(Rollback)**합니다. 정상 종료 시에는 **커밋(Commit)**
2.  **옵션 제공** : `격리 수준(Isolation)`, `전파 속성(Propagation)`, `읽기 전용(readOnly)`, `롤백 대상 예외` 등을 설정할 수 있습니다.
3.  **AOP 기반** : 프록시 객체가 트랜잭션을 시작(`begin`)하고 종료(`commit`/`rollback`)하는 코드를 앞뒤로 넣어줍니다.

## Spring Security의 기본 개념을 설명해 주세요.

### 인증(Authentication)과 인가(Authorization)
Spring Security는 애플리케이션의 보안(인증, 인가, 권한 관리 등)을 담당하는 프레임워크입니다. 주로 **서블릿 필터 체인(Filter Chain)** 을 통해 동작합니다.



* **인증(Authentication)** : 사용자가 누구인지 확인하는 절차입니다. (예 : 로그인)
    * `AuthenticationManager`, `UserDetailsService` 등을 사용해 DB의 유저 정보와 대조합니다.
* **인가(Authorization)** : 인증된 사용자가 특정 리소스에 접근할 권한이 있는지 확인하는 절차입니다.
* **SecurityContext** : 인증된 사용자 정보(`Authentication` 객체)를 저장하여 전역적으로 접근할 수 있게 합니다.

## Spring Boot의 자동 설정(Auto Configuration) 기능이 무엇이며, 이를 어떻게 활용할 수 있는지 설명해주세요.

### Convention over Configuration
**Auto Configuration**은 프로젝트에 추가된 `jar` 의존성(라이브러리)을 기반으로 Spring Bean을 **자동으로 등록하고 설정**해 주는 기능입니다.
예를 들어, `spring-boot-starter-web`을 추가하면 내장 Tomcat과 Spring MVC 관련 설정이 자동으로 완료됩니다.

* **동작 원리** : `@SpringBootApplication` 안에 있는 `@EnableAutoConfiguration`이 작동하며, 클래스패스에 특정 클래스가 존재하는지(`@ConditionalOnClass`) 등을 확인하여 설정을 적용합니다.
* **활용** : `application.properties`나 `application.yml` 파일에 약속된 키값(예 : `server.port`)만 입력하면 내부 설정을 덮어씌워 커스터마이징할 수 있습니다.

## Spring에서 Bean의 라이프사이클을 설명하고, 이를 관리하는 방법을 이야기해주세요.

### 생성부터 소멸까지
Spring 컨테이너는 Bean 객체의 생명주기를 관리합니다. 주요 순서는 다음과 같습니다.



1.  **스프링 컨테이너 생성**
2.  **스프링 빈 생성** (생성자 호출)
3.  **의존관계 주입** (Setter, Field Injection 등)
4.  **초기화 콜백** : 의존성 주입이 끝난 후 필요한 초기화 작업을 수행합니다. (`@PostConstruct`, `InitializingBean`)
5.  **사용** : 애플리케이션 동작.
6.  **소멸 콜백** : 컨테이너 종료 전 리소스 해제 등을 수행합니다. (`@PreDestroy`, `DisposableBean`)

개발자는 주로 `@PostConstruct`와 `@PreDestroy` 애너테이션을 사용하여 초기화 및 종료 시점의 로직을 관리합니다.

## Spring에서 REST 컨트롤러와 일반 컨트롤러의 차이점에 대해 설명해 주세요.

### View vs Data
두 컨트롤러는 **응답(Response)의 형태** 가 다릅니다.

| 구분 | @Controller | @RestController |
| :--- | :--- | :--- |
| **주 목적** | 전통적인 웹 애플리케이션 (View 반환) | REST API 서비스 (Data 반환) |
| **응답 값** | `String` 반환 시 뷰 리졸버가 동작하여 **HTML 파일(JSP, Thymeleaf)** 찾아서 렌더링합니다. | 객체 반환 시 메시지 컨버터(Jackson 등)가 동작하여 **JSON** 또는 **XML** 데이터로 직렬화하여 반환합니다. |
| **구성** | - | `@Controller` + `@ResponseBody`가 합쳐진 형태입니다. |