# 260102 TIL

## 풀 스캔(Full Scan)
### 정의 및 특징
- **풀 스캔(Full Scan)** :  데이터베이스가 쿼리 결과를 찾기 위해 테이블에 존재하는 모든 **행(Row)** 을 처음부터 끝까지 순차적으로 읽는 방식 = `Table Scan`

* **발생 조건** : `WHERE` 절에 **인덱스가 없는 컬럼** 사용하거나, 인덱스가 있더라도 테이블 전체 데이터의 상당수(보통 20~25% 이상)를 가져와야 할 때 옵티마이저가 인덱스보다 효율적이라고 판단하면 발생
* **성능** : 디스크 I/O가 많이 발생하므로 대용량 테이블에서는 성능이 매우 느림. 하지만 데이터가 아주 적은 소형 테이블에서는 인덱스를 거치는 비용보다 풀 스캔이 더 빠를 수도 있음
## 전문(full-text) 검색
### 개념 및 원리
- **전문 검색(Full-text Search)** : **텍스트 데이터의 내용 전체를 대상으로 키워드 매칭을 수행** SQL의 `LIKE '%keyword%'`와는 다름

* **원리** : 문서를 단어(토큰) 단위로 쪼개어 **역색인(Inverted Index)** 구조를 만듦 ex) 'Apple'이라는 단어가 포함된 문서 ID 목록 저장
* **장점** : 긴 문장이나 본문 내용에서 특정 단어를 찾을 때 `LIKE` 연산보다 압도적으로 빠르며, 검색어의 유사도나 관련성 점수를 매길 수 있음

## 단일 인덱스
- **단일 인덱스(Single Index)** : 테이블의 **하나의 컬럼**만으로 구성된 인덱스

* **사용** : `WHERE name = 'Kim'`과 같이 하나의 조건으로 필터링하는 쿼리에서 효율적
* **한계** : `WHERE name = 'Kim' AND age = 30`처럼 여러 조건이 결합된 쿼리에서는, 인덱스를 통해 'Kim'을 먼저 찾은 뒤 나머지 데이터에서 '30'을 필터링해야 하므로 복합 인덱스보다 효율이 떨어질 수 있음

## 복합 인덱스
- **복합 인덱스(Composite Index)** : 두 개 이상의 컬럼을 묶어서 만든 인덱스. **컬럼의 순서**가 성능에 결정적인 영향을 미침
* **Left-Most Prefix** : 인덱스가 `(A, B, C)` 순서로 생성되었다면, `A` 없이 `B`나 `C`만으로는 인덱스를 쓸 수 없음. 선행 컬럼(A)이 조건절에 있어야 후행 컬럼(B, C)도 정렬된 상태를 활용할 수 있음
* **카디널리티(Cardinality)** : 일반적으로 중복도가 낮고(유니크한 값), 선택도가 높은 컬럼을 앞쪽에 배치하는 것이 유리

## 커버링 인덱스
- **커버링 인덱스(Covering Index)** : 쿼리 충족에 필요한 **모든 컬럼이 인덱스 자체에 포함**되어 있는 경우
* **동작** : `SELECT id FROM user WHERE age = 30` 쿼리에서 `(age, id)`로 구성된 인덱스가 있다고 가정. 인덱스 트리만 검색하면 `age`와 `id` 값을 모두 알 수 있으므로, 실제 데이터 파일(테이블)을 읽으러 가는 **랜덤 I/O 접근**을 생략
* **장점** : 디스크 I/O를 획기적으로 줄여주어 쿼리 성능을 최적화하는 가장 강력한 방법 중 하나

## count() 함수 사용하지 않기
- 전체 row 조회가 강제적이기 때문에 데이터가 많을수록 DB 성능에 영향을 준다

* **해결방법** 
    1.  **커버링 인덱스 활용** : `count(*)` 대신 `count(index_column)`을 사용하여 데이터 블록 접근을 줄임
    2.  **근사치 사용** : 정확한 개수가 필요 없다면 `SHOW TABLE STATUS`의 `rows` 값(통계 정보)을 사용
    3.  **별도 카운터 관리** : Redis나 별도 테이블에 `insert`/`delete` 시마다 카운트를 증감시켜 저장해 두고 조회

## 단편화와 최적화
* **단편화(Fragmentation)** : 데이터를 삭제(`DELETE`)하거나 가변 길이 문자열을 수정(`UPDATE`)하면, 데이터 페이지 중간중간에 빈 공간(Hole)이 생김. 실제 데이터는 적은데 파일 크기는 커지고, 읽어야 할 페이지 수가 늘어나 성능이 저하
* **최적화(Optimization)** : `OPTIMIZE TABLE` 명령어나 테이블 재생성(`ALTER TABLE ... ENGINE=InnoDB`)을 수행하여 빈 공간을 정리하고 데이터를 밀착(Compaction)시켜 디스크 공간을 회수하고 I/O 효율을 높이는 방법

## 연결 타임아웃
- `Connection Timeout` : 클라이언트가 데이터베이스 서버와 **초기 연결(Handshake)**을 맺는 데 소요되는 최대 시간

* **발생 상황** : DB 서버 전원이 꺼져 있거나, IP 주소가 잘못되었거나, 방화벽이 포트를 차단했을 때 발생
* **특징** : 보통 짧게 설정(예 : 1~3초)하여, 연결조차 안 되는 상황에서 클라이언트가 오랫동안 기다리지 않도록 함

## 읽기 타임아웃
- `Read Timeout(Socket Timeout)` : 연결은 성공했으나, 클라이언트가 요청을 보낸 후 **서버로부터 응답이 오기까지** 기다리는 최대 시간

* **발생 상황** : 슬로우 쿼리로 인해 DB 처리가 오래 걸리거나, 데드락이 발생했거나, 네트워크 패킷이 유실되었을 때 발생
* **특징** : 쿼리의 복잡도에 따라 적절히 설정해야 하며, 너무 짧으면 정상적인 쿼리도 실패할 수 있음

## 재시도를 해도 되는 조건
- 단순 조회 기능
- 연결 타임아웃
- 멱등성을 가진 변경 기능
    - `멱등성` : 연산을 여러 번 적용해도 결과가 달라지지 않음

## 벌크헤드(Bulkhead)
- **벌크헤드(Bulkhead)** : 선박의 선실을 격벽으로 나누어 하나가 침수되어도 배 전체가 가라앉지 않게 하는 구조에서 유래한 디자인 패턴으로 시스템의 자원(스레드 풀, 연결 풀 등)을 서비스별로 격리함
* **예시** : '주문 서비스'용 스레드 풀과 '검색 서비스'용 스레드 풀을 분리해 만약 검색 서비스에 트래픽이 폭주하여 스레드가 고갈되더라도, 주문 서비스용 스레드 풀은 남아있으므로 주문 기능은 정상 작동하게 만듦. **연쇄 장애**를 방지