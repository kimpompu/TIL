# 260103 TIL

## RESTful API의 설계 원칙을 설명해주세요.

### 6가지 핵심 원칙
- **REST(Representational State Transfer)** : 웹의 장점을 최대한 활용하기 위한 아키텍처 스타일

1.  **Uniform Interface(인터페이스 일관성)** : URI로 리소스를 식별하고, 표준 HTTP 메서드(GET, POST, PUT, DELETE)를 사용하여 조작한다.
2.  **Client-Server(클라이언트-서버 구조)** : 자원이 있는 서버와 자원을 요청하는 클라이언트가 독립적으로 분리되어야 한다.
3.  **Stateless(무상태성)** : 서버는 클라이언트의 상태(세션, 쿠키 등)를 저장하지 않는다. 각 요청은 필요한 모든 정보를 담고 있어야 한다.
4.  **Cacheable(캐시 가능)** : HTTP의 캐싱 기능을 적용할 수 있어야 한다.
5.  **Layered System(계층형 구조)** : 클라이언트는 서버가 로드 밸런서인지, 게이트웨이인지 알 수 없으며, 다중 계층으로 구성될 수 있다.
6.  **Code on Demand(선택 사항)** : 서버가 클라이언트에게 실행 가능한 코드(스크립트)를 전송할 수 있다.


## REST와 SOAP의 차이점을 설명해 주세요.

### 아키텍처 스타일 vs 프로토콜

| 구분 | REST | SOAP (Simple Object Access Protocol) |
| :--- | :--- | :--- |
| **정의** | 아키텍처 스타일 | 프로토콜 (규약) |
| **통신** | 주로 HTTP 사용 | HTTP, SMTP 등 다양한 프로토콜 사용 가능 |
| **데이터 포맷** | JSON, XML, Text 등 다양함 (주로 JSON) | **XML**만 사용 |
| **특징** | 유연하고 가벼움. 웹에 최적화됨. | 엄격한 표준(보안, 트랜잭션 등) 존재. 무거움. |
| **사용처** | 웹/모바일 API, 마이크로서비스 | 금융권, 엔터프라이즈 레거시 시스템 |

## API 버전 관리의 중요성과 방법을 설명해 주세요.

### 하위 호환성 보장
API를 업데이트할 때 기존 클라이언트(앱, 웹)가 오작동하지 않도록 **하위 호환성(Backward Compatibility)**을 유지하는 것이 중요

1.  **URI Path** : `GET /v1/users` (가장 직관적이고 많이 사용됨)
2.  **Query Parameter** : `GET /users?version=1`
3.  **Custom Header** : `X-API-VERSION: 1` 헤더를 추가하여 요청.
4.  **Accept Header(Content Negotiation)** : `Accept: application/vnd.company.v1+json` (가장 RESTful한 방식이지만 구현이 복잡함)

## GraphQL과 REST API의 차이점을 설명하고, 실무에서 어떤 상황에 적합한지 이야기해주세요.

### 데이터 페칭(Fetching) 방식의 차이



| 구분 | REST API | GraphQL |
| :--- | :--- | :--- |
| **엔드포인트** | 리소스마다 다름 (예 : `/users`, `/posts`) | **단일 엔드포인트** (주로 `/graphql`) |
| **데이터 로딩** | 서버가 정의한 데이터 전체를 받음 | 클라이언트가 **필요한 데이터만 쿼리**함 |
| **문제 해결** | Over-fetching / Under-fetching 발생 가능 | 필요한 만큼만 가져와서 해결 |

* **REST 적합** : 단순한 데이터 구조, 캐싱 전략이 중요한 경우, 파일 업로드 등.
* **GraphQL 적합** : 서로 다른 모양의 데이터를 요구하는 다양한 클라이언트(모바일, 웹)가 존재할 때, 복잡한 연관 관계 데이터를 한 번에 가져와야 할 때.

## OAuth 2.0이 무엇이며, 이를 사용한 인증 방식에 대해 설명해주세요.

### 권한 위임 프로토콜
**OAuth 2.0**은 사용자가 자신의 비밀번호를 제공하지 않고, 제3자 애플리케이션(Client)에게 자신의 정보(리소스)에 접근할 수 있는 권한을 위임하는 개방형 표준입니다. ex) 구글 로그인, 카카오 로그인



1.  **Resource Owner(사용자)** 가 **Client(앱)** 에게 접근 권한을 요청
2.  Client는 **Authorization Server(인증 서버)** 로 사용자를 리다이렉트
3.  사용자가 로그인을 하고 권한을 승인하면, Client는 **Authorization Code**를 받음
4.  Client는 이 코드를 사용해 인증 서버에 **Access Token**을 요청
5.  발급받은 Access Token을 이용해 **Resource Server(API 서버)** 에 데이터를 요청

## HTTP 상태 코드 중 200, 404, 500의 차이와 각각의 의미를 설명해주세요.

### 요청 처리 결과 분류

* **200 OK (성공)** : 요청이 성공적으로 처리되었음
* **404 Not Found (클라이언트 에러)** : 요청한 리소스(URL)를 서버에서 찾을 수 없음. 경로가 틀렸거나 삭제된 데이터일 수 있음
* **500 Internal Server Error (서버 에러)** : 서버 내부 로직에서 처리하지 못한 예외(Exception)나 버그가 발생하여 요청을 수행할 수 없음

## 멱등성(Idempotency)이란 무엇이며, API 설계 시 이를 어떻게 고려할 수 있는지 설명해주세요.

### 여러 번 수행해도 결과가 같음
- **멱등성(Idempotency)** : 동일한 연산을 여러 번 수행하더라도 결과가 달라지지 않는 성질

* **HTTP 메서드**
    * 멱등함 : `GET`(조회), `PUT`(전체 수정), `DELETE`(삭제)
    * 멱등하지 않음 : `POST`(생성 - 호출할 때마다 새로운 리소스 생성), `PATCH`(일부 수정 - 연산 방식에 따라 다름)
* **설계 시 고려** : 네트워크 타임아웃 등으로 인해 클라이언트가 `POST`(결제 요청 등)를 중복 전송할 수 있기 때문에 이를 방지하기 위해 헤더에 유니크한 **Idempotency Key** 를 담아 보내고, 서버는 이 키를 캐싱하여 이미 처리된 키라면 중복 처리를 막고 이전 결과를 반환하도록 설계해야 함

## API 문서를 자동으로 생성하는 방법(Spring REST Docs 등)에 대해 설명해주세요.

### Swagger vs Spring REST Docs

1.  **Swagger(OpenAPI)** : 코드에 애너테이션(`@Operation` 등)을 붙여 문서를 생성. UI가 화려하고 테스트 기능이 좋지만, 실제 코드와 문서가 불일치할 가능성이 있고 프로덕션 코드에 문서화 코드가 섞이는 단점이 있음
2.  **Spring REST Docs** : **테스트 코드(Test Code)**를 기반으로 문서를 생성합니다. 테스트가 통과해야만 문서가 만들어지므로 **코드와 문서의 일치성(신뢰성)**이 보장되지만 작성 난이도가 다소 높음

## HATEOAS(Hypermedia as the Engine of Application State)란 무엇이며, RESTful API에 어떻게 적용할 수 있는지 설명해 주세요.

### API의 동적 탐색
- **HATEOAS** : REST API의 성숙도 모델 중 가장 높은 단계로, 클라이언트가 서버로부터 받은 응답 내에 **다음에 할 수 있는 작업에 대한 링크(Hypermedia)** 포함

* **적용 방법** : JSON 응답에 `_links` 필드를 추가하여 제공합니다.
    ```json
    {
      "data": { "id": 1, "name": "user" },
      "_links": {
        "self": { "href": "/users/1" },
        "update": { "href": "/users/1", "method": "PUT" }
      }
    }
    ```
* **장점** : 클라이언트는 URI를 하드코딩하지 않고 링크를 따라가며 상태를 전이할 수 있어, 서버의 URI 변경에도 유연하게 대처할 수 있음

## HTTP/2와 HTTP/1.1의 차이점을 설명해 주세요.

### 성능 최적화와 바이너리 전송



| 특징 | HTTP/1.1 | HTTP/2 |
| :--- | :--- | :--- |
| **전송 포맷** | 텍스트(Text) 기반 | **바이너리(Binary)** 프레임 단위 전송 |
| **다중화** | HOL(Head of Line) Blocking 문제 존재 (순차 처리) | **Multiplexing** (한 연결로 여러 요청 병렬 처리) |
| **헤더** | 매 요청마다 중복된 헤더 전송 (텍스트) | **HPACK** 압축을 통해 헤더 크기 최소화 |
| **서버 푸시** | 지원 안 함 | 클라이언트 요청 없이 서버가 리소스(CSS, JS 등)를 미리 전송 가능 |