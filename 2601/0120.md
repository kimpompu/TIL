# 260120 TIL

## JVM의 구조와 동작 원리에 대해 설명해 주세요.

### JVM 구조
JVM(Java Virtual Machine) : 자바 바이트코드를 OS 독립적으로 실행하기 위한 가상 머신
* **Class Loader :** 클래스 파일을 로드하고 링크를 통해 Runtime Data Areas에 배치함.
* **Execution Engine :** 로드된 바이트코드를 명령어 단위로 실행함. Interpreter와 JIT Compiler 방식을 혼용함.
* **Garbage Collector :** Heap 메모리 영역에서 더 이상 참조되지 않는 객체를 찾아 삭제함.
* **Runtime Data Areas :** JVM이 프로그램을 수행하기 위해 OS로부터 할당받은 메모리 공간임.



---

## JVM의 메모리 구조(Heap, Stack, Method Area 등)를 설명해 주세요.

### 상세 영역별 특징
* **Method Area :** 모든 Thread가 공유하며 클래스 정보, 변수 명, Method 정보, Static 변수, Constant Pool 등을 저장함.
* **Heap :** 모든 Thread가 공유하며 `new` 키워드로 생성된 객체와 배열이 저장되는 공간임. Garbage Collection의 주 대상임.
* **Stack :** 각 Thread별로 독자적으로 할당됨. 메서드 호출 시마다 Frame을 생성하며 지역 변수, 매개 변수, 리턴 값 등을 임시 저장함.
* **PC Register :** Thread별로 현재 실행 중인 JVM 명령의 주소를 저장함.
* **Native Method Stack :** 자바 외 언어(C, C++)로 작성된 코드를 실행하기 위한 공간임.



---

## Garbage Collection의 동작 원리와 종류에 대해 설명해 주세요.

### 기본 원리
Stop-the-world : GC 실행을 위해 JVM이 애플리케이션 실행을 멈추는 현상
1. **Mark :** 사용 중인 객체와 그렇지 않은 객체를 식별함.
2. **Sweep :** 식별되지 않은(참조되지 않는) 객체를 메모리에서 해제함.
3. **Compaction :** 분산된 객체들을 정리하여 메모리 파편화를 해결함. (알고리즘에 따라 선택적)

### 종류
* **Serial GC :** Thread 1개로 처리함. 성능이 낮아 적은 메모리 환경에서 사용함.
* **Parallel GC :** 여러 개의 Thread를 사용하여 처리 속도를 높임.
* **CMS GC :** Stop-the-world 시간을 최소화하기 위해 고안되었으나 메모리 파편화 문제가 있음. (현재는 Deprecated)



---

## G1 GC와 다른 GC 알고리즘의 차이점은 무엇인가요?

* **구조적 차이 :** 기존의 물리적 Generation(Young, Old) 구분 대신 Heap을 동일한 크기의 Region으로 나눔
* **동작 방식 :** Garbage가 많은 Region부터 우선적으로 수거
* **장점 :** 바둑판 모양의 구조를 사용하여 효율적으로 메모리를 관리하며 Stop-the-world 시간을 예측 가능하게 유지
* **타 GC와의 차이 :** 전체 Heap을 한 번에 검사하지 않고 Region 단위로 병렬 처리하여 대용량 메모리 환경 최적화

---

## Java의 클래스 로딩 과정을 설명해 주세요.

### 단계별 절차
1. **Loading :** Bootstrap, Extension, Application Class Loader를 통해 클래스 파일을 읽어 메모리에 로드
2. **Linking :**
    * **Verification :** 바이트코드가 유효한지 검사함.
    * **Preparation :** Static 변수에 필요한 메모리를 할당하고 기본값으로 초기화
    * **Resolution :** 심볼릭 레퍼런스를 실제 메모리 주소(Direct Reference)로 변환
3. **Initialization :** Static 변수에 실제 값을 할당하고 Static Block을 실행



---

## static 키워드의 의미와 사용 시 주의사항은 무엇인가요?

### 의미
객체 생성 없이도 Method Area에 메모리를 할당받아 사용할 수 있게 하는 예약어. 프로그램 시작 시 메모리에 적재되며 종료 시까지 유지됨.

### 주의사항
* **메모리 효율 :** 무분별한 사용은 GC의 대상이 아니므로 메모리 부족을 유발
* **상태 공유 :** 전역에서 상태를 공유하므로 멀티 Thread 환경에서 동기화 이슈가 발생
* **객체 지향 위반 :** 데이터가 객체에 종속되지 않아 캡슐화 원칙을 저해할 수 있음

---

## final, finally, finalize의 차이점을 설명해 주세요.

### 용도 비교
* **`final` :** 재정의 또는 변경을 금지(변수 : 상수화, 메서드 : 오버라이딩 금지, 클래스 : 상속 금지)
* **`finally` :** `try-catch` 구문에서 예외 발생 여부와 상관없이 무조건 실행되는 블록. 주로 리소스 해제에 사용
* **`finalize` :** 객체가 GC에 의해 수거되기 전 호출되는 메서드. 예측 불가능성으로 인해 현재는 사용을 지양

---

## 추상 클래스와 인터페이스의 차이점과 사용 시나리오를 설명해 주세요.

### 상세 비교
* **Abstract Class :** 상속(`extends`)을 통해 기능을 확장하고 "Is-a" 관계에서 공통된 상태와 기능을 공유할 때 사용
* **Interface :** 구현(`implements`)을 강제하며 "Has-a" 또는 "Can-do" 관계에서 다중 구현을 통한 계약 정의 시 사용함.

---

## Java 8 이후 인터페이스의 default 메서드와 static 메서드에 대해 설명해 주세요.

### 특징
* **default Method :** 인터페이스 내에서 구현부를 가질 수 있는 메서드. 기존 구현체들을 수정하지 않고도 인터페이스에 새로운 기능을 추가할 수 있게 함(하위 호환성)
* **static Method :** 인터페이스 명으로 직접 호출 가능한 메서드. 관련 유틸리티 기능을 인터페이스 내에 포함시킬 때 사용

---

## Checked Exception과 Unchecked Exception의 차이점은 무엇인가요?

### 비교
* **Checked Exception :** `RuntimeException`을 상속받지 않음. 컴파일 단계에서 체크되며 반드시 `try-catch`나 `throws`로 처리해야 함. (예 : `IOException`)
* **Unchecked Exception :** `RuntimeException`을 상속받음. 컴파일 단계에서 체크되지 않으며 실행 중에 발생함. (예 : `NullPointerException`)

---

## try-with-resources 구문의 동작 원리를 설명해 주세요.

### 메커니즘
AutoCloseable 인터페이스를 구현한 리소스를 try 괄호 안에 선언하면, 블록 종료 시 자동으로 close() 메서드를 호출해 주는 방식임. 명시적인 finally 블록 없이도 안전한 리소스 해제를 보장함.

---

## equals()와 hashCode()의 관계와 오버라이딩 시 주의사항은 무엇인가요?

### 관계 및 원칙
1. **논리적 동등성 :** `equals()`가 true인 두 객체는 `hashCode()`값이 반드시 같아야 함
2. **Collection 효율 :** HashMap, HashSet 등에서 객체를 찾을 때 `hashCode()`를 먼저 비교한 후 `equals()`를 호출하여 성능 최적화
3. **주의사항 :** 둘 중 하나만 오버라이딩할 경우 Hash 기반 자료구조에서 객체를 찾지 못하는 오류 발생

---

## String, StringBuilder, StringBuffer의 차이점을 설명해 주세요.

### 상세 비교
* **String :** Immutable(불변). 연산 시마다 새로운 객체를 생성하므로 문자열 수정이 빈번할 경우 성능이 저하됨.
* **StringBuilder :** Mutable(가변). 단일 Thread 환경에서 성능이 가장 우수함. 동기화를 지원하지 않음.
* **StringBuffer :** Mutable(가변). 메서드별로 동기화 키워드를 지원하여 멀티 Thread 환경에서 안전함(Thread-safe).

---

## Java의 Generic에 대해 설명하고, Type Erasure란 무엇인가요?

### Generic 및 Type Erasure
Generic : 컴파일 시점에 타입을 체크하여 형변환 번거로움을 줄이고 타입 안정성을 높이는 기능임.
Type Erasure : 컴파일 타임에만 타입 제약을 확인하고, 런타임에는 타입을 제거(Object로 변환)하여 하위 버전과의 호환성을 유지하는 메커니즘임.

---

## Comparable과 Comparator의 차이점을 설명해주세요.

### 비교
* **Comparable :** 객체의 기본 정렬 기준을 구현함. `compareTo()` 메서드를 오버라이딩함.
* **Comparator :** 기본 정렬 기준 외에 사용자 정의 정렬 기준을 구현함. `compare()` 메서드를 오버라이딩함.

---

## Java의 Collection Framework 구조를 설명해 주세요.

### 계층 구조
* **Collection :** List, Set, Queue 인터페이스의 상위 인터페이스임.
* **List :** 순서가 있고 중복을 허용함. (ArrayList, LinkedList)
* **Set :** 순서가 없고 중복을 허용하지 않음. (HashSet, TreeSet)
* **Map :** Key와 Value의 쌍으로 데이터를 관리하며 Key는 중복될 수 없음. (HashMap, TreeMap)



---

## ArrayList와 LinkedList의 차이점과 사용 시나리오는 무엇인가요?

### 상세 비교
* **ArrayList :** 내부적으로 배열을 사용함. 인덱스를 통한 조회 속도가 매우 빠르나, 데이터 삽입 및 삭제 시 데이터 이동 비용이 큼.
* **LinkedList :** 노드 간 연결 구조를 사용함. 데이터 삽입 및 삭제 속도가 빠르나, 인덱스 조회를 위해 처음부터 탐색해야 하므로 조회가 느림.

---

## HashMap의 동작 원리와 해시 충돌 해결 방법을 설명해 주세요.

### 동작 원리 및 충돌 해결
* **원리 :** Key의 hashCode() 값을 이용해 배열의 인덱스(Bucket)를 결정함.
* **충돌 해결 :**
    * **Separate Chaining :** 같은 인덱스에 데이터가 쌓이면 LinkedList로 연결함. (Java 8부터 데이터가 많아지면 Red-Black Tree로 변환함)
    * **Open Addressing :** 다른 빈 버킷을 찾아 데이터를 저장함.



---

## ConcurrentHashMap의 동작 원리와 HashMap과의 차이점은 무엇인가요?

### 특징
* **동작 원리 :** 버킷 단위로 Lock을 거는 Segment Lock 또는 CAS(Compare And Swap) 방식을 사용하여 멀티 Thread 환경에서도 높은 성능을 유지함.
* **차이점 :** HashMap은 동기화를 지원하지 않음. Hashtable은 메서드 전체에 Lock을 걸어 느리지만, ConcurrentHashMap은 세밀한 Lock 관리를 통해 안전성과 성능을 동시에 확보함.

---

## Java의 동기화 방법(synchronized, volatile, Atomic 클래스 등)을 설명해 주세요.

### 주요 기법
* **synchronized :** 메서드나 블록 단위로 Lock을 걸어 한 번에 하나의 Thread만 접근 가능하게 함.
* **volatile :** 변수를 CPU Cache가 아닌 Main Memory에서 직접 읽고 쓰게 하여 가시성을 보장함.
* **Atomic Class :** 내부적으로 CAS(Compare And Swap) 알고리즘을 사용하여 Lock 없이도 원자적 연산을 보장함.

---

## volatile 키워드의 의미와 사용 시나리오는 무엇인가요?

### 의미 및 시나리오
의미 : 변수의 값을 항상 Main Memory에 저장하고 읽어오도록 강제하여 Thread 간 데이터 불일치 문제를 해결함.
시나리오 : 한 Thread가 값을 쓰고 다른 Thread가 읽기만 하는 상태에서 최신 값을 보장해야 할 때 사용함. 단, 여러 Thread가 동시에 쓰기 연산을 수행할 경우 원자성을 보장하지 못하므로 주의가 필요함.

---

## Java Memory Model에 대해 설명해 주세요.

### 정의
JMM : Java Memory Model. 여러 Thread가 메모리에 접근할 때 어떤 순서와 방식으로 공유 변수를 가시화하고 제어할지 정의한 명세임. 하드웨어의 CPU Cache와 Main Memory 간의 상호작용 문제를 자바 레벨에서 해결하는 추상적인 모델임.

---

## ThreadLocal의 동작 원리와 주의사항은 무엇인가요?

### 동작 및 주의사항
원리 : Thread 내부의 독립적인 저장 공간을 제공함. 같은 코드라도 Thread마다 다른 값을 보유하게 함.
주의사항 : Thread Pool 환경에서 Thread 재사용 시 이전에 사용한 데이터가 남아있을 수 있으므로, 사용 종료 후 반드시 `remove()`를 호출하여 데이터를 삭제해야 함. 메모리 누수 위험이 있음.

---

## Executor Framework와 Thread Pool에 대해 설명해 주세요.

### 개념
* **Thread Pool :** 미리 Thread를 생성해두고 재사용하여 생성 비용과 오버헤드를 줄이는 관리 기법임.
* **Executor Framework :** Thread Pool을 쉽게 관리하고 작업 제출과 실행을 분리하기 위해 제공되는 인터페이스와 구현체(ThreadPoolExecutor 등)의 집합임.

---

## Fork/Join Framework의 동작 원리를 설명해 주세요.

### 메커니즘
Divide and Conquer : 큰 작업을 작은 단위로 쪼개고(Fork), 각 결과를 합쳐서(Join) 최종 결과를 얻음.
Work Stealing : 할 일이 끝난 Thread가 다른 Thread의 큐에서 작업을 가져와 처리함으로써 자원을 효율적으로 사용함.

---

## Java의 Stream API 동작 원리와 병렬 처리 방법을 설명해 주세요.

### 동작 및 병렬화
* **원리 :** 데이터 소스를 추상화하여 파이프라인 구조로 연결함. 중간 연산(Lazy Evaluation)과 최종 연산을 통해 데이터를 처리함.
* **병렬 처리 :** `parallelStream()`을 호출하여 Fork/Join Framework 기반으로 내부 데이터를 분할하여 여러 Thread에서 병렬로 작업을 수행함. 데이터의 순서나 Thread 동기화 이슈를 고려해야 함.