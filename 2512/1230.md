# 251230 TIL

## Object의 특성에 따라 사용할 수 있는 데이터 구조에는 어떤 것이 있는지 설명해주세요.

### 데이터 성격에 따른 분류
데이터가 가진 특성과 수행해야 할 작업에 따라 적절한 자료구조를 선택해야 합니다.

* **순차적 데이터 (Sequential)** : 데이터의 순서가 중요하고 인덱스로 접근하거나 순회해야 할 때 사용합니다.
    * **Array(배열)**, **ArrayList**, **LinkedList**
* **LIFO / FIFO (입출력 순서)** : 데이터를 넣고 빼는 순서가 정해져 있을 때 사용합니다.
    * **Stack(스택)** : 나중에 들어온 것이 먼저 나감 (후입선출).
    * **Queue(큐)** : 먼저 들어온 것이 먼저 나감 (선입선출).
* **키-값 쌍 (Key-Value)** : 고유한 키를 통해 값을 빠르게 조회해야 할 때 사용합니다.
    * **HashMap**, **HashTable**, **Dictionary**
* **계층적 구조 (Hierarchical)** : 데이터 간에 부모-자식 관계가 있을 때 사용합니다.
    * **Tree(트리)**, **Heap(힙)**
* **관계/네트워크 구조 (Network)** : 데이터 간의 복잡한 다대다 연결 관계를 표현할 때 사용합니다.
    * **Graph(그래프)**

## 스택(Stack)과 큐(Queue)의 차이점과 실제로 사용되는 사례를 설명해주세요.

### 구조적 차이와 활용
두 구조의 가장 큰 차이점은 데이터가 꺼내지는 순서입니다.



| 구분 | 스택(Stack) | 큐(Queue) |
| :--- | :--- | :--- |
| **원칙** | **LIFO** (Last In First Out)<br>후입선출 | **FIFO** (First In First Out)<br>선입선출 |
| **구조** | 한쪽 끝(Top)에서만 삽입/삭제 | 한쪽(Rear)에서 삽입, 반대쪽(Front)에서 삭제 |
| **활용 사례** | 웹 브라우저 '뒤로 가기', 실행 취소(Undo), 함수 호출 스택(재귀) | 프린터 인쇄 대기열, CPU 프로세스 스케줄링, 데이터 버퍼 |

## 연결 리스트(Linked List)의 구조와 사용 사례를 설명해주세요.

### 구조적 특징
**연결 리스트(Linked List)** 는 각 노드(Node)가 **데이터** 와 다음 노드를 가리키는 **포인터(주소)** 로 이루어진 자료구조입니다. 메모리상에 연속적으로 저장되지 않아도 되며, 포인터를 통해 논리적으로 연결됩니다.



* **단일 연결 리스트(Singly Linked List)** : 다음 노드에 대한 참조만 가집니다.
* **이중 연결 리스트(Doubly Linked List)** : 이전 노드와 다음 노드에 대한 참조를 모두 가집니다.

### 사용 사례
* 데이터의 추가와 삭제가 빈번하게 일어나는 경우 (배열보다 효율적).
* 데이터의 개수를 예측할 수 없어 동적으로 메모리를 할당해야 하는 경우.
* 예 : 음악 플레이어의 재생 목록(다음 곡, 이전 곡), 운영체제의 파일 시스템 관리 등.

## 해시맵(HashMap)과 트리(Tree)의 차이점은 무엇이며, 각각 언제 사용하면 좋을지 설명해주세요.

### 비교 및 선택 기준

| 특징 | 해시맵(HashMap) | 트리(Tree, 주로 BST/RB Tree) |
| :--- | :--- | :--- |
| **내부 구조** | 해시 함수를 이용한 배열(Bucket) 저장 | 노드 간의 계층적 연결 구조 |
| **시간 복잡도** | 평균 **O(1)** (검색/삽입/삭제) | 평균 **O(log n)** |
| **정렬 여부** | 데이터가 정렬되지 않음 | 데이터가 정렬된 상태로 유지됨 (In-order 순회) |
| **메모리** | 해시 충돌 방지를 위해 넉넉한 공간 필요 | 필요한 노드만큼만 메모리 사용 |

### 사용 시점
* **해시맵** : 데이터의 순서가 중요하지 않고, **빠른 검색(Lookup)** 속도가 최우선일 때 사용합니다. (예 : ID 중복 체크, 캐싱)
* **트리** : 데이터가 **정렬**되어 있어야 하거나, 범위 검색(Range Search)이 필요할 때 사용합니다. (예 : DB 인덱스, 자동 완성)

## 트리(Tree)와 그래프(Graph)의 차이점을 설명하고, 각각의 장단점을 이야기해주세요.

### 개념적 차이
**트리**는 그래프의 특수한 형태(순환이 없는 연결 그래프)입니다.



| 구분 | 트리(Tree) | 그래프(Graph) |
| :--- | :--- | :--- |
| **루트 노드** | 존재함 (Root) | 개념 없음 (모든 노드가 평등) |
| **순환(Cycle)** | 불가능 (Acyclic) | 가능 (Cyclic / Acyclic) |
| **방향성** | 부모 -> 자식 (계층적 단방향/양방향) | 방향(Directed) 또는 무방향(Undirected) |
| **모델링** | 계층 구조 (조직도, 파일 시스템) | 네트워크 구조 (지도, 소셜 네트워크) |

### 장단점
* **트리** : 계층 구조를 명확히 표현하고 탐색 효율이 높지만, 복잡한 다대다 관계를 표현하기 어렵습니다.
* **그래프** : 현실 세계의 복잡한 관계를 모두 표현할 수 있지만, 탐색 알고리즘이 복잡하고 연산 비용이 높습니다.

## 배열(Array)과 연결 리스트(Linked List)의 차이점과 시간 복잡도를 설명해주세요.

### 주요 차이점
* **배열(Array)** : 메모리상에 **연속적**으로 저장됩니다. 인덱스를 통해 즉시 접근(Random Access)이 가능하지만, 크기가 고정적이고 중간 삽입/삭제 시 데이터를 밀어내는 비용이 듭니다.
* **연결 리스트(Linked List)** : 메모리상에 **비연속적**으로 저장됩니다. 크기가 동적이고 중간 삽입/삭제가 빠르지만(주소를 알 때), 특정 요소에 접근하려면 순차적으로 탐색해야 합니다.



### 시간 복잡도 비교

| 연산 | 배열(Array) | 연결 리스트(Linked List) |
| :--- | :--- | :--- |
| **접근 (Access)** | **O(1)** | O(n) |
| **검색 (Search)** | O(n) | O(n) |
| **삽입/삭제 (Insertion/Deletion)** | O(n) (데이터 이동 필요) | **O(1)** (위치를 아는 경우) |

## 빅오(Big-O) 표기법이란 무엇이며, 자주 사용되는 데이터 구조의 시간 복잡도를 설명해주세요.

### 빅오(Big-O) 표기법
알고리즘의 효율성을 나타내는 지표로, 입력 데이터의 크기(n)가 증가함에 따라 실행 시간(또는 공간)이 얼마나 늘어나는지를 **최악의 경우(Worst Case)**를 기준으로 나타낸 것입니다.


### 자주 사용되는 복잡도
* **O(1) (Constant)** : 입력 크기와 상관없이 일정함. (스택/큐의 삽입/삭제, 해시맵 접근)
* **O(log n) (Logarithmic)** : 입력이 늘어날수록 처리량이 절반씩 줄어듦. (이진 탐색, 이진 탐색 트리 검색)
* **O(n) (Linear)** : 입력 크기에 비례하여 증가. (배열/리스트의 순차 탐색)
* **O(n log n)** : (퀵 정렬, 병합 정렬 등 효율적인 정렬 알고리즘)
* **O(n^2) (Quadratic)** : 이중 루프. (버블 정렬, 삽입 정렬)

## 이진 탐색(Binary Search) 알고리즘을 설명하고, 시간 복잡도를 이야기해주세요.

### 알고리즘 개요
**이진 탐색**은 **정렬된 배열**에서 특정 값을 찾는 탐색 알고리즘입니다. 탐색 범위를 절반씩 줄여가며 데이터를 찾습니다.



1.  배열의 중간값을 선택합니다.
2.  중간값이 찾는 값과 같으면 탐색을 종료합니다.
3.  찾는 값이 중간값보다 작으면 왼쪽 절반을, 크면 오른쪽 절반을 탐색 범위로 지정합니다.
4.  값을 찾거나 범위가 없어질 때까지 반복합니다.

### 시간 복잡도
* **O(log n)** : 한 번 비교할 때마다 탐색 범위가 1/2로 줄어들기 때문에 매우 효율적입니다. 단, 데이터가 반드시 정렬되어 있어야 한다는 전제 조건이 있습니다.

## 정렬 알고리즘 중 퀵 정렬(Quick Sort)과 병합 정렬(Merge Sort)의 차이점을 설명하고, 각각의 시간 복잡도를 이야기해주세요.

### 분할 정복(Divide and Conquer) 알고리즘

| 구분 | 퀵 정렬(Quick Sort) | 병합 정렬(Merge Sort) |
| :--- | :--- | :--- |
| **방식** | **피벗(Pivot)** 기준으로 작은 값과 큰 값으로 분할하여 정렬 | 리스트를 절반으로 계속 나눈 뒤, 합치면서(Merge) 정렬 |
| **평균 시간 복잡도** | **O(n log n)** | **O(n log n)** |
| **최악 시간 복잡도** | **O(n^2)** (피벗이 최솟값/최댓값일 때) | **O(n log n)** (항상 일정) |
| **추가 메모리** | 적음 (In-place sorting 가능) | 많음 (O(n), 임시 배열 필요) |
| **안정성(Stability)** | 불안정 정렬 (Unstable) | 안정 정렬 (Stable) |

일반적으로 메모리 제한이 적고 평균 속도가 중요한 경우 **퀵 정렬**, 최악의 경우에도 일정한 성능 보장이나 안정 정렬이 필요한 경우 **병합 정렬** 선호합니다.

## 그래프에서 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)의 차이점과 사용 사례를 설명해주세요.

### 탐색 방식의 차이



* **DFS(Depth-First Search)** : 루트 노드에서 시작하여 다음 분기(Branch)로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식입니다. (깊게 파고듦)
    * **구현** : 스택(Stack) 또는 재귀함수 사용.
    * **활용** : 미로 찾기, 경로의 존재 여부 확인, 백트래킹.
* **BFS(Breadth-First Search)** : 루트 노드에서 시작하여 인접한 노드를 먼저 탐색하는 방식입니다. (넓게 퍼짐)
    * **구현** : 큐(Queue) 사용.
    * **활용** : **최단 경로 찾기** (가중치가 없는 그래프), 소셜 네트워크 친구 추천

## 대용량 데이터를 처리할 때, 해시맵(HashMap)과 트리(Tree) 중 어느 구조를 선택하는 것이 성능 측면에서 유리한지 설명해 주세요.

### 성능 및 사용 목적에 따른 선택
대용량 데이터 처리는 단순한 조회 속도뿐만 아니라 메모리 효율, 정렬 필요성 등을 종합적으로 고려해야 합니다.

1.  **해시맵(HashMap)을 선택해야 하는 경우**
    * **목적** : 데이터의 순서가 상관없고, **단건 데이터의 빠른 조회/삽입/삭제**가 최우선일 때.
    * **성능** : 평균적으로 **O(1)** 시간 복잡도를 가집니다.
    * **단점** : 해시 충돌(Collision)이 빈번하게 발생하면 성능이 O(n)까지 저하될 수 있으며, 충돌 방지를 위해 실제 데이터보다 넉넉한 메모리 공간(버킷)을 할당해야 하므로 메모리 낭비가 발생할 수 있습니다.

2.  **트리(Tree, 주로 Red-Black Tree 등 균형 트리)를 선택해야 하는 경우**
    * **목적** : 데이터가 **항상 정렬된 상태**여야 하거나, 특정 범위의 데이터를 조회하는 **범위 검색(Range Scan)** 필요할 때.
    * **성능** : 검색, 삽입, 삭제 시 **O(log n)** 의 시간 복잡도를 보장합니다.
    * **장점** : 해시맵보다 조회 속도는 느리지만, 데이터 양이 늘어나도 성능이 안정적이며 해시 충돌 문제에서 자유롭습니다.



## 퀵 정렬(Quick Sort)과 병합 정렬(Merge Sort) 중 어떤 상황에서 어느 알고리즘을 선택하는 것이 적합한지 설명해 주세요.

### 메모리와 데이터 특성에 따른 선택

| 비교 항목 | 퀵 정렬(Quick Sort) | 병합 정렬(Merge Sort) |
| :--- | :--- | :--- |
| **시간 복잡도** | 평균 O(n log n) / 최악 O(n^2) | 항상 O(n log n) |
| **공간 복잡도** | **O(log n)** (스택 메모리만 사용) | **O(n)** (추가 배열 공간 필요) |
| **안정성** | 불안정 정렬(Unstable Sort) | **안정 정렬(Stable Sort)** |
| **적합한 상황** | **메모리가 제한적인 경우**, 일반적인 배열 정렬 시 가장 빠름 (캐시 지역성 우수) | **Linked List 정렬**, 데이터의 순서 유지가 중요한 경우, **외부 정렬**(디스크에 있는 대용량 데이터 정렬) |



## 이진 탐색(Binary Search) 알고리즘을 사용해야 하는 상황과 이 알고리즘의 시간 복잡도를 설명해 주세요.

### 사용 조건 및 상황
**이진 탐색(Binary Search)** 은 업다운(Up-Down) 게임처럼 탐색 범위를 절반씩 좁혀가는 방식입니다.

1.  **필수 전제 조건** : 데이터가 반드시 **정렬(Sorted)**되어 있어야 합니다.
2.  **자료구조 제약** : 인덱스로 임의 접근(Random Access)이 가능해야 하므로 **배열(Array)** 구조에서 효율적입니다. (Linked List에서는 중간 지점으로 바로 갈 수 없어 비효율적임)
3.  **사용 상황** : 데이터의 변경(삽입/삭제)은 적지만 **조회(검색) 빈도가 매우 높은 대용량 데이터**를 다룰 때 적합합니다.

### 시간 복잡도
* **O(log n)** : 10억 개의 데이터가 있어도 약 30번(`2^30`)의 비교만으로 데이터를 찾을 수 있어 매우 강력합니다.

## 그래프(Graph) 구조를 이용해 최단 경로를 구하는 알고리즘(예: 다익스트라 알고리즘)을 설명하고, 실무에서의 사용 사례를 제시해 주세요.

### 다익스트라(Dijkstra) 알고리즘
다익스트라 알고리즘은 **음의 가중치가 없는 그래프**에서 한 정점(노드)에서 다른 모든 정점까지의 최단 경로를 구하는 알고리즘입니다.

1.  **원리** :
    * 시작 노드를 기준으로 연결된 노드 중 가장 비용이 적은 노드를 선택합니다(**Greedy**).
    * 선택된 노드를 거쳐가는 경로가 기존 경로보다 짧으면 값을 갱신합니다.
    * 이 과정을 반복하기 위해 주로 **우선순위 큐(Priority Queue)**를 사용합니다.
2.  **시간 복잡도** : O(E log V) (E : 간선 수, V : 노드 수)

### 실무 사용 사례
* **내비게이션 시스템** : 지도 상의 두 지점 간 최단 거리 또는 최단 시간 경로 탐색.
* **네트워크 라우팅 프로토콜(OSPF)** : 패킷이 목적지까지 가는 가장 빠른 네트워크 경로 산출.
* **게임 개발** : 캐릭터가 장애물을 피해 목적지로 이동하는 경로 탐색 (A* 알고리즘의 기초).



## 스택(Stack)과 큐(Queue)를 사용하는 실제 사례를 설명하고, 각각의 장단점을 비교해 주세요.

### 사용 사례 및 장단점 비교

| 구분 | 스택(Stack) - LIFO | 큐(Queue) - FIFO |
| :--- | :--- | :--- |
| **실제 사례** | 1. **웹 브라우저 뒤로 가기**<br>2. 편집기 **실행 취소(Undo)**<br>3. 함수 호출 메모리 구조(**Call Stack**)<br>4. 괄호 유효성 검사 | 1. **프린터 인쇄 대기열**<br>2. **프로세스 스케줄링**(준비 큐)<br>3. **너비 우선 탐색(BFS)**<br>4. 메시지 큐(Kafka, RabbitMQ) |
| **장점** | 구조가 단순하여 구현이 쉽고, 데이터 저장/읽기 속도가 빠름. 나중에 들어온 데이터를 먼저 처리해야 하는 로직에 최적화됨. | 데이터가 입력된 순서대로 처리됨을 보장하므로, 순차적 작업 처리에 적합함. |
| **단점** | 데이터 탐색 시 중간 데이터에 접근하기 어렵고(꺼내야 함), 크기 제한이 있는 경우 **Stack Overflow** 발생 가능. | 중간 데이터 접근이 어렵고, 구현 방식(배열 등)에 따라 앞부분 공간이 낭비될 수 있음(Circular Queue로 해결). |