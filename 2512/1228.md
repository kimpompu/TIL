# 251228 TIL

## 시스템 콜이 무엇인지 설명해 주세요.

### 정의 및 역할
**시스템 콜(System Call)** 은 운영체제의 커널(Kernel)이 제공하는 서비스에 대해, 응용 프로그램(User Program)의 요청을 처리하기 위한 인터페이스입니다.

사용자 프로그램은 기본적으로 **유저 모드(User Mode)** 에서 실행되며, 하드웨어(디스크, 메모리, CPU 등)에 직접 접근할 수 있는 권한이 없습니다. 파일 읽기/쓰기, 화면 출력, 프로세스 생성 등 하드웨어를 제어하거나 특권 명령이 필요한 작업을 수행해야 할 때, 사용자 프로그램은 시스템 콜을 호출하여 운영체제에게 대행을 요청하게 됩니다. 이를 통해 커널은 자원을 안전하게 관리하고 프로그램을 보호합니다.

## 우리가 사용하는 시스템 콜의 예시를 들어주세요.

### 대표적인 시스템 콜 예시
우리가 C언어나 파이썬 등으로 프로그래밍할 때 사용하는 많은 라이브러리 함수들은 내부적으로 시스템 콜을 호출합니다.

| 분류 | 예시 (Linux 기준) | 설명 |
| :--- | :--- | :--- |
| **프로세스 제어** | `fork()` | 현재 프로세스를 복제하여 자식 프로세스를 생성합니다. |
| | `exec()` | 프로세스의 메모리 공간을 새로운 프로그램으로 덮어씌워 실행합니다. |
| | `exit()` | 프로세스 실행을 종료하고 자원을 반납합니다. |
| | `wait()` | 자식 프로세스가 종료될 때까지 기다립니다. |
| **파일 조작** | `open()` | 파일을 열거나 생성하고 파일 디스크립터를 반환합니다. |
| | `read()` | 파일로부터 데이터를 읽어옵니다. |
| | `write()` | 파일에 데이터를 씁니다. (`printf` 함수도 내부적으로 이를 사용함) |
| | `close()` | 열린 파일을 닫습니다. |
| **장치 관리** | `ioctl()` | 하드웨어 장치의 제어 및 상태 정보를 설정합니다. |
| **정보 유지** | `getpid()` | 현재 프로세스의 ID를 반환합니다. |
| | `time()` | 현재 시스템 시간을 얻어옵니다. |

## 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.

### 실행 과정 (Flow)
시스템 콜은 소프트웨어 인터럽트(Trap)를 통해 실행됩니다.

1.  **라이브러리 함수 호출** : 사용자 프로그램이 `fopen()`이나 `printf()` 같은 표준 라이브러리 함수를 호출합니다.
2.  **시스템 콜 번호 할당** : 라이브러리 내부에서 해당 기능에 매핑되는 **시스템 콜 번호(System Call Number)** 를 CPU 레지스터(예 : EAX)에 저장합니다.
3.  **인터럽트 발생 (Trap)** : `INT 0x80` 혹은 `SYSCALL` 명령어를 실행하여 **소프트웨어 인터럽트(Trap)** 를 발생시킵니다. 이 순간 CPU 모드는 유저 모드에서 **커널 모드**로 전환됩니다.
4.  **핸들러 실행** : CPU는 IDT(Interrupt Descriptor Table)를 참조하여 시스템 콜 핸들러(ISR)로 이동합니다.
5.  **테이블 참조 및 실행** : 커널은 레지스터에 저장된 시스템 콜 번호를 확인하고, **시스템 콜 테이블(System Call Table)** 에서 해당 번호에 맞는 커널 함수를 찾아 실행합니다.
6.  **복귀** : 커널 함수의 실행이 끝나면 결과값을 레지스터에 저장하고, `IRET` 등의 명령어를 통해 다시 **유저 모드** 로 전환하여 사용자 프로그램으로 돌아갑니다.



## 시스템 콜의 유형에 대해 설명해 주세요.

### 주요 6가지 유형
운영체제가 제공하는 서비스의 종류에 따라 다음과 같이 분류할 수 있습니다.

| 유형 | 설명 | 주요 기능 예시 |
| :--- | :--- | :--- |
| **프로세스 제어(Process Control)** | 프로세스의 생성, 실행, 종료 등을 제어 | `fork`, `exit`, `wait` |
| **파일 관리(File Management)** | 파일 및 디렉터리 생성, 읽기, 쓰기, 삭제 | `open`, `read`, `write`, `close` |
| **장치 관리(Device Management)** | 하드웨어 장치 요청, 반환, 읽기/쓰기 | `ioctl`, `read`, `write` |
| **정보 유지(Information Maintenance)** | 시스템 시간, 날짜, 프로세스 정보 설정 및 획득 | `time`, `date`, `getpid` |
| **통신(Communication)** | 프로세스 간 통신(IPC) 연결 및 메시지 전달 | `pipe`, `shmget`, `socket` |
| **보호(Protection)** | 자원에 대한 접근 권한 제어 | `chmod`, `umask`, `chown` |

## 운영체제의 Dual Mode 에 대해 설명해 주세요.

### 이중 모드 (Dual Mode)의 개념
운영체제는 시스템을 보호하기 위해 CPU의 실행 모드를 두 가지로 나누어 관리합니다. CPU 내부의 상태 레지스터에 있는 **모드 비트(Mode Bit)**를 통해 현재 모드를 구분합니다.

1.  **유저 모드 (User Mode, bit = 1)**
    * 사용자 애플리케이션이 실행되는 영역입니다.
    * 제한된 명령만 수행할 수 있으며, 하드웨어(디스크, I/O 등)에 직접 접근할 수 없습니다.
    * 위험한 명령(특권 명령)을 수행하려고 하면 CPU는 예외(Exception)를 발생시켜 프로그램을 강제 종료합니다.

2.  **커널 모드 (Kernel Mode, bit = 0)**
    * 운영체제 코드(커널)가 실행되는 영역입니다. (시스템 모드, 모니터 모드라고도 함)
    * 모든 CPU 명령(특권 명령 포함)을 실행할 수 있고, 모든 메모리 및 하드웨어 자원에 접근할 수 있습니다.
    * 인터럽트, 시스템 콜, 예외 발생 시 진입하게 됩니다.

## 왜 유저모드와 커널모드를 구분해야 하나요?

### 시스템 보호 및 안정성
가장 큰 이유는 **보안(Security)** 과 **안정성(Stability)** 입니다.

* **자원 보호** : 만약 사용자 프로그램이 하드웨어를 직접 제어할 수 있다면, 악의적이거나 잘못 작성된 프로그램이 다른 프로그램의 메모리를 침범하거나 운영체제의 핵심 데이터를 지워버릴 수 있습니다.
* **시스템 붕괴 방지** : 하나의 응용 프로그램에서 발생한 오류가 전체 시스템(OS)을 멈추게 하는(Down) 것을 방지합니다. 중요 자원 접근을 커널 모드로 제한함으로써 운영체제가 문지기(Gatekeeper) 역할을 수행하여 시스템 전체의 무결성을 보장합니다.

## 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?

### 시스템 콜 번호 (System Call Number)
운영체제는 수백 가지의 시스템 콜을 제공합니다. 이들을 구분하기 위해 각 시스템 콜 함수마다 고유한 **정수 번호(ID)** 를 부여합니다.

* **식별 방법** : 사용자가 `read()` 함수를 호출한다고 해서 커널이 이름 문자열 "read"를 인식하는 것이 아닙니다. 컴파일러나 라이브러리가 `read`에 해당하는 번호(예를 들어 리눅스 x86에서 3번)를 레지스터에 저장하고 인터럽트를 겁니다.
* **시스템 콜 테이블** : 커널 내부에는 이 번호와 실제 실행해야 할 커널 함수의 주소를 매핑해 놓은 **시스템 콜 테이블(System Call Table)** 이 존재합니다. 커널은 전달받은 번호를 인덱스로 사용하여 이 테이블에서 정확한 함수를 찾아 실행합니다.