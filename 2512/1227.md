# 251227 TIL

## WebSocket 서버의 부하 분산(load balancing) 전략에는 어떤 것들이 있나요?

### L4 vs L7 로드 밸런싱과 스티키 세션
- WebSocket은 연결이 수립되면 장시간 유지되는 **Stateful** 프로토콜이므로 일반적인 HTTP 로드 밸런싱과는 다른 접근이 필요

1.  **Least Connections 전략** : WebSocket 연결은 길게 유지되므로, 단순히 순서대로 배분하는 라운드 로빈(Round Robin)보다는 현재 연결 수가 가장 적은 서버로 트래픽을 보내는 방식이 유리
2.  **스티키 세션(Sticky Session)** : 핸드쉐이크 과정(HTTP)과 이후의 통신이 동일한 서버에서 이루어지도록 보장. IP 해시나 쿠키를 기반으로 클라이언트가 처음 접속한 서버에 계속 연결되도록 설정
3.  **L4(TCP) 로드 밸런싱** : 패킷 내용을 보지 않고 IP/Port 기반으로 트래픽 분산. 속도가 빠르지만 세밀한 제어가 어려움
4.  **L7(HTTP) 로드 밸런싱** : Nginx나 HAProxy 등을 사용하여 `Upgrade` 헤더를 인식하고 WebSocket 연결을 적절한 백엔드 서버로 라우팅


## WebSocket 연결 유지 시 메모리 및 리소스 관리 방법은 무엇인가요?

### 리소스 누수 방지 및 최적화
수만 개의 동시 연결을 처리하기 위해 다음과 같은 관리가 필수적

* **파일 디스크립터(File Descriptor) 제한 해제** : 리눅스 환경에서는 연결 하나당 파일 디스크립터를 소모하므로 `ulimit` 설정을 통해 OS의 최대 오픈 파일 수를 늘려야 함
* **버퍼 사이즈 조정** : 각 연결마다 할당되는 송수신 버퍼 크기를 애플리케이션 특성에 맞게 줄여 메모리 사용량 최적화
* **Heartbeat 주기 관리** : 너무 잦은 Ping/Pong은 CPU와 대역폭을 낭비하므로 적절한 주기(예 : 30~60초) 설정
* **Zombie Connection 정리** : 클라이언트가 비정상 종료되어 TCP 연결만 남아있는 경우를 탐지하여(Ping 타임아웃 등) 서버 측에서 소켓을 강제로 닫고 메모리를 해제

## WebSocket과 HTTP/2의 주요 차이점은 무엇인가요?

### 프로토콜 설계 목적의 차이
- 두 프로토콜 모두 단일 연결을 통한 효율성을 추구하지만 목적이 다름

| 특징 | WebSocket | HTTP/2 |
| :--- | :--- | :--- |
| **통신 방식** | 양방향<br>(Bi-directional) | 요청/응답 + 서버 푸시(Server Push) |
| **프로토콜** | TCP 기반의 얇은 터널링 | HTTP의 개선된 버전<br>(Stream 기반) |
| **메시지 구조** | 개발자가 정의한 프레임 | HTTP 헤더와 바디 구조 유지 |
| **사용 사례** | 실시간 채팅, 주식 시세, 멀티플레이 게임 | 웹 페이지 로딩 속도 최적화, 리소스 병렬 로딩 |
| **특징** | 연결 후 헤더 오버헤드 거의 없음 | 헤더 압축(HPACK), 멀티플렉싱 지원 |



## WebSocket 연결의 성능 최적화를 위한 고려사항은 무엇인가요?

### 처리량 증대 및 지연 시간 감소
1.  **이진 프로토콜(Binary Protocol) 사용** : JSON(텍스트) 대신 Protobuf나 MessagePack과 같은 이진 포맷을 사용하여 페이로드 크기를 줄이고 파싱 속도를 높임
2.  **메시지 배치 처리(Batching)** : 아주 작은 메시지를 너무 자주 보내는 경우, 이를 모아서 한 번에 전송(Nagle 알고리즘과 유사한 애플리케이션 레벨 배치)하여 시스템 콜 오버헤드를 줄임
3.  **비동기 I/O(Non-blocking I/O)** : Node.js, Netty(Java), Go 등 비동기 처리에 특화된 런타임을 사용하여 스레드 블로킹을 방지
4.  **커널 튜닝** : TCP 버퍼 크기, Ephemeral Port 범위 등 OS 커널 파라미터를 튜닝하여 대규모 연결을 수용하도록 함

## WebSocket 서버 구축 시 장애 조치(failover) 방안을 어떻게 마련할 수 있나요?

### 연결 복구 및 상태 동기화
- WebSocket은 연결 지향적이므로 서버 다운 시 클라이언트 연결이 끊어집니다. 이를 복구하는 전략이 필요

1.  **클라이언트 재연결 로직** : 연결 끊김 감지 시 지수 백오프(Exponential Backoff)를 사용하여 다른 정상 서버로 재접속을 시도
2.  **상태 저장소 분리** : 접속한 사용자의 상태 정보(채팅방 입장 여부 등)를 WebSocket 서버 메모리가 아닌 Redis와 같은 외부 저장소에 저장하여, 서버가 바뀌어도 상태를 유지할 수 있게 함
3.  **메시지 유실 방지** : 재연결 사이 유실된 메시지를 복구하기 위해 메시지 시퀀스 번호를 관리하거나, Kafka 등을 통해 지난 메시지를 다시 읽어오는(Replay) 메커니즘을 구현

## 클라이언트에서 WebSocket 연결 오류를 디버깅하는 방법에는 어떤 것들이 있나요?

### 도구 및 모니터링
1.  **브라우저 개발자 도구** : Network 탭에서 `WS` 필터를 선택하면 핸드쉐이크 요청/응답 헤더와 프레임 단위로 주고받은 메시지 내역을 실시간으로 확인할 수 있음
2.  **Wireshark** : 네트워크 패킷 캡처 도구를 사용하여 TCP 레벨에서의 연결 종료 패킷(FIN, RST)이나 TLS 핸드쉐이크 실패 원인을 분석
3.  **클라이언트 로그** : `onclose` 이벤트 발생 시 넘어오는 `code`(종료 코드)와 `reason`(사유)을 로깅하여 원인을 파악
4.  **wscat** : 커맨드 라인 도구인 `wscat`을 사용하여 서버에 직접 연결을 시도하고 메시지를 테스트

## WebSocket과 서버 푸시(Server-Sent Events)의 차이점은 무엇인가요?

### 양방향 vs 단방향
- **SSE(Server-Sent Events)**는 HTTP 기반으로 서버가 클라이언트에게 데이터를 단방향으로 스트리밍

| 구분 | WebSocket | Server-Sent Events (SSE) |
| :--- | :--- | :--- |
| **통신 방향** | 양방향<br>(Server <-> Client) | 단방향<br>(Server -> Client) |
| **프로토콜** | 전용 프로토콜 (ws/wss) | 표준 HTTP |
| **데이터 형식** | 텍스트 및 **이진(Binary)** 데이터 | **텍스트(UTF-8)**만 가능 |
| **재연결** | 별도 구현 필요 | 브라우저가 **자동 재연결** 지원 |
| **방화벽 친화성** | 일부 프록시에서 문제 발생 가능 | HTTP를 사용하므로 문제 없음 |
| **용도** | 채팅, 게임 | 뉴스 피드, 스포츠 중계, 알림 전송 |

## TLS/SSL을 활용하여 WebSocket 연결을 보호하는 방법에 대해 설명해주세요.

### WSS(WebSocket Secure) 적용
1.  **암호화** : 일반 `ws://` 대신 `wss://`를 사용하면 HTTPS와 마찬가지로 TLS 계층 위에서 핸드쉐이크와 데이터 전송
2.  **인증서 적용** : 서버(또는 로드 밸런서)에 유효한 SSL 인증서를 설치
3.  **중간자 공격 방지** : 데이터가 암호화되므로 공용 와이파이 등에서 패킷을 가로채더라도 내용을 볼 수 없음
4.  **프록시 호환성 향상** : 암호화된 트래픽은 프록시 서버가 내용을 검사하지 않고 투과시키므로, 프록시로 인한 연결 끊김 문제를 줄이는 부수적인 효과가 있음

## WebSocket 통신에서 프록시 서버 사용 시 발생할 수 있는 문제는 무엇인가요?

### 프록시의 이해 부족 및 타임아웃
1.  **Upgrade 헤더 미지원** : 오래된 프록시 서버는 `Upgrade` 헤더를 이해하지 못해 핸드쉐이크 요청을 거부하거나 일반 HTTP 요청으로 처리할 수 있음
2.  **유휴 타임아웃(Idle Timeout)** : 프록시 서버는 일정 시간 데이터 전송이 없으면 연결을 끊는 설정이 되어 있는 경우가 많음. WebSocket은 장시간 연결을 유지하므로 이로 인해 연결이 의도치 않게 종료될 수 있음(해결책 : `Keep-Alive Ping` 전송)
3.  **버퍼링** : 일부 프록시는 응답 전체를 버퍼링한 뒤 보내려 하는데, 스트리밍 성격의 WebSocket과는 맞지 않아 지연이 발생할 수 있음

## WebSocket 라이브러리(예: Socket.IO, ws 등)의 차이점과 선택 기준에 대해 설명해주세요.

### 기능성 vs 성능
* **ws** : Node.js를 위한 가장 가볍고 빠른 WebSocket 구현체입니다. 표준 프로토콜만 지원하며, 부가 기능(재연결, 룸 등)은 직접 구현해야 합니다. **최대 성능이 필요하거나 커스텀 구현이 쉬운 경우** 선택합니다.
* **Socket.IO** : WebSocket을 기반으로 하되, 연결이 불가능한 경우 HTTP Long Polling으로 자동 폴백(Fallback)하는 기능을 제공합니다. 룸(Room), 네임스페이스, 자동 재연결 등을 기본 지원합니다. **개발 편의성과 구형 브라우저 호환성이 중요한 경우** 선택합니다.
* **Spring WebSocket** : Java 환경에서 STOMP 프로토콜과 결합하여 메시지 브로커 방식의 개발을 지원합니다.

## WebSocket을 활용한 Pub/Sub 시스템 구현 방법에 대해 설명해주세요.

### 메시지 브로커 연동
여러 WebSocket 서버가 클러스터링되어 있을 때, 클라이언트 간 메시지 교환을 위해 **Pub/Sub(Publish/Subscribe)** 패턴이 필요합니다.

1.  **구조** : [Client A] -> [WS Server 1] -> [Redis/Kafka] -> [WS Server 2] -> [Client B]
2.  **동작 원리** :
    * Client A가 메시지를 보내면 WS Server 1이 받습니다.
    * WS Server 1은 이 메시지를 Redis 채널(Topic)에 **Publish**합니다.
    * 해당 채널을 **Subscribe**하고 있던 모든 WS Server(1, 2, 3...)가 메시지를 수신합니다.
    * 각 WS Server는 자신의 메모리에 연결된 타겟 클라이언트(Client B)가 있는지 확인하고 메시지를 전달합니다.

## WebSocket 연결 종료 시 graceful shutdown을 구현하는 방법은 무엇인가요?

### 안전한 연결 종료 절차
서버를 배포하거나 재시작할 때 기존 연결을 강제로 끊으면 데이터 유실이 발생할 수 있습니다.

1.  **신규 연결 차단** : 로드 밸런서나 서버 레벨에서 새로운 핸드쉐이크 요청을 받지 않도록 설정
2.  **종료 프레임 전송** : 연결된 모든 클라이언트에게 `Going Away (1001)` 또는 `Service Restart (1012)` 코드를 담은 Close 프레임을 보냄
3.  **대기** : 클라이언트가 진행 중인 작업을 마치고 스스로 연결을 끊거나 재연결을 시도할 때까지 일정 시간(예 : 30초) 대기
4.  **강제 종료** : 타임아웃 이후에도 남아있는 연결은 강제로 종료하고 서버 셧다운

## WebSocket의 버전 관리 및 프로토콜 업데이트가 필요한 이유는 무엇인가요?

### 하위 호환성 및 기능 변경
애플리케이션이 발전하면서 주고받는 메시지의 JSON 구조가 바뀌거나 새로운 기능이 추가될 수 있습니다.

1.  **Subprotocol 활용** : 핸드쉐이크 시 `Sec-WebSocket-Protocol` 헤더를 통해 클라이언트가 사용하려는 버전(예 : `v1.json`, `v2.json`)을 명시하고 서버가 이를 협상
2.  **메시지 내부 버전닝** : 전송되는 JSON 페이로드 안에 `{"version": 2, "type": "chat", ...}`와 같이 버전을 명시하여 서버가 버전에 맞게 파싱 로직을 분기 처리
3.  **이유** : 구버전 앱을 사용하는 사용자와 신버전 앱 사용자가 공존하는 기간 동안 서비스 중단을 막기 위함

## WebSocket 통신에서 데이터 압축 기능을 사용할 때 고려해야 할 점은 무엇인가요?

### permessage-deflate 확장
- WebSocket은 `permessage-deflate` 확장을 통해 메시지를 압축 전송할 수 있음

* **장점** : 텍스트 데이터(JSON 등)의 크기를 획기적으로 줄여 대역폭 비용 절감
* **고려사항** :
    1.  **CPU 사용량 증가** : 압축 및 해제 과정에서 CPU 자원을 많이 소모. CPU 바운드 서버에서는 병목이 될 수 있음
    2.  **이미지/비디오** : 이미 압축된 데이터(JPEG, MP4 등)를 다시 압축하면 효과는 없고 CPU만 낭비하므로 압축을 비활성화
    3.  **CRIME 공격** : 압축 사용 시 보안 취약점(Side-channel attack)에 노출될 가능성이 있으므로 민감한 데이터 전송 시 주의 필요

## WebSocket 연결 시 세션 관리를 구현하는 방법에는 어떤 것들이 있나요?

### 연결과 사용자 매핑
- WebSocket 연결은 HTTP 요청과 달리 쿠키가 매번 전송되지 않으므로(초기 핸드쉐이크 제외), 별도의 세션 관리가 필요

1.  **객체 매핑** : 서버 메모리에 `Map<SessionId, WebSocketSession>` 또는 `Map<UserId, List<WebSocketSession>>` 형태의 자료구조를 만들어 관리
2.  **토큰 기반** : 핸드쉐이크 시 검증된 JWT 등의 토큰에서 사용자 ID를 추출하여 소켓 세션 객체의 속성(Attribute)으로 저장
3.  **외부 저장소** : 서버 재시작 시에도 세션 정보를 유지하려면 Redis 등에 `UserId`와 현재 접속 중인 `ServerId`를 매핑하여 저장

## WebSocket 서버와 클라이언트 간의 인증 및 인가 방식은 어떻게 구현하나요?

### 핸드쉐이크 시점 인증
- WebSocket 표준 API(Javascript)는 임의의 헤더를 추가하는 것을 허용하지 않아 인증 헤더(`Authorization`) 전송이 까다로움

1.  **쿼리 파라미터(Query Parameter)** : `ws://server.com/socket?token=xyz` 형태로 토큰을 전달(로그에 토큰이 남을 수 있어 보안상 주의 필요)
2.  **쿠키(Cookie)** : HTTP 핸드쉐이크 요청 시 브라우저가 자동으로 전송하는 인증 쿠키를 서버에서 검증(CSRF 방어 필요)
3.  **Ticket 방식** : 사전에 HTTP API로 인증 후 일회용 '티켓'을 발급받고, WebSocket 연결 시 이 티켓을 사용하여 검증
4.  **연결 후 인증(On-Connect)** : 소켓 연결이 수립되자마자 첫 번째 메시지로 인증 토큰을 전송하고, 서버가 이를 검증한 후 통신을 허용

## WebSocket 기반 애플리케이션에서 발생할 수 있는 일반적인 문제와 해결 방안은 무엇인가요?

### 대표적인 트러블슈팅
1.  **Head-of-Line Blocking** : TCP 기반이므로 패킷 하나가 손실되면 그 뒤의 모든 패킷 처리가 지연. 실시간성이 극도로 중요한 게임 등에서는 UDP 기반의 WebTransport나 WebRTC 데이터 채널을 고려
2.  **포트 고갈(Port Exhaustion)** : 너무 많은 아웃바운드 연결 시 소스 포트가 부족해질 수 있음. 로드 밸런서 증설이나 가상 IP 활용이 필요
3.  **방화벽 차단** : 일부 기업용 방화벽은 80/443 포트 외의 비표준 포트나 장시간 연결을 차단. 443(WSS) 포트를 사용하고 Heartbeat를 유지하는 것이 좋음