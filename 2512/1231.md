# 251231 TIL

## 개인/팀 프로젝트에 적용해 보았거나 사용할 줄 아는 RDB에 대해 이야기해주세요.

### MySQL/MariaDB 활용 경험
"저는 팀 프로젝트에서 RDB인 **PostgreSQL**을 주로 사용했습니다.
Spring Boot 프로젝트에서 JPA와 연동하여 사용했으며, 트랜잭션 처리을 활용한 데이터 무결성 유지에 중점을 두었습니다. 대용량 알림을 다루기 위해서는 MongoDB를 사용했습니다."

## RDB와 NoSQL DB의 차이점을 설명해주세요.

### 구조와 확장성의 차이



| 구분 | RDB(Relational Database) | NoSQL(Not Only SQL) |
| :--- | :--- | :--- |
| **데이터 구조** | 테이블(Table), 행(Row), 열(Column) 기반의 정해진 스키마 | 문서(Document), 키-값(Key-Value), 그래프 등 유연한 스키마 |
| **확장성** | 수직적 확장(Scale-up) 중심 | 수평적 확장(Scale-out) 중심 |
| **트랜잭션** | 강력한 ACID 보장 | 느슨한 일관성(BASE), Eventual Consistency |
| **사용 사례** | 데이터 무결성이 중요한 금융, 결제 시스템 | 데이터 구조가 자주 바뀌거나 대용량 트래픽 처리 (SNS, 로그) |

## 데이터베이스에서 인덱스를 사용하는 이유와 인덱스가 성능에 미치는 영향을 설명해주세요.

### 검색 속도 향상과 쓰기 성능 저하
**인덱스(Index)**는 책의 '색인'과 같은 역할을 하여, 테이블의 모든 데이터를 뒤지는 풀 스캔(Full Scan) 대신 특정 데이터를 빠르게 찾을 수 있게 해줍니다. (주로 B-Tree 구조 사용)



* **장점(SELECT)** : `WHERE` 절이나 `JOIN`, `ORDER BY`에 사용되는 컬럼에 인덱스를 걸면 검색 속도가 비약적으로 상승합니다(O(N) -> O(log N)).
* **단점(INSERT/UPDATE/DELETE)** : 데이터를 추가하거나 수정할 때, 인덱스 테이블도 함께 정렬 및 갱신해야 하므로 **쓰기 성능이 저하**됩니다. 또한 추가적인 저장 공간을 차지합니다.

## 데이터베이스 정규화(Normalization)와 역정규화(Denormalization)의 차이점에 대해 설명해 주세요.

### 데이터 중복 제거 vs 조회 성능 최적화
* **정규화(Normalization)** : 데이터를 중복 저장하지 않도록 테이블을 쪼개는 과정입니다. 이상 현상(Anomaly)을 방지하고 데이터 무결성을 높이는 것이 목적입니다. ex) 1차, 2차, 3차 정규형
* **역정규화(Denormalization)** : 정규화된 테이블을 다시 합치거나 중복 컬럼을 추가하는 과정입니다. 정규화가 너무 많이 되어 `JOIN` 연산이 과도하게 발생하여 조회 성능이 떨어질 때, **읽기 성능을 향상**시키기 위해 선택적으로 수행합니다.

## 트랜잭션(Transaction)이 무엇이며, ACID 특성을 설명해 주세요.

### 논리적인 작업 단위와 4가지 원칙
**트랜잭션**은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위입니다. 

1.  **Atomicity(원자성)** : 트랜잭션 내의 작업은 모두 성공하거나, 모두 실패해야 합니다(All or Nothing).
2.  **Consistency(일관성)** : 트랜잭션 수행 전후에 데이터베이스는 일관된 상태(제약 조건 만족 등)를 유지해야 합니다.
3.  **Isolation(격리성)** : 동시에 실행되는 트랜잭션들은 서로의 연산에 끼어들거나 영향을 주어서는 안 됩니다.
4.  **Durability(지속성)** : 성공적으로 완료(Commit)된 트랜잭션의 결과는 시스템 장애가 발생하더라도 영구적으로 보존되어야 합니다.

## 데이터베이스에서 JOIN의 개념과 사용 사례를 설명해주세요.

### 테이블 결합
**JOIN**은 두 개 이상의 테이블을 연결하여 데이터를 검색하는 방법입니다. 관계형 데이터베이스는 정규화를 통해 데이터를 여러 테이블에 분산 저장하므로, 이를 다시 조합하여 유의미한 정보를 만들기 위해 사용합니다.



* **Inner Join** : 두 테이블에 모두 존재하는 교집합 데이터만 조회 
* **Left/Right Outer Join** : 기준 테이블의 모든 데이터와 매칭되는 반대쪽 테이블의 데이터를 조회

## 외래 키(Foreign Key)와 참조 무결성(Referential Integrity)에 대해 설명해주세요.

### 관계의 유효성 보장
**외래 키(Foreign Key)** 는 다른 테이블의 기본 키(Primary Key)를 참조하는 컬럼입니다.

**참조 무결성(Referential Integrity)** 은 외래 키를 통해 맺어진 관계가 항상 유효하도록 보장하는 규칙입니다.
* 자식 테이블에 존재하는 외래 키 값은 반드시 부모 테이블에 존재해야 합니다.
* 부모 테이블의 데이터가 삭제되거나 수정될 때, 이를 참조하는 자식 데이터가 있다면 삭제를 막거나(`RESTRICT`), 같이 삭제하거나(`CASCADE`), NULL로 변경(`SET NULL`)하여 무결성을 유지합니다.

## 데이터베이스에서 발생할 수 있는 데드락(Deadlock)을 방지하는 방법을 설명해주세요.

### 교착 상태 해결 방안
**데드락(Deadlock)** 은 두 개 이상의 트랜잭션이 서로가 가진 자원의 잠금(Lock)이 풀리기를 무한히 기다리는 상태입니다.

1.  **트랜잭션 순서 통일** : 모든 트랜잭션이 테이블 A -> 테이블 B 순서로 접근하도록 로직을 일관성 있게 짭니다.
2.  **트랜잭션 범위 최소화** : 트랜잭션을 최대한 짧게 유지하여 잠금 유지 시간을 줄입니다.
3.  **타임아웃 설정** : 일정 시간 동안 잠금을 획득하지 못하면 트랜잭션을 강제 종료(Rollback)하도록 설정합니다.

## 데이터베이스 샤딩(Sharding)이란 무엇인가요?

### 수평적 확장의 핵심
**샤딩(Sharding)** 은 대용량 데이터를 처리하기 위해 하나의 데이터베이스에 저장된 데이터를 여러 개의 물리적 데이터베이스(서버)에 **분산 저장(Horizontal Partitioning)** 하는 기술입니다.



* **Shard Key** : 데이터를 어떤 서버에 저장할지 결정하는 기준 키입니다. 이를 잘 설계해야 데이터가 한쪽으로 쏠리는 현상(Data Skew)을 막을 수 있습니다.
* **장점** : 트래픽과 데이터 용량을 여러 서버로 분산시켜 무한에 가까운 확장성을 가질 수 있습니다.
* **단점** : `JOIN` 연산이 매우 어렵고, 트랜잭션 관리가 복잡해집니다.

## 데이터베이스에서 파티셔닝(Partitioning)을 적용하는 이유를 설명하고, 수평/수직 파티셔닝의 차이점을 설명해주세요.

### 테이블 분할 전략
파티셔닝은 논리적인 하나의 테이블을 작은 단위로 쪼개어 관리하는 기법입니다. 주로 쿼리 성능 향상과 관리 용이성을 위해 사용합니다.

1.  **수평 파티셔닝(Horizontal Partitioning)** : 행(Row) 단위로 자릅니다.
    * 예 : 날짜별로 2023년 데이터, 2024년 데이터로 분리. 샤딩도 수평 파티셔닝의 일종(서버 간 분산)입니다.
2.  **수직 파티셔닝(Vertical Partitioning)** : 열(Column) 단위로 자릅니다.
    * 예 : 회원 테이블에서 자주 조회되는 '아이디/이름'과 자주 조회되지 않는 무거운 '프로필 이미지/소개글'을 별도 테이블로 분리하여 I/O 효율을 높입니다.