# 251221 TIL

## 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요

### 트랜잭션(Transaction)
- 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위. 작업이 모두 성공하거나 모두 실패(All or Nothing)해야 함

### ACID 원칙

- Atomicity(원자성) : 트랜잭션 내의 모든 명령은 완벽히 수행되거나, 아예 수행되지 않아야 함

- Consistency(일관성) : 트랜잭션 수행 전후에 데이터베이스는 언제나 일관된 상태(제약조건 만족 등)를 유지해야 함

- Isolation(격리성) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 연산에 영향을 주면 안 됨

- Durability(지속성) : 성공적으로 완료된 트랜잭션의 결과는 시스템 고장이 발생하더라도 영구적으로 반영되어야 함

## ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?
### WAL(Write-Ahead Logging)
- DBMS는 WAL(Write-Ahead Logging) 방식을 통해 지속성을 보장. 데이터를 실제 디스크의 데이터 파일에 기록하기 전에, 로그 파일(Redo Log 등)에 변경 사항을 먼저 기록. 이 로그 기록이 디스크에 안전하게 저장(fsync)되었다면 트랜잭션이 커밋된 것으로 간주. 시스템이 셧다운되더라도 재시작 시 이 로그를 읽어 데이터를 복구(Replay)함으로써 지속성을 보장

## 읽기에는 트랜잭션을 걸지 않아도 될까요?
- 걸어주는 것이 권장됨
    1. 데이터 일관성 : 조회 도중 다른 트랜잭션이 데이터를 수정하더라도, 트랜잭션 격리 수준(예 : Repeatable Read)에 따라 처음 조회를 시작한 시점의 일관된 데이터를 볼 수 있음

    2. 성능 최적화 : Spring 프레임워크의 경우 @Transactional(readOnly = true)를 설정하면, Hibernate가 스냅샷을 만들지 않거나 Dirty Checking을 수행하지 않는 등 성능 최적화를 수행

## 트랜잭션 격리 레벨에 대해 설명해 주세요
### 4단계 격리 수준
- 트랜잭션 간의 간섭을 어느 정도 허용할지 정의

1. `Read Uncommitted` : 아직 커밋되지 않은 데이터도 다른 트랜잭션이 읽을 수 있음(Dirty Read 발생 가능)
2. `Read Committed` : 커밋된 데이터만 읽을 수 있음(Non-Repeatable Read 발생 가능)
3. `Repeatable Read` : 트랜잭션이 시작된 시점의 데이터를 계속 읽을 수 있음(Phantom Read 발생 가능, MySQL InnoDB의 기본값)
4. `Serializable` : 가장 엄격한 수준으로, 트랜잭션을 순차적으로 처리. 동시성이 가장 낮음

## 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
- 모든 DBMS가 4가지를 완벽하게 구현하지는 않습니다(예 : Oracle은 Read Uncommitted를 지원하지 않음). 이유는 성능과 동시성(Concurrency) 사이의 트레이드오프 때문입니다. 높은 격리 수준(Serializable)은 데이터 정확성은 높지만 락(Lock)을 많이 사용하여 동시 처리 성능이 떨어집니다. 반면 낮은 수준은 성능은 좋지만 데이터 정합성이 깨질 위험이 큽니다. DBMS 벤더들은 자신들의 아키텍처(MVCC 등)에 맞춰 가장 효율적이라고 판단되는 격리 수준을 중심으로 구현 및 최적화합니다.

## 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요
- Undo Log(언두 로그) : **롤백(Rollback)과 격리성(MVCC)**을 위한 영역. 트랜잭션이 데이터를 수정하기 **전의 값(Old Value)**을 저장. 트랜잭션이 실패하면 이 값을 이용해 데이터를 원상 복구하며, 다른 트랜잭션이 조회할 때 커밋 전의 과거 데이터를 보여주는 용도로 사용
-  Redo Log(리두 로그) : 지속성(Durability)과 재해 복구를 위한 영역입. 트랜잭션이 커밋된 후 변경된 데이터(New Value)를 디스크에 반영하기 전에 기록하는 로그. 시스템이 비정상 종료되더라도 리두 로그에 남은 기록을 다시 실행(Replay)하여 데이터를 복구