# 251226 TIL

## WebSocket의 기본 개념과 HTTP와의 차이점은 무엇인가요?

### WebSocket 개념 및 HTTP 비교
**WebSocket**은 하나의 TCP 연결을 통해 클라이언트와 서버 간에 **전이중(Full-Duplex)** 통신을 가능하게 하는 프로토콜

* **HTTP** : 기본적으로 **단방향(Unidirectional)**이며 **비연결성(Stateless)**. 클라이언트가 요청을 보내야만 서버가 응답할 수 있음. 매 요청마다 헤더(Header) 정보가 포함되어 오버헤드가 큼.
* **WebSocket** : 연결되면 클라이언트와 서버가 서로 자유롭게 데이터를 주고받을 수 있음. 최초 핸드쉐이크 이후에는 헤더가 거의 없어 **오버헤드가 매우 적음**.

| 구분 | HTTP | WebSocket |
| :--- | :--- | :--- |
| **통신 방향** | 단방향<br>(Client -> Server) | 양방향 |
| **연결 지속성** | 비연결성<br>(요청/응답 후 종료) | 연결 유지 |
| **상태** | Stateless | Stateful |
| **실시간성** | 낮음<br>(Polling 필요) | 높음 |

## WebSocket 연결의 Handshake 과정은 어떻게 진행되나요?

### HTTP Upgrade 매커니즘
WebSocket 연결은 **HTTP 프로토콜을 통해 시작**. 이를 핸드쉐이크(Handshake)라고 함

1.  **클라이언트 요청** : HTTP `GET` 요청을 보내면서 `Upgrade : websocket`, `Connection : Upgrade` 헤더를 포함. 또한 `Sec-WebSocket-Key`라는 무작위 키를 함께 보냄.
2.  **서버 응답** : 서버가 WebSocket을 지원한다면 `101 Switching Protocols` 상태 코드로 응답. 이때 `Sec-WebSocket-Key`를 바탕으로 생성한 `Sec-WebSocket-Accept` 값을 헤더에 담아 보냄
3.  **연결 수립** : 이 과정이 완료되면 HTTP 연결은 WebSocket 프로토콜(TCP)로 전환되어 양방향 통신이 시작

## WebSocket의 메시지 프레이밍(message framing) 메커니즘에 대해 설명해주세요.

### 데이터 프레임 구조
WebSocket은 데이터를 **프레임(Frame)** 단위로 쪼개서 전송. 각 프레임은 다음과 같은 비트와 필드로 구성

* **FIN (1 bit)** : 해당 프레임이 메시지의 마지막임을 나타냄(메시지가 여러 프레임으로 나뉠 경우 **마지막 프레임만 1**)
* **Opcode (4 bits)** : 페이로드 데이터의 해석 방식을 정의
    * `0x1` : 텍스트 데이터
    * `0x2` : 이진(Binary) 데이터
    * `0x8` : 연결 종료
    * `0x9` : Ping
    * `0xA` : Pong
* **Mask (1 bit)** : 클라이언트에서 서버로 보내는 데이터는 반드시 마스킹(Masking)되어야 함을 나타냄(보안 및 캐시 오염 방지)
* **Payload length** : 데이터의 길이.
* **Payload data** : 실제 전송되는 데이터

## Long Polling과 WebSocket의 차이점은 무엇인가요?

### 통신 방식 비교
* **Long Polling** : HTTP에서 사용. 클라이언트가 요청을 보내면, 서버는 데이터가 생길 때까지 응답을 보류(Hold). 데이터가 생겨 응답을 보내면 연결이 끊기고, 클라이언트는 즉시 다시 요청을 보냄. 헤더 오버헤드가 계속 발생하며 서버 리소스 소모가 큼
* **WebSocket** : 한 번의 연결로 계속 데이터를 주고받음. 연결을 맺고 끊는 비용이 없으며 헤더 오버헤드가 최소화됨.

## WebSocket 통신에서 보안을 강화하기 위한 주요 고려 사항은 무엇인가요?

### 보안 모범 사례
1.  **WSS(WebSocket Secure) 사용** : HTTPS와 마찬가지로 TLS/SSL을 적용한 `wss://` 프로토콜을 사용하여 데이터를 암호화해야함
2.  **Origin 검증** : 핸드쉐이크 과정에서 브라우저가 전송하는 `Origin` 헤더를 서버에서 반드시 확인하여, 허용된 도메인에서의 요청인지 검증해야함(CSWSH 공격 방지)
3.  **입력값 검증** : WebSocket을 통해 전달되는 데이터도 SQL Injection이나 XSS 공격의 대상이 될 수 있으므로 철저히 검증해야함
4.  **Rate Limiting** : DoS 공격을 방지하기 위해 클라이언트당 메시지 전송 빈도나 연결 개수를 제한해야함

## WebSocket 연결이 끊어졌을 때 재연결(reconnect) 로직은 어떻게 구현하나요?

### 지수 백오프(Exponential Backoff)
네트워크 불안정으로 연결이 끊어지면 클라이언트는 `onclose` 또는 `onerror` 이벤트를 감지하여 재연결을 시도해야함. 이때 즉시 재연결하는 대신 **지수 백오프** 전략을 사용하는 것이 좋음

1.  연결 종료 감지
2.  초기 대기 시간(예 : 1초) 설정
3.  재연결 시도. 실패 시 대기 시간을 2배로 증가(1초 -> 2초 -> 4초...)
4.  최대 대기 시간(예 : 30초)을 설정하여 무한정 늘어나지 않게 함
5.  연결 성공 시 대기 시간 초기화

## WebSocket 프로토콜에서 사용되는 상태 코드와 그 의미에 대해 설명

### 주요 Close Code
WebSocket 연결이 종료될 때(Close Frame), 종료 원인을 나타내는 상태 코드를 교환

| 코드 | 의미 | 설명 |
| :--- | :--- | :--- |
| **1000** | Normal Closure | 정상적인 종료 |
| **1001** | Going Away | 서버 다운이나 브라우저 이동 등으로 떠남 |
| **1002** | Protocol Error | 프로토콜 오류 발생 |
| **1003** | Unsupported Data | 허용되지 않은 데이터 유형 수신<br>(예 : 텍스트 전용에 바이너리 전송) |
| **1006** | Abnormal Closure | 비정상 종료<br>(TCP 연결이 끊김 등, 애플리케이션 레벨에서는 전송되지 않음) |
| **1011** | Internal Error | 서버 내부 오류로 요청 처리 불가 |

## Ping/Pong 메커니즘이 WebSocket 연결 유지에 어떻게 활용되는지 설명해주세요.

### Heartbeat (심박) 체크
TCP 연결은 물리적인 단절(케이블 뽑힘 등)이나 중간의 로드밸런서/방화벽의 유휴 시간(Idle Timeout)으로 인해 끊길 수 있음. 이를 감지하고 유지하기 위해 Ping/Pong을 사용

* **동작** : 서버(또는 클라이언트)가 주기적으로 `Ping` 프레임을 보냄. 상대방은 이를 받으면 즉시 `Pong` 프레임으로 응답해야함
* **활용** : 일정 시간 동안 `Pong` 응답이 없으면 연결이 죽은(Zombie Connection) 것으로 간주하고 소켓을 강제로 닫고 재연결 로직을 수행

## WebSocket 확장(extensions) 기능은 무엇이며, 어떤 용도로 사용되나요?

### 프로토콜 기능 확장
WebSocket 프로토콜은 핸드쉐이크 과정에서 `Sec-WebSocket-Extensions` 헤더를 통해 기능을 추가할 수 있도록 설계
* **permessage-deflate** : 가장 대표적인 확장 기능으로, 메시지를 압축하여 전송. 대역폭을 절약할 수 있지만 CPU 사용량이 늘어남
* **용도** : 데이터 압축, 다중화(Multiplexing) 등의 기능을 표준 프로토콜 변경 없이 추가할 때 사용

## WebSocket 구현 시 발생할 수 있는 Cross-Origin 문제와 그 해결 방법은 무엇인가요?

### Cross-Site WebSocket Hijacking (CSWSH)
WebSocket은 리소스 요청이 아니므로 브라우저의 SOP(Same-Origin Policy)를 엄격하게 따르지 않음. 따라서 악의적인 사이트에서 사용자의 세션을 이용해 내 서버로 WebSocket 연결을 시도할 수 있음.

* **해결 방법** :
    1.  서버 핸드쉐이크 로직에서 **`Origin` 헤더를 반드시 확인**
    2.  허용된 도메인 목록(Allowlist)에 있는 경우에만 연결을 승인하고, 그렇지 않으면 `403 Forbidden`을 반환
    3.  연결 수립 전 쿠키 대신 CSRF 토큰과 유사한 티켓 기반 인증을 사용할 수도 있음

## 단일 서버와 클러스터 환경에서의 WebSocket 구현 차이점은 무엇인가요?

### 세션 공유와 메시지 브로커
* **단일 서버** : 모든 클라이언트의 WebSocket 세션 객체를 해당 서버의 메모리에서 관리하면 되므로 구현이 간단
* **클러스터 환경** :
    1.  **세션 불일치** : 클라이언트 A는 서버 1에, 클라이언트 B는 서버 2에 연결될 수 있습니다. 서버 1에서 B에게 메시지를 보내려 해도 세션이 없음
    2.  **메시지 브로커(Pub/Sub)** : `Redis Pub/Sub`이나 `Kafka` 같은 브로커가 필요. 서버 1이 메시지를 브로커에 발행(Publish)하면, 브로커가 이를 구독(Subscribe) 중인 모든 서버에 **전파**하여 서버 2가 B에게 메시지를 전달하도록 해야 합니다.
    3.  **Sticky Session** : 핸드쉐이크 과정이 끊기지 않도록 로드밸런서에서 동일한 클라이언트의 요청은 동일한 서버로 보내도록 설정해야 할 수 있음

## WebSocket에서 텍스트와 이진 데이터 전송 방식의 장단점은 무엇인가요?

### 데이터 포맷 비교

| 구분 | 텍스트(Text) | 이진(Binary) |
| :--- | :--- | :--- |
| **포맷** | JSON, XML 등 문자열 | ArrayBuffer, Blob, Protobuf |
| **장점** | - 사람이 읽을 수 있어 디버깅이 쉬움 <br> - 웹 친화적 | -데이터 크기가 작음 <br> -파싱 속도가 빠름 <br> - 대역폭 절약 |
| **단점** | - 데이터 크기가 상대적으로 큼 <br> - 파싱 오버헤드 | - 디버깅이 어려움<br>- 별도의 디코딩 로직 필요 |

## 실시간 채팅이나 게임 애플리케이션에서 WebSocket이 선호되는 이유는 무엇인가요?

### 저지연과 효율성
1.  **Low Latency (저지연)** : HTTP와 달리 매 요청마다 연결을 맺지 않으므로 딜레이가 최소화되어 실시간 상호작용에 필수적
2.  **Full Duplex (전이중)** : 서버가 클라이언트에게 이벤트를 능동적으로 푸시할 수 있음(예 : 상대방이 채팅 입력 중, 게임 내 적의 이동)
3.  **오버헤드 감소** : HTTP 헤더(쿠키 등 포함 수백 바이트)를 계속 보내지 않고, 최소 2바이트의 프레임 헤더만으로 통신하므로 트래픽 비용이 절감