# 251211 TIL

## 오류 해결
| 분류 | 오류 증상 (Error) | 원인 (Cause) | 해결 방법 (Solution) |
| :--- | :--- | :--- | :--- |
| **MSA 통신** | `FeignException: [403] Forbidden` <br> (Comment -> User 호출 실패) | User Service의 Spring Security 설정이 내부 API 경로(`/internal/**`) 접근을 차단함. | `SecurityConfig`에서 `.requestMatchers("/internal/**").permitAll()` 설정 추가하여 내부 통신 허용. |
| **Gateway** | `IllegalArgumentException: Unable to find GatewayFilterFactory` | 커스텀 필터가 `GatewayFilter` 인터페이스만 구현하여 YAML 설정에서 팩토리로 인식 못함. | `AbstractGatewayFilterFactory`를 상속받도록 클래스 구조 변경 (`apply` 메서드 구현). |
| **Gateway** | `404 Not Found` (로그인 시도 시) | 1. 라우트 경로 설정 시 맨 앞 슬래시(`/`) 누락 (`Path=api/auth/**`). <br> 2. `application.yml` 들여쓰기 오류 (`routes`가 `discovery` 하위에 종속됨). | 1. `/api/auth/**`로 슬래시 추가. <br> 2. `routes` 설정을 `discovery` 밖으로 꺼내 `gateway` 바로 하위로 이동. |
| **Gateway Config** | `Deprecated configuration property` 경고 | Spring Cloud Gateway 버전 업데이트로 설정 키 구조 변경 (`server.webflux` 계층 추가됨). | `application.yml` 구조를 `spring.cloud.gateway.server.webflux.routes` 형태로 최신화. |

### `IllegalArgumentException: Unable to find GatewayFilterFactory`

1. 원인
- application.yml 파일에서 filters: 속성에 필터 이름을 적으면, Spring Gateway는 Factory 찾음
- 작성 코드는 단순한 GatewayFilter 구현체(단일 객체)였기 때문에, 스프링이 찾는 Factory가 없어 Error

2. 해결
- `AbstractGatewayFilterFactory`를 상속
```Java
package com.gateway.filter;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;

@Slf4j
@Component
// ✨ 핵심 1: AbstractGatewayFilterFactory 상속 필수!
public class JwtAuthenticationFilter extends AbstractGatewayFilterFactory<JwtAuthenticationFilter.Config> {

    @Value("${jwt.secret}")
    private String jwtSecret;

    public JwtAuthenticationFilter() {
        super(Config.class);
    }

    // ✨ 핵심 2: apply 메서드 안에 필터 로직 작성
    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();

            // 1. 헤더 확인
            String authorizationHeader = request.getHeaders().getFirst("Authorization");
            if (!StringUtils.hasText(authorizationHeader) || !authorizationHeader.startsWith("Bearer ")) {
                log.warn("토큰이 없거나 형식이 잘못됨");
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete();
            }

            // 2. 토큰 검증
            String token = authorizationHeader.substring(7);
            try {
                SecretKey key = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
                Claims claims = Jwts.parserBuilder()
                        .setSigningKey(key)
                        .build()
                        .parseClaimsJws(token)
                        .getBody();

                // 3. 헤더에 정보 추가 (X-User-Id 등)
                ServerHttpRequest mutatedRequest = request.mutate()
                        .header("X-User-Id", claims.getSubject())
                        .header("X-User-Email", claims.get("email", String.class))
                        .header("X-User-Role", claims.get("role", String.class))
                        .build();

                return chain.filter(exchange.mutate().request(mutatedRequest).build());

            } catch (Exception e) {
                log.error("토큰 검증 실패: {}", e.getMessage());
                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
                return exchange.getResponse().setComplete();
            }
        };
    }

    // 설정 클래스 (비어 있어도 됨)
    public static class Config {}
}
```

### `Deprecated configuration property`
1. 원인
- Spring Cloud Gateway 최신 버전(4.x 이상)부터는 설정 구조가 계층형으로 변경
    - 구 : `spring.cloud.gateway.routes`
    - 신 : `spring.cloud.gateway.server.webflux.routes`

2. 해결
```yml
server:
  port: 19091

spring:
  application:
    name: gateway
  main:
    web-application-type: reactive
  cloud:
    gateway:
      server:
        webflux:
          
          # 1. Discovery 설정
          discovery:
            locator:
              enabled: false 
  
          # 2. Routes 설정
          routes:
            - id: user-service-public
              uri: lb://USER-SERVICE
              predicates:
                - Path=/api/auth/** 

            - id: user-service-protected
              uri: lb://USER-SERVICE
              predicates:
                - Path=/user/**, /blocks/**
              filters:
                - JwtAuthenticationFilter 

            - id: comment-service
              uri: lb://COMMENT-SERVICE
              predicates:
                - Path=/comments/**, /feeds/*/comments/**
              filters:
                - JwtAuthenticationFilter

            - id: notification-service
              uri: lb://NOTIFICATION-SERVICE
              predicates:
                - Path=/notifications/** 
              filters:
                - JwtAuthenticationFilter

```

