# 251220 TIL

## Key(기본키, 후보키, 슈퍼키 등등...)에 대해 설명해 주세요
### Key의 종류와 개념
- 관계형 데이터베이스에서 Key는 튜플(행)을 식별하거나 테이블 간의 관계를 맺는 데 사용되는 중요한 제약조건
- 슈퍼키(Super Key) : 테이블 내의 튜플을 유일하게 식별할 수 있는 속성들의 집합. 유일성은 만족하지만, 최소성은 만족하지 않아도 됩
- 후보키(Candidate Key) : 튜플을 유일하게 식별할 수 있는 속성들의 부분집합. 슈퍼키 중에서 유일성과 최소성을 모두 만족하는 키
- 기본키(Primary Key) : 후보키 중에서 엔티티를 대표하기 위해 선택된 키. NULL 값을 가질 수 없으며(Not Null), 중복된 값을 가질 수 없음(Unique)
- 대체키(Alternate Key) : 후보키 중에서 기본키로 선택받지 못한 나머지 키
- 외래키(Foreign Key) : 다른 테이블의 기본키를 참조하여 테이블 간의 관계를 연결하는 키. 무결성을 유지하는 데 사용

## 기본키는 수정이 가능한가요?
### 기술적 가능성과 권장 사항
- 기술적으로는 수정이 가능. 대부분의 DBMS는 기본키 업데이트를 허용. 하지만, 권장하지 않음
    1. 데이터 무결성 문제 : 해당 키를 참조하고 있는 다른 테이블의 외래키(FK) 데이터와의 연결이 끊어지거나, 연쇄적으로 수정(Cascade Update)해야 하는 비용이 발생
    2. 인덱스 오버헤드 : MySQL InnoDB와 같이 기본키가 클러스터드 인덱스(Clustered Index)로 구성된 경우, 기본키 값이 바뀌면 데이터의 물리적 저장 위치가 변경. 이는 페이지 분할(Page Split)과 인덱스 재구성을 유발하여 심각한 성능 저하를 일으킬 수 있음

## 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
### InnoDB의 숨겨진 키 생성
- MySQL의 기본 스토리지 엔진인 InnoDB는 데이터를 클러스터드 인덱스 형태로 저장하기 위해 반드시 기본키가 필요. 사용자가 명시적으로 기본키를 정의하지 않으면 다음과 같은 순서로 처리
    1. Unique Non-Null 컬럼 탐색 : 테이블에 UNIQUE하면서 NOT NULL인 컬럼이 있다면 이를 기본키로 대체하여 사용
    2. 히든 키 생성 : 위 조건에 맞는 컬럼이 없다면, InnoDB 내부적으로 **6바이트 크기의 숨겨진 컬럼(GEN_CLUST_INDEX / DB_ROW_ID)**을 자동으로 생성하여 이를 기본키로 사용. 이 ID는 사용자가 쿼리로 조회할 수 없음

## 외래키 값은 NULL이 들어올 수 있나요?
### 외래키의 Null 허용 여부
- 가능. 외래키 컬럼에 NOT NULL 제약조건을 명시적으로 걸지 않았다면 NULL 값을 저장할 수 있음
- 의미 : 외래키가 NULL이라는 것은 참조하는 부모 테이블의 데이터와 관계가 맺어지지 않음 혹은 옵션 관계임을 의미
    ex) 사원 테이블의 '부서ID'가 외래키일 때, 아직 부서 배치를 받지 않은 신입사원은 NULL일 수 있음

## 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
### 읽기(Read)와 쓰기(Write) 성능 차이
- 읽기 성능(SELECT) : UNIQUE 키워드가 붙으면 유니크 인덱스가 생성. 인덱스가 없는 컬럼(Full Table Scan)에 비해 훨씬 빠르며, 일반적인 B-Tree 인덱스와 비교해도 동등하거나 약간 더 빠름. DBMS는 찾는 값이 유일함을 보장받으므로, 첫 번째 일치하는 값을 찾는 순간 더 이상 탐색하지 않고 종료할 수 있기 때문
- 쓰기 성능(INSERT, UPDATE) : 성능이 떨어짐. 데이터를 삽입하거나 수정할 때마다, DBMS는 해당 값이 중복되는지 확인하는 과정(유일성 검사)을 거쳐야 함. 이 과정에서 읽기 잠금(Read Lock)이나 쓰기 잠금 등이 발생하여 오버헤드가 생김

## RDB와 NoSQL의 차이에 대해 설명해 주세요
### 구조와 확장성의 차이
- RDB(Relational Database) : 정해진 스키마(Schema)에 따라 데이터를 2차원 테이블 형태로 저장. 데이터 간의 관계를 중시하며 SQL을 사용. 수직적 확장(Scale-up)에 유리
- NoSQL(Not Only SQL) : 스키마가 없거나 유연하며, Key-Value, Document, Graph 등 다양한 데이터 모델을 가짐. 관계보다는 데이터 자체의 조회와 저장 속도에 집중. 수평적 확장(Scale-out)에 매우 유리

## NoSQL의 강점과, 약점이 무엇인가요?
### 강점

- 유연성 : 스키마가 고정되지 않아 데이터 구조 변경이 자유로움
- 확장성 : 샤딩(Sharding) 등을 통한 수평적 확장이 용이하여 대용량 트래픽 처리에 적합
- 성능 : 단순 검색 및 추가 작업(Write/Read)에 대해 매우 빠른 응답 속도를 제공

### 약점

- 데이터 일관성 : RDB의 ACID보다 완화된 BASE(Basically Available, Soft state, Eventual consistency) 모델을 따르므로, 실시간 데이터 일관성이 보장되지 않을 수 있음
- 쿼리 복잡성 : JOIN 연산이 없거나 비효율적이며, 복잡한 검색 쿼리를 작성하기 어려움
- 데이터 중복 : 조인을 피하기 위해 데이터를 중복 저장하는 경우가 많아 저장 공간을 더 차지할 수 있음

## RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요?
- ACID 트랜잭션 보장 : RDB는 강력한 데이터 무결성을 위해 트랜잭션 처리(Locking, Logging 등)에 많은 리소스를 사용
- 스키마 제약(Schema Enforcement) : 데이터를 쓸 때마다 스키마(데이터 타입, 길이, 제약조건)를 검사해야 함
- JOIN 연산 : 정규화된 데이터들을 조합해서 가져오기 위해 복잡한 JOIN 연산을 수행해야 하는데, 이는 데이터 양이 많아질수록 CPU와 메모리 비용이 급격히 증가
ㄴ
