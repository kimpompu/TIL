# 251217 TIL

## 트러블슈팅

| 문제 상황 / 질문 | 해결 및 배운 점 |
| :--- | :--- |
| **403 Forbidden** | **현상:** Comment → Feed 호출 시 토큰 없이 호출해서 `403`<br>**해결:** `FeignConfig`에 `RequestInterceptor`를 추가하여 `Authorization` 헤더 복사 로직 구현. |
| **Internal API 보안** | **질문:** "내부 호출용 API는 어떻게 보호해?"<br>**해결:** URL을 `/internal/`로 분리하고, **Gateway 라우팅에서 제외(화이트리스트)**하거나 `IP 필터링을 적용`하는 전략 학습. |

## FeignConfig 설정
- MSA 환경에서 FeignClient로 서비스 간 호출 시, **사용자의 인증 정보를 끊기지 않고 전달**하기 위해 `RequestInterceptor`를 설정

```java
package com.your.package.config;

import feign.RequestInterceptor;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

@Slf4j
@Configuration
public class FeignConfig {

    @Bean
    public RequestInterceptor requestInterceptor() {
        return requestTemplate -> {
            // 1. 현재 요청(Current Request)의 속성 가져오기
            ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();

            if (attributes != null) {
                HttpServletRequest request = attributes.getRequest();
                
                // 2. 현재 요청에 들어있는 헤더 값 꺼내기 (Gateway가 넣어준 값들)
                String authorizationHeader = request.getHeader("Authorization");
                String userId = request.getHeader("X-User-Id");
                String role = request.getHeader("X-User-Role");

                // 3. Feign 요청 템플릿에 그대로 다시 주입 (릴레이)
                
                // (1) JWT 토큰 전달
                if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
                    requestTemplate.header("Authorization", authorizationHeader);
                }

                // (2) User ID 전달 
                if (userId != null) {
                    requestTemplate.header("X-User-Id", userId);
                }

                // (3) Role 전달
                if (role != null) {
                    requestTemplate.header("X-User-Role", role);
                }
                
                log.debug("Feign Interceptor: Headers Propagated (User: {})", userId);
            }
        };
    }
}
```

## API Gateway Whitelist 설정
```Java
package com.gateway.filter;

import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.net.InetSocketAddress;
import java.util.List;

@Slf4j
@Component
public class IPCheckFilter extends AbstractGatewayFilterFactory<IPCheckFilter.Config> {

    public IPCheckFilter() {
        super(Config.class);
    }

    public static class Config {

    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            ServerHttpResponse response = exchange.getResponse();

            // 1. 접속한 클라이언트의 IP 가져오기
            InetSocketAddress remoteAddress = request.getRemoteAddress();
            String clientIp = "";
            if (remoteAddress != null) {
                clientIp = remoteAddress.getAddress().getHostAddress();
            }

            log.info("Client IP 접속 시도: {}", clientIp);

            // 2. 화이트리스트 (허용할 IP 목록)
            List<String> whiteList = List.of(
                    "127.0.0.1",      // 로컬호스트
                    "0:0:0:0:0:0:0:1" // 로컬호스트 (IPv6)
            );

            // 3. 검사 로직
            if (!whiteList.contains(clientIp)) {
                log.warn("차단된 IP 접근 시도: {}", clientIp);
                response.setStatusCode(HttpStatus.FORBIDDEN); // 403 Forbidden
                return response.setComplete(); // 요청 종료 (뒤로 안 넘김)
            }

            // 4. 통과
            return chain.filter(exchange);
        };
    }
}
```

```yml
spring:
  cloud:
    gateway:
      routes:
        # 일반 사용자용 (누구나 접속)
        - id: xxx-service-public
          uri: lb://xxx-SERVICE
          predicates:
            - Path=/api/xxx/**

        # 관리자/내부용 (IP 필터 적용!)
        - id: xxx-service-internal
          uri: lb://xxx-SERVICE
          predicates:
            - Path=/internal/xxx/** # 내부 API 경로
          filters:
            - name: IPCheckFilter      # 필터적용
```