# 260209 TIL

## 유형 정리

| 순위 | 유형 | 핵심 로직 | 추천 자료구조/메소드 |
| :--- | :--- | :--- | :--- |
| 1 | **정렬 (Sorting)** | 여러 조건으로 정렬하기 (나이순, 이름순 등) | `Arrays.sort()`, `Comparator` |
| 2 | **완전 탐색 (Brute Force)** | 모든 경우의 수 다 해보기 | `for` 반복문, 재귀(Recursion) |
| 3 | **그리디 (Greedy)** | 현재 상황에서 가장 최선의 선택 하기 | `Math.max()`, `Math.min()` |
| 4 | **BFS / DFS** | 그래프/미로 탐색 (최단거리, 연결 요소) | `Queue`, `Stack`, 재귀 |
| 5 | **자료구조 (Stack/Queue)** | 괄호 짝 맞추기, 요세푸스 문제 등 | `Stack`, `Deque`, `Queue` |
| 6 | **다이나믹 프로그래밍 (DP)** | 작은 문제의 답을 저장해 큰 문제 해결 | `dp[]` 배열 (Memoization) |
| 7 | **문자열 (String)** | 패턴 찾기, 문자열 변환 및 파싱 | `StringBuilder`, `replace()` |
| 8 | **이분 탐색 (Binary Search)** | 정렬된 데이터에서 원하는 값 빠르게 찾기 | `Arrays.binarySearch()` |
| 9 | **집합과 맵 (Hash)** | 중복 제거, Key-Value 쌍 데이터 관리 | `HashSet`, `HashMap` |
| 10 | **누적 합 (Prefix Sum)** | 구간의 합을 빠르게 구하기 | `sum[i] = sum[i-1] + arr[i]` |

## 그리디 유형
| 순위 | 유형 | 풀이 |
| :--- | :--- | :--- | 
| 1 | **동전 교환** | 가장 큰 단위의 동전부터 최대한 많이 사용하기 |
| 2 | **회의실 배정** | **끝나는 시간**이 가장 빠른 순서대로 정렬하기 | 
| 3 | **체육복/구명보트** | 가장 무거운 사람과 가벼운 사람을 짝짓기(정렬 활용) | 
| 4 | **문자열 합치기** | 가장 작은 크기의 파일/카드 두 개를 먼저 합치기 | 
| 5 | **최소 숫자 만들기** | 수식에서 `-` 뒤의 괄호를 크게 묶어 최대한 빼기 | 
| 6 | **주유소 거리** | 다음 주유소까지 갈 때, 지금까지 본 가장 싼 곳에서 주유 | 
| 7 | **대기 시간 최소화** | 소요 시간이 짧은 사람을 앞에 세워 총 대기시간 줄이기 | 
| 8 | **보석 도둑** | 가치가 높은 보석을 담을 수 있는 가장 작은 가방에 넣기 | 
| 9 | **센서/기지국** | 간격이 가장 넓은 부분을 제외하고 연결하기 | 
| 10 | **문자열 뒤집기** | 연속된 같은 문자를 하나로 취급하여 적은 쪽 뒤집기 |

### 활동 선택
```Java
// 종료 시간 기준 정렬, 종료 시간이 같다면 시작 시간 기준 정렬
Arrays.sort(meetings, (o1, o2) -> {
    if(o1[1] == o2[1]) return o1[0] - o2[0];
    return o1[1] - o2[1];
});
```

### 최소값
```Java
String[] minusSplit = input.split("-");
for (String s : minusSplit) {
    String[] plusSplit = s.split("\\+");
    // 각 묶음의 합을 구한 뒤 첫 번째 묶음만 더하고 나머지는 뺌
}
```

### 주유소
```Java
long minPrice = price[0];
for (int i = 0; i < n - 1; i++) {
    if (price[i] < minPrice) minPrice = price[i];
    totalCost += (minPrice * distance[i]);
}
```