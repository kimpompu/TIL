# 251107 TIL

## IoC (Inversion of Control, 제어의 역전)
- `정의` : 객체의 생성 및 생명주기 관리, 객체간 의존 관계 설정을 개발자가 아닌 프레임워크가 전담
- `Spring Container`

## DI (의존성 주입)
- 정의 : IoC 달성 방법 중 하나, 객체를 개발자가 아닌 외부에서 주입하는 방식
- 장점 : 클래스 간 결합도를 낮추고 유연성을 높임

```Java
    // 의존성 (사용할 객체)
    public interface MessageService {
        void send();
    }

    // 기존 방식 (개발자가 직접 생성 -> 강한 결합)
    public class TraditionalController {
        private MessageService service = new EmailService(); // << 강한 결합
        // ...
    }

    // DI 방식 (Spring이 주입 -> 낮은 결합)
    @Controller
    public class SpringController {
        
        // 1. 필드 주입 (Field Injection)
        @Autowired 
        private MessageService service; 

        2. 생성자 주입 (Constructor Injection) - 가장 권장되는 방식
        private final MessageService service;
        
        public SpringController(MessageService service) { // @Autowired 생략 가능
            this.service = service;
        }
        
    }
```

## POJO (Plain Old Java Object)

- `정의` : 특정 프레임워크나 환경(IDE)에 종속되지 않고 순수하게 비즈니스 로직에만 집중하여 작성된 자바 객체
    - Spring의 POJO : Spring의 IoC/DI 컨테이너를 사용하더라도, 클래스 자체는 특정 인터페이스를 구현하거나 특정 클래스를 상속받을 필요가 없음

### 특징

- 순수 자바 환경 : 특정 라이브러리/프레임워크의 클래스나 인터페이스를 상속/구현하지 않음
- 단위 테스트 용이 : 프레임워크 외부에서 순수하게 테스트가 가능
- 높은 가독성/재사용성 : 비즈니스 로직만 담고 있어 이해하기 쉽고, 다른 환경으로 마이그레이션이 용이

```Java
// 이 클래스는 Spring 클래스를 상속받지도, 특정 인터페이스를 구현하지도 않는 POJO다.
public class UserService { 
    
    public User findUser(Long id) {
        // 순수한 비즈니스 로직
        return userRepository.findById(id); 
    }
}
// Spring은 @Service 어노테이션만으로 이 POJO 객체를 관리(Bean)할 수 있다.
```

## AOP (Aspect-Oriented Programming, 관점 지향 프로그래밍)
- `정의` : 핵심 비즈니스 로직이 아닌 여러 모듈에서 공통적으로 사용되는 부가 기능(횡단 관심사, Cross-cutting Concern)을 분리하여 모듈화하는 프로그래밍 패러다임
    - 횡단 관심사 : 로깅(Logging), 트랜잭션 관리(Transaction), 보안(Security), 성능 측정(Profiling) 등

## PSA (Portable Service Abstraction, 서비스 추상화)
- `정의` : 특정 기술(데이터베이스 접근 기술, 트랜잭션 기술 등)이 바뀌더라도 일관된 서비스 인터페이스를 유지하도록 하는 설계 원칙
           Spring이 제공하는 인터페이스를 통해 개발자는 구현 기술(Concrete Technology)에 직접 의존하지 않고, 추상화된 서비스에만 집중

```Java
import org.springframework.transaction.annotation.Transactional;

@Service
public class OrderService {
    
    // 개발자는 이 어노테이션만 사용
    @Transactional 
    public void createOrder(Order order) {
        // 비즈니스 로직
    }
    
    // 1. JDBC를 쓰면 Spring이 내부적으로 JDBC 트랜잭션을 사용한다.
    // 2. JPA/Hibernate를 쓰면 Spring이 내부적으로 JPA 트랜잭션을 사용한다.
    // -> 개발자 코드는 기술 변경에 상관없이 동일한 @Transactional 어노테이션을 유지한다.
}
```