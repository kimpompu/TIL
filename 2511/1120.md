# 251120 TIL

## Redis Cluster의 기본 아키텍처와 데이터 샤딩(sharding) 방식에 대해 설명해주세요.

### Redis Cluster
- 대규모 데이터셋과 높은 처리량을 처리하기 위해 데이터를 여러 Redis 인스턴스에 **자동으로 분할(Sharding)**하고, 고가용성을 제공하는 분산형 시스템

| 개념 | 설명 |
| :--- | :--- |
| **아키텍처** | 마스터-슬레이브(레플리카) 노드 그룹으로 구성된 분산형 시스템 |
| **샤딩 방식** | 해시 슬롯 기반 (16384개 슬롯) |
| **특징** | 자동 분할(Sharding), 장애 감지 및 페일오버, 노드 추가/제거 용이 |

- 기본 아키텍처 (Architecture) 노드 구성
    - 노드 구성 : 클러스터는 여러 개의 마스터 노드와 각 마스터의 슬레이브(레플리카) 노드로 구성

    - 장애 감지 및 페일오버 : 모든 노드는 서로 Gossip 프로토콜을 통해 통신하며, 장애를 감지. 마스터 노드에 장애가 발생하면, 해당 마스터의 슬레이브 노드 중 하나가 자동으로 **새로운 마스터로 승격(Failover)**되어 서비스를 지속

- 데이터 샤딩 방식 (Data Sharding) : 데이터를 쪼개어 저장하는 데 해시 슬롯(Hash Slot) 기반의 샤딩 방식


## Redis Sentinel의 역할은 무엇이며, 이를 통해 어떻게 고가용성을 보장할 수 있나요?

| 역할 | 기능 및 특징 |
| :--- | :--- |
| **모니터링** | 마스터와 슬레이브 노드의 상태를 지속적으로 확인 |
| **알림** | 장애 발생 시 시스템 관리자나 다른 애플리케이션에 알림 전송 |
| **자동 페일오버** | 마스터 장애 시 슬레이브를 마스터로 자동 승격 |
| **설정 공급** | 클라이언트에게 현재 마스터의 주소를 제공 |

## Redis의 캐시 만료(expiration) 정책 설정 방법과, 실제 운영 시 고려해야 할 점은 무엇인가요?

| 설정 방법 | 설명 |
| :--- | :--- |
| **`EXPIRE key seconds`** | 주어진 키에 초 단위의 TTL(Time-To-Live) 설정 |
| **`PEXPIRE key milliseconds`** | 주어진 키에 밀리초 단위의 TTL 설정 |
| **`EXPIREAT key timestamp`** | 주어진 유닉스 타임스탬프에 만료되도록 설정 |
| **`PERSIST key`** | TTL 제거(영구 저장) |

## Redis의 캐시 eviction 정책(LRU, LFU, TTL 등) 간의 차이점과 선택 기준에 대해 설명해주세요.

| 정책 (Policy) | 설명 (Description) | 선택 기준 (Selection Criteria) |
| :--- | :--- | :--- |
| **`noeviction`** | 메모리 제한 초과 시 쓰기 명령 거부 (기본값) | 데이터 유실이 절대적으로 허용되지 않을 때 |
| **`allkeys-lru`** | 전체 키 중 가장 오랫동안 사용되지 않은 키 제거 | 범용적인 캐싱, 최근 사용 데이터가 중요할 때 |
| **`volatile-lru`** | TTL이 설정된 키 중 가장 오랫동안 사용되지 않은 키 제거 | 만료 설정된 키 중에서만 캐시 교체 필요 시 |
| **`allkeys-lfu`** | 전체 키 중 사용 빈도가 가장 낮은 키 제거 | 사용 빈도가 접근 패턴의 지표일 때 |
| **`volatile-lfu`** | TTL이 설정된 키 중 사용 빈도가 가장 낮은 키 제거 | 만료 설정 키 중 빈도 기반 캐시 교체 필요 시 |
| **`allkeys-random`** | 전체 키 중 무작위로 키 제거 | 키 간 중요도 차이가 없을 때 |
| **`volatile-ttl`** | TTL이 설정된 키 중 만료 시간이 가장 가까운 키 제거 | 만료 시점 기반의 예측 가능한 제거가 필요할 때 |


## Redis의 트랜잭션 기능(MULTI, EXEC, WATCH 등)을 활용하여 동시성 문제를 어떻게 해결할 수 있는지 설명해주세요.

| 명령어 | 역할 |
| :--- | :--- |
| **`MULTI`** | 트랜잭션 시작 (이후 명령들을 큐에 저장) |
| **`EXEC`** | 큐에 저장된 모든 명령을 원자적으로 실행 |
| **`DISCARD`** | 트랜잭션 취소 |
| **`WATCH`** | 하나 이상의 키를 감시하여 낙관적 잠금(Optimistic Locking) 구현 |