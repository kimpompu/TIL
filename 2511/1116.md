# 251116 TIL


## Spring에서 메시징 시스템(Kafka, RabbitMQ 등)과의 연동 방법은 무엇인가요?
- `Spring AMQP(RabbitMQ)`와 `Spring Kafka`라는 전용 프로젝트를 통해 메시징 시스템과 연동

### 연동방법

1. 의존성 추가 및 설정

- `RabbitMQ`
    - pring-boot-starter-amqp 의존성 추가
    - application.yml에 spring.rabbitmq.host, port 등 브로커 주소 설정
- `Kafka`
    - spring-boot-starter-kafka 의존성 추가
    - application.yml에 spring.kafka.bootstrap-servers 설정

2. 메시지 발행 (Sending / Producing)

- `RabbitMQ`
    - RabbitTemplate 빈을 주입받아 convertAndSend(exchange, routingKey, message) 메서드로 메시지를 발행
- `Kafka`
    - KafkaTemplate 빈을 주입받아 send(topic, message) 메서드로 메시지를 발행

3. 메시지 구독 (Receiving / Consuming)

- `RabbitMQ`
    - `@RabbitListener(queues = "큐이름")` 어노테이션을 특정 메서드에 붙여 해당 큐를 구독(Listen)
- `Kafka`
    - `@KafkaListener(topics = "토픽이름", groupId = "그룹ID")` 어노테이션을 메서드에 붙여 해당 토픽을 구독

## Spring의 캐싱 추상화(Cache Abstraction)와 캐시 적용 방법에 대해 설명해주세요.

### 캐싱 추상화(Cache Abstraction)
- 개발자가 캐시 구현 기술(Redis, Ehcache, Caffeine 등)에 종속되지 않고, 일관된 어노테이션만으로 캐싱을 적용할 수 있게 해주는 기능
- 원리 : AOP를 기반으로 동작

### 적용 방법

1. `@EnableCaching`: 메인 애플리케이션 클래스나 설정 클래스에 붙여 캐싱 기능을 활성화
2. `@Cacheable` : 조회 메서드 실행 전에 캐시를 먼저 확인
3. 캐시에 데이터가 있으면 `Hit` 메서드를 실행하지 않고 캐시된 데이터를 즉시 반환
3-2. 캐시에 데이터가 없으면 `Miss` 메서드를 실행하고, 그 결과를 캐시에 저장한 뒤 반환
4. `@CachePut` 수정 메서드를 항상 실행하고, 그 결과를 캐시에 업데이트
    - 캐시 무효화를 방지하면서 데이터를 갱신
5. `@CacheEvict` 삭제 메서드 실행 후에 캐시에서 특정 항목 또는 전체 항목을 삭제

## Spring Boot에서 프로파일 관리와 환경별 설정 적용 방법은 무엇인가요?
- 개발(dev), 테스트(test), 운영(prod) 등 서로 다른 환경에 따라 다른 설정 값(DB 정보, 포트, 로깅 레벨 등)을 적용하는 기능

### 설정 적용 방법
1. 설정 파일 분리
- `application-{profile}.yml` 혹은 `.properties`

2. `application.yml`에 명시
2-2. `JVM 옵션` 설정해 Jar 실행
    ```
    # 'prod' 프로파일로 애플리케이션 실행
    java -jar -Dspring.profiles.active=prod my-app.jar
    ```
2-3. `@ActiveProfiles("test")`

## Spring Bean의 Scope(싱글톤, 프로토타입 등) 차이점과 활용 사례는 무엇인가요?

| 스코프         | 정의                                                       | 생성 시점                  | 활용 사례                                                    |
|----------------|------------------------------------------------------------|----------------------------|-------------------------------------------------------------|
| Singleton      | Spring 컨테이너 내에서 단 하나의 인스턴스만 생성되어 공유됨. | 컨테이너 시작 시 (즉시 로딩)  | (기본값) 대부분의 Service, Repository, Controller. 상태를 갖지 않는(Stateless) 객체 |
| Prototype      | 빈을 요청(주입)할 때마다 매번 새로운 인스턴스를 생성함.    | getBean() 또는 주입이 발생할 때 | 상태를 가져야 하는(Stateful) 객체 (예: 사용자별 장바구니 객체) |
| Request        | HTTP 요청이 발생할 때마다 새로운 인스턴스를 생성하고, 요청이 끝나면 소멸됨. | HTTP 요청 시작 시             | HTTP 요청마다 고유해야 하는 정보 (예: 사용자 인증 정보 객체) |
| Session        | HTTP 세션이 생성될 때마다 새로운 인스턴스를 생성하고, 세션이 만료되면 소멸됨. | HTTP 세션 생성 시             | 로그인한 사용자의 세션 정보 (예: 로그인 유저 객체)         |


## Spring의 이벤트 발행 및 리스너(Event Listener) 메커니즘에 대해 설명해주세요.

### Spring 이벤트 메커니즘
- Spring의 이벤트 메커니즘은 **옵저버(Observer) 패턴**을 구현하여, 한 컴포넌트(발행자)가 다른 컴포넌트(구독자)와 직접적인 의존 관계 없이 상태 변화나 이벤트를 전달하는 방식

### 주요 구성 요소

- **Event(이벤트 객체)**  
   - 발행자가 전달할 데이터나 상태를 담은 객체
   - 보통 POJO(Plain Old Java Object)로 생성

- **ApplicationEventPublisher(발행자)**  
   - 이벤트를 발행하는 주체로, 서비스 클래스에서 주입받아 사용

- **@EventListener(구독자)**  
   - 이벤트를 수신하고 처리하는 메서드에 사용하는 어노테이션
   - 이 어노테이션이 붙은 메서드는 Spring이 자동으로 리스너로 등록

### 동작 흐름
1. **서비스에서 이벤트 발행**  
   - 이벤트가 발생해야 하는 서비스(예: `UserService`)가 `ApplicationEventPublisher`를 주입
2. **이벤트 발행**  
   - 예시: `publisher.publishEvent(new UserRegisteredEvent(user));`  
   - 특정 이벤트를 발행. 이때, `UserRegisteredEvent`는 이벤트 객체
3. **이벤트 수신 및 처리**  
   - `@EventListener` 어노테이션이 붙은 메서드가 해당 이벤트를 파라미터로 받아 처리  
   - 예시: `@EventListener public void sendWelcomeEmail(UserRegisteredEvent event) { ... }`  
   - `sendWelcomeEmail` 메서드는 이벤트를 수신하고 환영 메일을 발송하는 로직을 처리

### 장점

- **느슨한 결합**: 핵심 로직(회원 가입)과 부가적인 로직(환영 메일 발송)을 분리할 수 있어, 코드의 유지보수성과 확장성을 높임

### 비동기 처리

- `@EventListener`에 `@Async` 어노테이션을 사용하면 해당 리스너를 **비동기적**으로 처리할 수 있음  
  - 메인 스레드는 즉시 반환되고, 리스너는 별도의 스레드에서 실행

  ```java
  @EventListener
  @Async
  public void sendWelcomeEmail(UserRegisteredEvent event) {
      // 환영 메일 발송 로직
  }
    ```

## 커스텀 어노테이션을 생성하고 이를 Spring에서 활용하는 방법은 무엇인가요?
### 생성 방법
1. `@interface` 키워드를 사용하여 어노테이션을 정의
2. `@Target` 어노테이션을 어디에 적용할지(메서드, 클래스, 파라미터 등) 지정
3. `@Retention` 어노테이션 정보를 언제까지 유지할지(보통 RUNTIME) 지정
4. `@Inherited` 상속 가능 여부를 지정
5. 메타 어노테이션: 다른 어노테이션의 기능을 조합

```Java
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.lang.annotation.*;

@Target(ElementType.TYPE) // 클래스/인터페이스에 적용
@Retention(RetentionPolicy.RUNTIME)
@Transactional(readOnly = true) // (A) 트랜잭션 기능 추가
@Service // (B) 서비스 빈으로 등록
public @interface ReadOnlyService { 
    // @Service + @Transactional(readOnly=true)을 합친 새 어노테이션
}

// [활용]
@ReadOnlyService
public class MyUserService {
    // 이 클래스는 @Service와 @Transactional(readOnly=true)이 적용됨
}
```
