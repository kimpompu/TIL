# 251122 TIL

## Redis에서 Key 네임스페이스(예: Key prefix)를 사용하는 이유와 장점은 무엇인가요?

### 사용 이유

1. 논리적 그룹화 : 수만 개의 키 중에서 데이터의 도메인(User, Product, Order 등)을 쉽게 식별할 수 있습니다. RDB의 'Table'과 같은 역할
2. 키 충돌 방지 : 서로 다른 도메인에서 같은 ID(예: id=100)를 사용하더라도 user:100, order:100과 같이 구분
3. 관리 및 조회 용이성 : SCAN 명령어와 패턴 매칭(MATCH user:*)을 사용하여 특정 도메인의 데이터만 조회하거나 관리(삭제, 마이그레이션)
4. 가독성 : 개발자가 키 이름만 보고도 어떤 데이터인지 직관적으로 파악할 수 있어 디버깅에 유리

| 구성 요소 | 예시 (Example) | 설명 |
| :--- | :--- | :--- |
| **Entity (개체)** | `user`, `product` | RDB의 테이블 명에 해당 |
| **ID (식별자)** | `1234`, `uuid-v4` | RDB의 Primary Key (PK)에 해당 |
| **Field (속성)** | `email`, `stock` | 특정 속성을 나타내는 접미사 |
| **전체 키 예시** | `user:1234:email` | 사용자 1234의 이메일 주소 데이터 |

## Redis를 활용한 세션 관리 구현의 장점과 고려해야 할 단점은 무엇인가요?

### 장점
1. 중앙 집중식 저장소 : 여러 웹 서버(WAS)가 하나의 Redis를 바라보게 하여, 사용자가 어떤 서버에 접속하더라도 로그인 상태(세션)를 유지(Sticky Session 불필요)
2. 고속 접근 : 인메모리 기반이므로 디스크 기반 DB보다 세션 조회/갱신 속도가 훨씬 빨라 전체 응답 속도를 높임
3. TTL 자동 관리 : Redis의 만료 시간(Expire) 기능을 통해 세션 타임아웃을 애플리케이션 로직 없이 자동으로 처리

### 단점 및 고려사항
1. 직렬화/역직렬화 비용 : 객체(Java Object 등)를 Redis에 저장하기 위해 JSON이나 Byte 배열로 변환하는 과정에서 CPU 오버헤드가 발생
2. 메모리 비용 : 동시 접속자가 매우 많을 경우 세션 데이터가 메모리를 많이 차지하여 비용이 증가
3. 단일 실패 지점(SPOF ): Redis 서버가 죽으면 모든 사용자가 로그아웃되는 사태가 발생하므로, 반드시 Sentinel이나 Cluster를 통한 고가용성(HA) 구성이 필요