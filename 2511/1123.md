# 251123 TIL

## Redis의 데이터 복제(replication) 메커니즘과 이를 통한 데이터 가용성 확보 방법에 대해 설명해주세요.
- 리더-팔로워(Master-Replica) 기반의 비동기 복제 메커니즘을 사용

### 구조
- 하나의 마스터(Master) 인스턴스가 쓰기(Write) 작업을 처리하고, 다수의 레플리카(Replica) 인스턴스가 마스터의 데이터를 복제하여 읽기(Read) 작업을 분산 처리

### 매커니즘
1. 연결
- 레플리카가 REPLICAOF (또는 이전 버전의 SLAVEOF) 명령을 사용하여 마스터에 연결

2. 초기 동기화 (Full Resynchronization)
- 최초 연결 시 또는 부분 동기화가 불가능할 때 발생
- 마스터는 BGSAVE 명령을 실행하여 메모리 데이터를 디스크에 RDB 스냅샷으로 저장
  RDB 파일을 레플리카에게 전송
  RDB 생성 중 발생한 모든 쓰기 명령은 복제 백로그(Replication Backlog) 버퍼에 기록되며, RDB 파일 전송이 완료되면 이 명령 스트림을 레플리카에게 보냄
  레플리카는 RDB를 로드하고 명령 스트림을 적용하여 마스터와 동일한 상태

3. 부분 동기화 (Partial Resynchronization)
- 네트워크 문제 등으로 연결이 잠깐 끊겼을 때 발생
- 마스터와 레플리카는 offset과 Replication ID를 공유하며, 레플리카는 연결 복구 후 자신이 놓친 명령(커맨드)의 일부만 복제 백로그 버퍼에서 가져와 적용합니다. 이는 Full Resync보다 훨씬 빠름

| 메커니즘 | 설명 | 가용성 기여 |
| :--- | :--- | :--- |
| **읽기 확장 (Read Scaling)** | 레플리카를 통해 읽기 트래픽을 분산하여 마스터의 부하를 줄이고 전체 시스템 응답 속도를 향상시킵니다. | 트래픽 집중으로 인한 서비스 중단 위험 감소 |
| **장애 복구 (Failover)** | 마스터 인스턴스에 장애가 발생하면 레플리카 중 하나를 새로운 마스터로 승격하여 서비스 중단을 최소화합니다. | 단일 실패 지점(Single Point of Failure) 제거 |
| **Redis Sentinel** | **자동 Failover**를 구현하는 공식 솔루션입니다. Sentinel 프로세스가 마스터와 레플리카의 상태를 모니터링하다가 마스터 다운 감지 시, 투표를 통해 레플리카 중 하나를 새로운 마스터로 자동 승격시키고 클라이언트에게 새 마스터 정보를 제공합니다. | **수동 개입 없는** 높은 가용성 보장 |
| **Redis Cluster** | 데이터 샤딩(Sharding)을 통한 **확장성**과 함께, 각 샤드(마스터)마다 레플리카를 두어 장애 발생 시 자동 Failover를 제공합니다. | 대규모 데이터셋 및 최고 수준의 가용성 요구 사항 충족 |

## Redis에서 데이터 정합성을 보장하기 위한 방법에는 어떤 것들이 있으며, 각각의 한계는 무엇인가요?

### Redis 데이터 정합성(Consistency) 확보 방법 및 한계

| 정합성 확보 방법 | 설명 | 정합성 관련 이점 | 한계점 |
| :--- | :--- | :--- | :--- |
| **비동기 복제** | 마스터가 쓰기 작업이 완료되자마자 응답하고, 이후 백그라운드에서 레플리카로 데이터를 복제합니다. | 고성능, 낮은 지연 시간(Low Latency) | **최종 일관성(Eventual Consistency)**만 보장. 복제 지연(Replication Lag) 시간 동안 마스터와 레플리카의 데이터가 다를 수 있음. |
| **`WAIT` 명령어** | 마스터에서 쓰기 명령 실행 후, 지정된 수의 레플리카가 해당 쓰기 명령을 실제로 수신하고 적용했음을 비동기적으로 확인하기 위해 블로킹합니다. | 특정 시점까지 **부분적 동기화(Semi-Synchronous)** 보장. 데이터 유실 가능성을 줄임. | **완전한 동기식(Fully Synchronous) 복제가 아님.** `WAIT` 완료 후 마스터가 크래시 나면 데이터가 유실될 수 있음. |
| **Redis Transactions** | `MULTI`, `EXEC`, `WATCH`를 사용하여 여러 명령을 원자적(Atomic)으로 실행합니다. 트랜잭션 내의 모든 명령은 단일 단계로 실행되거나 전혀 실행되지 않습니다. | 여러 명령의 **원자성(Atomicity)** 보장. 명령 실행 중 다른 클라이언트의 개입 방지. | **ACID 트랜잭션이 아님.** `WATCH`를 사용한 낙관적 잠금(Optimistic Locking)만 지원하며, 트랜잭션 내 명령 오류 시 **롤백(Rollback) 기능이 없습니다.** |
| **Lua 스크립팅** | Lua 스크립트를 사용하여 여러 Redis 명령을 하나의 스크립트 내에서 실행합니다. 이 스크립트 자체는 원자적으로 처리됩니다. | 복잡한 로직에서도 **강력한 원자성** 보장. | 스크립트 실행 시간이 길어지면 **Redis 서버 전체가 블로킹**될 수 있음. 복잡한 로직은 디버깅이 어려움. |
| **Persistence (RDB/AOF)** | 데이터 유실을 방지하기 위해 디스크에 데이터를 저장합니다. | 서버 재시작 시 **최종 상태의 데이터** 복구 가능. **내구성(Durability)** 보장. | AOF `everysec` 설정 시 1초 동안의 데이터 유실 가능성이 있으며, RDB는 가장 최근의 스냅샷 시점 이후 데이터 유실 가능성이 있음. |