# 251121 TIL

## Redis에서 Lua 스크립트를 사용하는 이유와, 스크립팅 기능이 주는 이점은 무엇인가요?

### 사용 이유 및 이점

1. 원자성(Atomicity)보장
    - Redis는 단일 스레드로 동작하므로, Lua 스크립트가 실행되는 동안 다른 클라이언트의 명령어는 실행되지 않음
    - 이를 통해 WATCH나 복잡한 트랜잭션 관리 없이도 완벽한 트랜잭션(Race Condition 방지)을 보장

2. 네트워크 오버헤드 감소
    - 여러 개의 명령어를 클라이언트와 서버 간에 주고받는 대신, 하나의 스크립트로 묶어서 한 번만 요청을 보냄
    - 이는 네트워크 왕복 시간(RTT, Round Trip Time)을 획기적으로 감소시킴

3. 서버 측 연산 활용
    - 데이터를 클라이언트로 가져와서 가공하고 다시 저장하는 대신, 데이터가 있는 서버 내부에서 로직을 처리하므로 훨씬 효율적

4. 재사용성
    - 스크립트를 SCRIPT LOAD를 통해 서버에 캐싱해 두고 SHA1 해시값만으로 호출하여 대역폭을 더욱 절약할 수 있음

| 특징 | 일반 명령어 방식 | Lua 스크립트 방식 |
| :--- | :--- | :--- |
| **트랜잭션** | `MULTI`/`EXEC`/`WATCH` 조합 필요 | 스크립트 자체가 원자적으로 실행됨 |
| **네트워크 통신** | 명령어 개수만큼 왕복 발생 | 단 1회의 요청으로 처리 가능 |
| **데이터 처리 위치** | 클라이언트가 데이터 조회 후 처리 | Redis 서버 내부에서 직접 처리 |
| **복잡도** | 클라이언트 로직이 복잡해질 수 있음 | 서버 측 로직으로 캡슐화 가능 |

## Redis의 메모리 관리 전략과, 메모리 부족 시 발생할 수 있는 문제 및 해결 방법에 대해 설명해주세요.

### 메모리 관리 전략
- Maxmemory 설정 : redis.conf에서 maxmemory 지시어를 통해 Redis가 사용할 수 있는 최대 메모리 양을 제한
- Eviction(방출) 정책 : 메모리 한계에 도달했을 때 어떤 데이터를 삭제할지 결정(LRU, LFU 등)
- 메모리 단편화(Fragmentation) 관리 : OS가 할당한 메모리 페이지와 실제 데이터 크기 간의 차이로 발생하는 낭비를 줄이기 위해 jemalloc과 같은 메모리 할당자를 사용

### 메모리 부족 시 문제 및 해결 방법
1. 쓰기 불가(Write Error) : maxmemory에 도달하고 Eviction 정책이 noeviction이면 쓰기 요청 시 에러를 반환
2. OOM Killer 작동 : 시스템 전체 메모리가 부족하면 리눅스 커널의 OOM Killer가 Redis 프로세스를 강제로 종료시킬 수 있음
3. Swap 사용으로 인한 성능 저하 : 디스크 스왑(Swap)이 발생하면 속도가 급격히 느려져 Redis의 장점인 '빠른 속도'가 사라짐

| 상황 | 문제점 | 해결 방법 (Solutions) |
| :--- | :--- | :--- |
| **Eviction 불가** | 신규 데이터 저장 실패 (에러 반환) | TTL 설정 확인, `allkeys-lru` 등으로 정책 변경 |
| **단편화 증가** | 실제 데이터보다 많은 메모리 점유 | `activedefrag` 설정 활성화, 서버 재시작 |
| **물리 메모리 한계** | OOM Killer에 의한 프로세스 종료 | Redis Cluster로 스케일 아웃(Scale-out), 메모리 증설 |
| **Swap 발생** | 급격한 성능 저하 (Latency 증가) | `maxmemory`를 물리 메모리의 70~80%로 제한 설정 |
