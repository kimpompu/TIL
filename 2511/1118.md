

## Spring WebFlux와 Spring MVC의 차이점 및 사용 시나리오는 무엇인가요?

| 구분 | Spring MVC (Blocking) | Spring WebFlux (Non-blocking) |
|------|-------------------------|--------------------------------|
| 프로그래밍 모델 | 명령형 (Imperative) | 반응형 (Reactive) - Reactor 라이브러리 (Mono, Flux) |
| 스레드 모델 | 스레드 풀 (Thread Pool) 기반 | 이벤트 루프 (Event Loop) 기반 (적은 수의 고정 스레드) |
| I/O 모델 | Blocking I/O (동기) | Non-blocking I/O (비동기) |
| 주요 사용 사례 | - 대부분의 표준 CRUD 애플리케이션<br>- 동기/블로킹 작업이 많은 경우<br>- 개발자가 반응형 프로그래밍에 익숙하지 않은 경우 | - 대규모 동시 접속 처리 (예: 실시간 채팅, 스트리밍)<br>- 비동기 I/O가 잦은 경우 (다른 마이크로서비스 호출)<br>- 높은 응답성과 자원 효율성이 요구될 때 |
| 서버 | Tomcat (기본값), Jetty, Undertow | Netty (기본값), Tomcat, Jetty (비동기 지원) |


## Spring에서 비동기 처리(Asynchronous Processing)를 구현하는 방법에 대해 설명해주세요.

### 구현방법

1. @Async 어노테이션 사용 (가장 일반적)

- **@EnableAsync**: 메인 애플리케이션 또는 설정 클래스에 붙여 비동기 기능을 활성화  
- **@Async**: 비동기로 실행할 메서드에 붙임  
- **반환 타입**
  - 반환 값이 필요 없을 때: `void`
  - 반환 값이 필요할 때:  
    - `Future<T>`  
    - `CompletableFuture<T>`  
    - `ListenableFuture<T>` (Spring 4.0+)

- 예시 코드
    ```java
    @EnableAsync
    @Configuration
    public class AsyncConfig { /* ... */ }

    @Service
    public class EmailService {

        @Async // 이 메서드는 별도의 스레드에서 실행됨
        public CompletableFuture<Boolean> sendEmail(String to) throws InterruptedException {
            // 시간이 오래 걸리는 작업 시뮬레이션
            Thread.sleep(3000); 
            System.out.println("Email sent to: " + to);
            return CompletableFuture.completedFuture(true);
        }
    }

2. WebClient 사용 (Spring WebFlux)
- WebFlux의 WebClient는 Non-blocking I/O 기반으로 동작
- 기본적으로 비동기 방식으로 외부 API 호출 수행
- Reactor 타입(Mono, Flux) 반환

3. 이벤트 리스너 활용 (@EventListener + @Async)

- Spring 이벤트가 발생했을 때,
    해당 이벤트를 처리하는 메서드에 @Async를 붙여 비동기 처리 가능
    - 주문 완료 이벤트 → 이메일 발송이나 알림 처리 등을 비동기 실행

## Logback을 이용한 Spring Boot의 로깅 설정과 관리 방법은 무엇인가요?

### 기본 설정
1. application.yml (또는 .properties) 파일을 통해 설정을 관리

2. logging.level.{패키지} : 특정 패키지의 로그 레벨(DEBUG, INFO, WARN, ERROR)을 지정

3. logging.file.name / logging.file.path : 로그를 파일로 출력할 경로를 지정

    ```yml
    logging:
    level:
        root: INFO # 전체 기본 레벨은 INFO
        com.example.myapp: DEBUG # 우리 앱 패키지는 DEBUG 레벨로 설정
    file:
        name: logs/my-app.log # 로그 파일 저장 위치
    ```

### 고급 설정
- `logback-spring.xml`
    - 콘솔 출력 형식, 파일 롤링(Rolling) 정책(시간별/용량별 분리), 프로파일별(dev, prod) 다른 로그 설정 등 복잡한 설정이 필요할 때 사용
    - src/main/resources 경로에 logback-spring.xml 파일을 생성하면 Spring Boot가 이를 자동으로 인식하여 적용
    - <springProfile name="..."> 태그를 사용하여 프로파일별로 다른 Appender(출력 대상)나 로거(Logger) 설정


## HttpMessageConverter의 역할과 Spring에서의 메시지 변환 과정을 설명해주세요.

### HttpMessageConverter
- HTTP 요청 및 응답의 Body를 자바 객체로 변환하거나, 그 반대로 변환

1. 역할
- 요청 (HTTP Request → 자바 객체)
    클라이언트가 보낸 HTTP Body(예: JSON, XML)를 @RequestBody 어노테이션이 붙은 자바 객체(DTO)로 **역직렬화(Deserialize)**

- 응답 (자바 객체 → HTTP Response)
    @ResponseBody 또는 @RestController가 반환하는 자바 객체를 HTTP Body(예: JSON)로 **직렬화(Serialize)**

2. 과정
    1. 클라이언트가 JSON 데이터를 Body에 담아 POST 요청(Content-Type: application/json)
    2. DispatcherServlet은 HandlerAdapter를 통해 HttpMessageConverter 목록을 확인
    3. 요청 헤더의 Content-Type과 @RequestBody의 객체 타입을 보고, **MappingJackson2HttpMessageConverter**가 이 변환을 처리할 수 있다고 판단
    4. Converter가 JSON 문자열을 읽어 @RequestBody로 지정된 자바 객체로 변환(역직렬화)한 뒤 컨트롤러 메서드에 전달

## RestTemplate과 WebClient의 차이점 및 사용 사례에 대해 설명해주세요.
| 구분 | RestTemplate | WebClient |
|------|---------------|------------|
| I/O 모델 | Blocking I/O (동기) | Non-blocking I/O (비동기) |
| API 스타일 | 명령형 (Imperative) | 반응형 (Reactive) - Mono, Flux 반환 |
| 스레드 모델 | 요청당 1개의 스레드 점유 | 이벤트 루프 기반 (적은 스레드로 동시 처리) |
| 프로젝트 | Spring MVC | Spring WebFlux (MVC에서도 사용 가능) |
| 상태 | 유지보수 모드 (Maintenance Mode) | Spring 5부터 권장되는 방식 |
| 사용 사례 | - 간단한 동기식 호출이 필요할 때<br>- 기존 Spring MVC 프로젝트 | - 비동기/대규모 API 호출이 필요할 때<br>- MSA 환경에서 서비스 간 통신<br>- Spring WebFlux 프로젝트 |


## @Scheduled 애노테이션을 사용한 스케줄링 작업 구현 방법은 무엇인가요?
### 구현방법
1. 클래스에 `@EnableScheduling` 어노테이션을 추가
2. 주기적으로 실행하고 싶은 메서드에 `@Scheduled` 어노테이션
    ```
    @EnableScheduling // 스케줄링 활성화
    @Component
    public class ScheduledTasks {

        // 이전 작업 '시작' 후 1000ms(1초) 마다 실행
        @Scheduled(fixedRate = 1000)
        public void reportCurrentTime() {
            System.out.println("현재 시간: " + LocalDateTime.now());
        }

        // 매일 오전 4시 30분에 실행
        @Scheduled(cron = "0 30 4 * * *") 
        public void cleanupTask() {
            // 데이터 정리 로직
        }
    }
    ```

## Spring Boot Starter의 개념과 주요 Starter들의 역할에 대해 설명해주세요.
- 특정 목적을 달성하기 위해 필요한 의존성(라이브러리)들의 묶음
- 의존성 설정을 단순화

| Starter 이름 | 역할 및 포함 라이브러리 |
|--------------|--------------------------|
| `spring-boot-starter-web` | REST API 및 웹 애플리케이션 구축. (Tomcat, Spring MVC, Jackson 포함) |
| `spring-boot-starter-data-jpa` | JPA 기반의 DB 접근. (Hibernate, HikariCP, Spring Data JPA, JDBC 포함) |
| `spring-boot-starter-test` | 테스트를 위한 통합 라이브러리. (JUnit 5, Mockito, AssertJ, Hamcrest 포함) |
| `spring-boot-starter-security` | 인증 및 인가 기능. (Spring Security Core, Web Security 포함) |
| `spring-boot-starter-validation` | 데이터 유효성 검사. (Hibernate Validator 등 Bean Validation API 구현체 포함) |

## Java Config와 XML Config를 통한 Bean 등록 및 설정 방식의 차이점은 무엇인가요?
| 구분 | XML Config (과거) | Java Config (현재 표준) |
|------|----------------------|----------------------------|
| 설정 파일 | .xml 파일 (applicationContext.xml) | .java 클래스 (@Configuration) |
| 빈 등록 | `<bean id="..." class="...">` 태그 사용 | @Bean 어노테이션이 붙은 메서드 |
| 타입 안전성 | 컴파일 시점 오류 확인 불가 (오타가 있어도 실행해봐야 앎) | 컴파일러가 타입을 체크해주므로 안전함 |
| 가독성/리팩토링 | XML 문법을 따로 알아야 하며 리팩토링이 어려움 | 자바 코드이므로 IDE의 지원(자동완성, 리팩토링) 용이 |

## 최신 Spring 버전에서 추가된 기능 및 개선 사항에 대해 설명해주세요.
- Java 17 기준 : Spring Boot 3.0부터는 Java 17이 최소 요구 사항(Java 8, 11 지원 중단)
- Jakarta EE 전환 : javax.* 패키지명(예: javax.persistence, javax.servlet)이 **jakarta.***로 변경
- GraalVM Native Image 공식 지원 : JVM 없이 실행 가능한 네이티브 이미지 컴파일을 공식 지원하여, 초고속 부팅과 낮은 메모리 사용량을 제공(Serverless 환경에 유리)
- Observability(관측성) 통합 : Micrometer Tracing이 통합되어 분산 추적 및 메트릭 수집이 훨씬 강력하고 쉬워짐
- HTTP Interface Client : 마치 Spring Data JPA처럼, 인터페이스 선언만으로 HTTP 클라이언트를 구현할 수 있는 기능이 추가(Declarative HTTP Client)