# 251101 TIL

## Checked Exception과 Unchecked Exception의 차이점은 무엇인가요?
- 컴파일 시점에서의 예외 처리 강제 여부
- 예외 발생하는 원인

| 특징 | Checked Exception (확인된 예외) | Unchecked Exception (미확인 예외/런타임 예외) |
| :--- | :--- | :--- |
| **처리 시점** | **컴파일 시점**에 확인 (강제) | **실행(런타임) 시점**에 확인 (강제 아님) |
| **처리 강제성** | 반드시 `try-catch`로 **처리**하거나 `throws`로 **선언**해야 함. (안 하면 컴파일 에러 발생) | 명시적으로 처리할 필요 없음. (처리해도 무방) |
| **상속 구조** | `java.lang.Exception` 클래스를 상속받는 클래스들 (단, `RuntimeException`과 그 하위 클래스는 제외) | `java.lang.RuntimeException` 또는 `java.lang.Error` 클래스를 상속받는 클래스들 |
| **발생 원인** | 프로그램의 **외부 환경**이나 **예측 가능한 상황**에서 발생 (복구 가능성이 있음) | **프로그래밍 로직 오류**나 **잘못된 API 사용**에서 주로 발생 (대부분 복구 불가능) |
| **예시** | `IOException`, `SQLException`, `FileNotFoundException` | `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException` |

## try-with-resources 구문의 동작 원리를 설명해주세요.
- Java 7에 도입
- 파일 스트림, 데이터베이스 연결 등 사용 후 반드시 닫아야 하는 자원을 안전하고 간결하게 처리하기 위해 사용

### 동작 원리
1. 자동 자원 해제 보장 : try 괄호 () 안에 선언된 자원은 try 블록이 정상적으로 완료되거나 예외가 발생하더라도 자동으로 자원의 close() 메서드가 호출되도록 보장

2. AutoCloseable 인터페이스: `try-with-resources` 구문에 사용될 수 있는 자원은 반드시 `java.lang.AutoCloseable` 인터페이스(혹은 이를 상속받는 `java.io.Closeable` 인터페이스)를 구현. 이 인터페이스에는 자원을 닫는 `void close() throws Exception` 메서드가 정의.

3. 내부 동작 : 컴파일러는 이 구문을 일반적인 `try-catch-finally` 블록으로 변환. 변환된 코드에서는 finally 블록에 자원의 close() 메서드를 호출하는 로직이 추가.

4. 예외 처리 (Suppressed Exceptions) : 
    - `try` 블록에서 예외가 발생하고, 자원을 닫는 close() 메서드에서도 또 다른 예외가 발생했을 때, `try-with-resources`는 try 블록에서 발생한 예외를 주 예외로 throw.
    - close() 메서드에서 발생한 예외는 '`억제된 예외(Suppressed Exception)`'로 처리되어 주 예외에 첨부. 이는 원본 문제를 파악하기 쉽게 함. (기존 finally 방식은 finally에서 발생한 예외만 던져서 원본 예외를 덮어쓸 수 있었음).

5. 자원 해제 순서 : 여러 개의 자원을 선언했을 경우, 자원들은 선언된 역순으로 close() 메서드가 호출됩니다.

## equals()와 hashCode()의 관계와 오버라이딩 시 주의사항은 무엇인가요?

### 관계

| 규칙 | 내용 |
| :--- | :--- |
| **`equals()` 재정의 시** | **항상** `hashCode()`도 **함께 재정의**해야 합니다. |
| **핵심 계약** | `equals()` 메서드가 `true`를 반환하는 두 객체(`x`와 `y`)는, `hashCode()` 메서드를 호출했을 때 **반드시 같은 정수 값**을 반환해야 합니다. (`x.equals(y)`가 참이면 `x.hashCode() == y.hashCode()`도 참이어야 함) |
| **역관계** | `hashCode()`가 **같은 값**을 반환하는 두 객체가 `equals()` 메서드에서 `false`를 반환하는 것은 **허용**됩니다. (해시 충돌) |
| **일관성** | 애플리케이션 실행 중 객체의 `equals()` 비교에 사용되는 정보가 변경되지 않는 한, `hashCode()`는 여러 번 호출되어도 **항상 같은 값**을 반환해야 합니다. |

### 주의사항

| 구분 | 주의사항 |
| :--- | :--- |
| **`equals()` 오버라이딩** | 1. **대칭성(Symmetry):** `x.equals(y)`가 참이면 `y.equals(x)`도 참이어야 합니다. <br> 2. **추이성(Transitivity):** `x.equals(y)`와 `y.equals(z)`가 참이면 `x.equals(z)`도 참이어야 합니다. <br> 3. **일관성(Consistency):** 객체가 수정되지 않았다면 여러 번 호출해도 일관된 결과를 반환해야 합니다. <br> 4. **Non-nullity:** `x.equals(null)`은 항상 `false`를 반환해야 합니다. |
| **`hashCode()` 오버라이딩** | 1. **`equals()`에 사용된 필드만 사용:** `equals()` 비교에 사용된 필드(객체의 논리적 동등성을 정의하는 필드)만을 사용하여 `hashCode`를 계산해야 합니다. <br> 2. **성능 고려:** 해시 충돌(Collision)을 줄이고 성능을 높이기 위해 해시 코드를 잘 분산시키는 알고리즘을 사용해야 합니다. (일반적으로 `Objects.hash()` 유틸리티 사용 권장) |

## String, StringBuilder, StringBuffer의 차이점을 설명해주세요.

| 특징 | String | StringBuilder | StringBuffer |
| :--- | :--- | :--- | :--- |
| **가변성 (Mutability)** | **불변(Immutable)**: 한 번 생성되면 내용 변경 불가. 변경 시 새 객체 생성. | **가변(Mutable)**: 내용 변경 시 기존 객체 내부에서 변경. | **가변(Mutable)**: 내용 변경 시 기존 객체 내부에서 변경. |
| **스레드 안전성** | **안전함(Thread-Safe)**: 불변 객체이므로 안전함. | **안전하지 않음(Not Thread-Safe)**: 비동기 방식. | **안전함(Thread-Safe)**: 대부분의 메서드가 `synchronized` 처리되어 안전함. |
| **성능 (Performance)** | **느림**: 문자열 변경/연산이 잦을 경우 새 객체가 계속 생성되어 성능 저하. | **가장 빠름**: 동기화 오버헤드가 없고 새 객체 생성이 적어 빠름. | **느림**: 동기화(Synchronization) 오버헤드 때문에 `StringBuilder`보다 느림. |
| **사용 시점** | 문자열이 **고정**되거나 **빈번한 변경**이 없을 때. | **단일 스레드** 환경에서 문자열 **변경/연산**이 많을 때. (가장 일반적인 선택) | **다중 스레드** 환경에서 문자열 **변경/연산**이 많아 **동기화**가 필요할 때. |
| **도입 버전** | JDK 1.0 | JDK 1.5 | JDK 1.0 |