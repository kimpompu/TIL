# 251104 TIL

## 멀티모듈
- 하나의 Gradle/Maven 프로젝트 안에서 여러 모듈(subproject) 로 구성된 구조
- 공통 라이브러리를 분리해 여러 애플리케이션을 함께 관리 

### settings.gradle
```groovy
    rootProject.name = 'testrepo'

    include 'common'
    include 'domain'
    include 'api'
    include 'batch'
```

### 루트의 build.gradle
```groovy
    plugins {
        id 'java'
        id 'io.spring.dependency-management' version '1.1.5' apply false
        id 'org.springframework.boot' version '3.3.0' apply false
    }

    allprojects {
        group = 'com.example'
        version = '1.0.0'

        repositories {
            mavenCentral()
        }
    }

    subprojects {
        apply plugin: 'java'

        sourceCompatibility = '17'
        targetCompatibility = '17'

        dependencies {
            testImplementation 'org.springframework.boot:spring-boot-starter-test'
        }

        test {
            useJUnitPlatform()
        }
    }

```

### Executable JAR / Plain JAR

| 구분                    | 이름        | 역할                              | 특징                                                              |
| --------------------- | --------- | ------------------------------- | --------------------------------------------------------------- |
| **Executable JAR** | `bootJar` | Spring Boot Application 실행용 JAR | 실행 가능한 `main()` 포함, 내부에 모든 dependency를 포함                       |
| **Plain JAR**      | `jar`     | 라이브러리용 JAR                      | 실행 불가능, 외부 모듈에서 `implementation project(':module')` 으로 참조할 때 사용 |

```groovy
    // 공통모듈(commonn)
    tasks.named('bootJar') {
        enabled = false
    }
    tasks.named('jar') {
        enabled = true
    }
```

## HashMap의 동작 원리와 해시 충돌 해결 방법을 설명해주세요.

### 동작원리
- HashMap은 내부적으로 버킷(bucket) 배열을 사용하며, 이 배열의 크기는 보통 2의 거듭제곱
- put(key, value) 호출 시 key.hashCode()로 해시값을 구한 뒤 내부적으로 추가 해싱을 거쳐 버킷 인덱스를 (table.length-1) & hash 방식으로 계산
- 해당 버킷이 비어 있으면 새 노드를 삽입하고, 이미 노드가 있다면 키가 같은지 equals()로 비교해서 값 교체하거나, 키가 다르면 리스트 끝에 새 노드를 추가
- get(key)은 동일한 해시→인덱스 계산 후 해당 버킷 내 노드들을 순회하면서 hash와 equals() 체크로 대상 값을 탐색
- 저장된 원소 수가 임계치(예: capacity × loadFactor)를 넘으면 버킷 배열을 두 배로 확장(resize)하고 기존 엔트리들을 재배치(리해시)

### 해시 충돌 처리 방법

- 해시 충돌 : 서로 다른 키들이 동일한 버킷 인덱스를 갖는 경우
    - 충돌이 발생하면 기본적으로 ‘체이닝(chaining)’ 방식, 즉 해당 버킷 내부에 링크드 리스트 형태로 여러 엔트리를 저장
    - 자바 8 버전부터는 한 버킷 안에 저장된 노드 수가 일정 기준을 넘으면(예: 8개) 이 리스트를 트리(레드-블랙 트리)로 전환하여 탐색 성능을 향상
    - 키 객체는 hashCode()와 equals()를 적절히 오버라이드하여 해시 분포가 균형 있도록 하는 것이 중요

## ConcurrentHashMap의 동작 원리와 HashMap과의 차이점은 무엇인가요?

### ConcurrentHashMap의 동작 원리
- ConcurrentHashMap : 다수 스레드가 동시에 접근 및 수정할 수 있는 환경을 위해 설계된 Map

- `자바 7` 이하: 세그먼트(Segment) 기반 락 → 기본적으로 16개 세그먼트가 있고, 각 세그먼트는 자체 잠금(lock). 하나의 스레드가 특정 세그먼트에 쓰기를 할 때만 해당 세그먼트를 잠그며, 다른 세그먼트는 동시에 접근 가능

- `자바 8` 이상: 세그먼트 개념이 사라지고, HashMap과 유사한 Node<K,V>[] table 배열 사용 + 버킷 수준(bucket-level) 락 및 CAS 기법 사용. 읽기는 대부분 락 없이(volatile 읽기) 가능

- `put()` 동작: 키 해시 → 인덱스 계산 → 버킷이 비어있으면 CAS로 삽입 → 비어있지 않으면 첫 노드 락을 잡고 리스트/트리 순회 후 삽입/업데이트 → 필요시 트리화(treeify) 가능.

- `get()` 동작: 해시 → 인덱스 계산 → 버킷 노드까지 간 뒤 equals()로 비교 → 락 없이도 읽을 수 있어 여러 스레드가 병렬 읽기 가능.

- `리사이징(resize)`: 자바 8 이상에서는 여러 스레드가 협력하여 기존 테이블에서 새 테이블로 버킷을 옮기는 방식으로 동작하며, 전체 맵을 막는 단일 락 방식이 아님

### `HashMap`과 `ConcurrentHashMap`의 주요 차이점

| 구분                           | **HashMap**                                                                    | **ConcurrentHashMap**                                            |
| :--------------------------- | :----------------------------------------------------------------------------- | :--------------------------------------------------------------- |
| **스레드 안정성 (Thread Safety)**  |  스레드 안전하지 않음.<br>멀티스레드 환경에서 동시 수정 시 **데이터 불일치**나 **무한 루프** 가능                 |  스레드 안전.<br>내부적으로 **세분화된 락(lock)** 및 **CAS 연산**으로 동시 접근 안전하게 처리 |
| **null 키 / 값 허용 여부**         |  **null 키 1개**, **null 값 여러 개** 허용                                            |  **null 키/값 허용 안 함** (동시성 환경에서 모호성 방지)                          |
| **락의 범위 및 병렬성**              | 전체 맵 수준에서 동기화 필요 (`Collections.synchronizedMap()` 사용 시 전체 잠금)<br> -> **동시성 저하** | 버킷 단위 락 또는 CAS 방식으로 **미세한 동기화 단위** 적용<br> -> **동시성 및 성능 향상**      |
| **이터레이터 (Iterator) 동작**      | **Fail-Fast**:<br>다른 스레드가 구조 변경 시 `ConcurrentModificationException` 발생         | **Weakly Consistent**:<br>변경 중에도 예외 없이 “일부 반영된 최신 뷰” 제공          |
| **성능 (Performance Context)** | 단일 스레드 환경에서는 **오버헤드 적고 빠름**                                                    | 멀티스레드 환경에서는 **높은 처리량(throughput)** 제공                            |
| **내부 구조 (Java 8 기준)**        | `Node<K,V>[] table` + 체이닝(리스트/트리) 구조                                           | `Node<K,V>[] table` + **버킷 수준 락** + **CAS** 기반 동시 제어             |
| **사용 권장 환경**                 | 단일 스레드, 읽기 중심, 동시 접근 적은 경우                                                     | 멀티스레드, 쓰기/읽기 병행, 높은 동시성 요구되는 경우                                  |
