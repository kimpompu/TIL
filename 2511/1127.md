# 251127 TIL

## static class와 static method를 비교해 주세요.

| 구분 | Static Class (정적 클래스) | Static Method (정적 메서드) |
| :--- | :--- | :--- |
| **정의** | (Java에서는 주로 **정적 중첩 클래스**를 의미) 클래스를 인스턴스화할 수 없으며, 모든 멤버가 `static`이어야 하는 클래스임. (C# 등 일부 언어에서는 일반 클래스에 적용 가능) | 클래스 인스턴스 없이 클래스 이름으로 직접 호출되는 메서드임. |
| **인스턴스화** | 불가능함. | 불가능함. (클래스 인스턴스에 종속되지 않음) |
| **접근** | 내부적으로는 외부 클래스의 `static` 멤버만 접근 가능함. (외부 클래스의 인스턴스 멤버 직접 접근 불가) | 클래스 이름으로 직접 접근하며, 클래스의 **`static` 멤버**만 직접 접근 가능함. (`this` 키워드 사용 불가) |
| **용도** | 유틸리티 기능(예: `java.lang.Math`), 상수 모음, 혹은 외부 클래스의 객체에 의존하지 않는 중첩 클래스에 사용됨. | 인스턴스 상태에 의존하지 않는 기능(순수 함수), 팩토리 메서드, 엔트리 포인트(예: `public static void main`)에 사용됨. |

## static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?

### 이점
- 메모리 효율성(Memory Efficiency) : static 멤버는 클래스가 로드될 때 단 한 번만 메모리(메서드 영역/메타스페이스)에 할당. 따라서 객체를 여러 개 생성해도 메모리 낭비가 없음

- 쉬운 접근성(Easy Access) : 객체를 생성하지 않고도 클래스 이름을 통해 바로 접근할 수 있음(예: ClassName.staticMethod()).

- 공통 데이터 공유(Shared Data) : 모든 인스턴스가 단일 static 변수 복사본을 공유하므로, 전역적인 상수 또는 모든 객체에 공통으로 필요한 상태(예: 객체 수 카운터)를 관리하는 데 유용

- 성능 향상(Performance) : 인스턴스 메서드 호출과 달리 가상 메서드 디스패치 오버헤드가 없어 미세하게 더 빠를 수 있음

### 제약
- 인스턴스 상태 접근 불가(No Instance Access) : static 메서드/블록은 특정 객체와 연결되지 않기 때문에 클래스의 non-static (인스턴스) 멤버(변수나 메서드)를 직접 사용할 수 없음(this 참조가 없음)

- 다형성/오버라이딩 불가(No Polymorphism/Overriding) : static 메서드는 런타임이 아닌 컴파일 시간에 바인딩(정적 바인딩)되므로, 인스턴스 메서드처럼 오버라이딩을 통한 다형성을 구현할 수 없음

- 테스트 용이성 저하(Reduced Testability) : static 멤버는 Mocking(가상 객체 대체)이 어렵거나 불가능하여, 단위 테스트 시 해당 코드를 격리하고 테스트하기가 까다로움

- 전역 상태 및 스레드 안정성(Global State & Thread Safety) : static 변수는 전역 상태로 작동하므로, 멀티스레드 환경에서 데이터 무결성을 위해 명시적인 동기화 처리가 필요

## 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.

1. 클래스 로딩(Class Loading)
    - 소스 코드를 컴파일하면 .class 파일이 생성 
    - JVM의 클래스 로더가 .class 파일을 읽어 메모리(주로 메서드 영역/메타스페이스)에 로드하는 과정에서 static 멤버들이 처리

2. 초기화 (Initialization)

    - static 변수 : static 변수는 클래스가 로드될 때 단 한 번 초기화. 이 과정은 객체의 인스턴스 생성보다 먼저 발생

    - static 초기화 블록 : 이 블록 내의 코드는 static 변수 초기화 직후, 그리고 클래스의 어떤 생성자나 메서드보다 먼저 단 한 번 실행

3. 정적 바인딩 (Static Binding)
    - static 메서드는 컴파일 시점에 호출할 대상이 이미 결정(정적 바인딩 또는 이른 바인딩)
    - 런타임에 어떤 객체인지 확인할 필요가 없어 오버헤드가 줄어들고, 오버라이딩이 불가능

## Java의 Exception에 대해 설명해 주세요.
| 유형 | Checked Exception (컴파일러 검사 예외) | Unchecked Exception (런타임 예외) | Error (에러) |
| :--- | :--- | :--- | :--- |
| **상속** | `java.lang.Exception` 상속 (단, `RuntimeException` 제외) | `java.lang.RuntimeException` 상속 | `java.lang.Error` 상속 |
| **검사 시점** | **컴파일 시점** | **런타임 시점** | **런타임 시점** |
| **처리 의무** | **필수** (`try-catch`로 처리하거나 `throws`로 선언해야 함) | **선택** (프로그래머 실수로 간주되므로 명시적 처리 강제 X) | **불가능** (JVM 자체 문제로 복구 불가능) |
| **예시** | `IOException`, `SQLException`, `FileNotFoundException` | `NullPointerException`, `ArithmeticException`, `ArrayIndexOutOfBoundsException` | `OutOfMemoryError`, `StackOverflowError` |

## 예외처리를 하는 세 방법에 대해 설명해 주세요.

1. `try-catch` 블록을 사용한 처리(Handling)
    - 예외가 발생할 가능성이 있는 코드를 try 블록에 넣고, 예외가 발생하면 즉시 실행 흐름이 해당 예외 유형에 맞는 catch 블록으로 이동하여 예외를 처리
2. `throws` 사용한 위임(Delegating)
    - throws ExceptionType을 선언하여, 이 메서드가 해당 예외를 처리하지 않고 자신을 호출한 곳(호출자)으로 예외 처리를 미룸
3. `finally` 블록을 사용한 정리(Cleanup)
    - try 블록이 정상적으로 완료되든, 예외가 발생하여 catch 블록이 실행되든 관계없이 항상 실행

