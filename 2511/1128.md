# 251128 TIL

## JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.

### JVM
- 정의
    - 자바 바이트코드(.class 파일)를 운영체제(OS)가 이해할 수 있는 기계어로 변환해 실행하는 가상 컴퓨터
- 역할
    - 작성된 자바 코드가 OS나 하드웨어에 종속되지 않고 실행
- 기능
    1. 클래스로더(Class Loader) : 컴파일된 바이트코드를 런타임에 로드하고 링크
    2. 실행 엔진
        - 인터프리터 : 바이트코드를 한 줄씩 읽어 실행
        - JIT(Just-In-Time) 컴파일러 : 반복되는 코드를 네이티브 기계어로 변환하여 캐싱함으로써 성능 최적화
        - 가비지 컬렉터(Garbage Collector) : 더 이상 사용되지 않는 메모리(Heap영역)를 자동으로 회수하여 관리

## 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?

- JVM은 자바(Java) 언어만을 위한 것이 아니라, 바이트코드 규격을 따르는 모든 언어를 실행할 수 있음
- 실행 가능 언어 : Kotlin, Scala, Groovy

## 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
- 전통적으로는 바이트코드로 변환해 VM 위에서 실행했지만, 최근에는 AOT (Ahead-Of-Time) 컴파일 기술이 발전해서 컴파일해서 사용할 수 있음
- GraalVM(Native Image) : 가장 대표적인 기술로, 자바나 코틀린 코드를 운영체제에 맞는 네이티브 실행 파일(기계어)로 미리 컴파일

## VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
| 구분 | 장점 (Pros) | 단점 (Cons) |
| :--- | :--- | :--- |
| **이식성 (Portability)** | OS에 독립적. 한 번 작성하면 어디서든 실행 가능 (WORA) | 각 OS에 맞는 VM 설치가 필요함 |
| **메모리 관리** | GC가 메모리를 자동 관리하여 개발 생산성 향상 및 누수 방지 | GC 동작 시 발생하는 Pause(Stop-the-world)로 인한 성능 예측 어려움 |
| **보안 (Security)** | 샌드박스 환경에서 실행되어 OS 직접 접근을 차단, 안전성 높음 | 네이티브 실행에 비해 한 단계(VM)를 거치므로 실행 속도가 상대적으로 느릴 수 있음 |
| **최적화** | JIT 컴파일러가 런타임 정보를 기반으로 코드 최적화 수행 | 애플리케이션 초기 구동 시간(Warm-up)이 필요함 |

## JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
- 부모-자식 프로세스 관계라고 보기 어려움

- 단일 프로세스 : 운영체제 입장에서 JVM은 하나의 **프로세스(Process)**

- 스레드 기반 : JVM 내부에서 실행되는 자바 프로그램(main 메서드 등)은 별도의 자식 프로세스가 아니라, JVM 프로세스 내의 **스레드(Thread)** 로 동작

- 메모리 공유 : 부모-자식 프로세스는 메모리 공간이 분리되어 있지만, 자바 프로그램은 JVM이 할당받은 힙(Heap) 등의 메모리 공간을 공유

## final 키워드를 사용하면, 어떤 이점이 있나요?
- **불변성(Immutability)** 과 **의도 명확화** 를 위해 사용
- 설계적 명확성 : 이 변수, 메서드, 클래스가 더 이상 변경되거나 상속/오버라이딩되지 않음을 명시하여 코드의 복잡도를 낮춤
- 스레드 안전성(Thread-Safety) : final 변수는 초기화 후 값이 바뀌지 않으므로, 동기화(Lock)없이 여러 스레드에서 안전하게 공유
- 유지보수 : 값이 바뀌지 않아야 할 데이터(상수 등)가 실수로 변경되는 버그를 컴파일시 방지

## 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
- `final`을 단서로 적극적인 최적화를 수행

1. 상수 접기 (Constant Folding)
    - 컴파일 타임에 값을 알 수 있는 static final 변수(상수)는 참조하는 모든 곳에 실제 값(리터럴)을 그대로 하드코딩. 변수 조회가 아닌 값 자체를 사용하므로 속도가 빠름
2. 인라인 최적화(Inlining)
    - `final` 메서드는 오버라이딩될 수 없다는 것이 보장
    - JIT 컴파일러는 메서드 호출(Call Stack 이동) 대신 메서드의 코드를 호출 위치에 직접 복사
3. 보안 검사 생략
    - `final`이면 상속을 통한 악의적인 동작 변경이 불가능
    - 런타임에 일부 타입 체크를 생략