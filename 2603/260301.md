# 260301 TIL

## 브루스 포스
- 가능한 **모든 경우의 수** 확인
- 데이터가 커지면 시간이 오래 걸림
- 시간 복잡도 : $O(N^2)$ ~ $O(2^N)$

```java
// 모든 연속 부분 수열의 합 구하기
for (int start = 0; start < n; start++) {
    int sum = 0;
    for (int i = 0; i < len; i++) {
        sum += elements[(start + i) % n];
    }
    sums.add(sum);
}
```

## 슬라이딩 윈도우
- **고정된 크기의 구간**을 옆으로 밀어 이동하며 계산
- 시간 복잡도 : 보통 $O(N)$

```java
// 모든 연속 부분 수열의 합 구하기
int sum = 0;
// 1. 0번째부터 len길이만큼 합을 구함
for (int i = 0; i < len; i++) sum += elements[i];
sums.add(sum);

// 2. 구간을 한 칸씩 옆으로 밀기
for (int start = 1; start < n; start++) {
    // (이전 합) - (방금 빠진 원소) + (새로 들어온 원소)
    int outIdx = (start - 1) % n;
    int inIdx = (start + len - 1) % n;
    
    sum = sum - elements[outIdx] + elements[inIdx];
    sums.add(sum);
}
```

| 비교 항목 | 브루트 포스 코드 | 슬라이딩 윈도우 코드 |
| :--- | :--- | :--- |
| **연산 방식** | `len`만큼 반복해서 더함 | `out` 빼고 `in` 더함 |
| **중복 계산** | 있음 | 없음 |
| **내부 루프** | 합을 구하는 루프 존재($O(N)$) | 루프 없이 단순 가감($O(1)$) |
| **총 시간 복잡도** | $O(N^2)$(길이별 반복 시 $O(N^3)$) | $O(N)$ (길이별 반복 시 $O(N^2)$) |